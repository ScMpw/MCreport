<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stakeholder PI Status Report – Disruption KPI</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background: #f7f8fa; font-family: 'Inter', Arial, sans-serif; margin:0; padding:0; }
    .main { max-width: 950px; margin: 30px auto; background:#fff; border-radius:18px; padding:36px 32px; box-shadow:0 2px 12px #d1d5db70; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #e5e7eb; padding: 6px 10px; text-align:left; font-size:0.95em; }
    th { background:#e0e7ef; }
    .btn { background:#6366f1; color:#fff; border:none; border-radius:6px; padding:7px 18px; cursor:pointer; font-size:1em; }
    .details-toggle { margin:10px 0 6px 0; }
    .story-table { border-collapse: collapse; width: 100%; margin: 6px 0 18px 0; }
    .story-table th, .story-table td { border: 1px solid #e5e7eb; padding: 4px 7px; font-size: 0.95em; text-align:left; }
    .story-table th { background:#e0e7ef; }
    .chart-section { margin-top: 30px; overflow-x: auto; }
    .chart-section canvas { margin-top: 20px; }
    .rating-zone-description { margin-top: 10px; font-size: 0.9em; }
    .rating-zone-description div { margin-top: 4px; }
    .rating-zone-description span { display:inline-block; width:12px; height:12px; margin-right:6px; vertical-align:middle; }
    .sprint-item { background:#e5e7eb; border-radius:4px; padding:2px 6px; margin-right:6px; display:inline-block; }
    .sprint-item .remove { cursor:pointer; color:#e11d48; margin-left:4px; }
  </style>
</head>
<body>
<div class="main">
  <h1>Disruption KPI Report</h1>
  <div>
    <label>Version:
      <select id="versionSelect" onchange="switchVersion(this.value)">
        <option value="index.html">Velocity</option>
        <option value="index_throughput.html">Throughput</option>
        <option value="index_throughput_week.html">Weekly Throughput</option>
        <option value="index_disruption.html">Disruption</option>
      </select>
    </label>
  </div>
  <div style="margin-top:20px;">
    <label>Jira Domain: <input id="jiraDomain" value="aldi-sued.atlassian.net" size="28"></label>
    <label style="margin-left:10px;">Boards:
      <select id="boardNum" multiple></select>
    </label>
    <button class="btn" onclick="loadDisruption()">Load Data</button>
    <button class="btn" onclick="exportPDF()">Download PDF</button>
  </div>
  <div id="sprintRow" style="margin-top:10px; display:none;">
    <span>Sprints:</span>
    <div id="sprintList" style="display:inline-block;"></div>
  </div>
  <div id="logPanel" style="display:none; white-space:pre-wrap; font-size:0.85em; background:#f3f4f6; border:1px solid #e5e7eb; padding:6px; margin:10px 0; max-height:150px; overflow:auto;"></div>
  <table>
    <thead>
      <tr>
        <th>Sprint</th>
        <th>Initially Planned</th>
        <th>Completed</th>
        <th>Other</th>
        <th>Pulled In</th>
        <th>Blocked Days</th>
        <th>Type Changed</th>
        <th>Moved Out</th>
        <th>Details</th>
      </tr>
    </thead>
    <tbody id="metricsBody"></tbody>
  </table>
  <div id="velocityStats"></div>
  <div id="chartSection" class="chart-section">
    <canvas id="completedChart"></canvas>
    <div class="rating-zone-description">
      <div><span style="background:rgba(254,202,202,0.5);"></span>Alarming: 0…AV-2SD</div>
      <div><span style="background:rgba(254,249,195,0.5);"></span>Concerning: AV-2SD…AV-1SD</div>
      <div><span style="background:rgba(209,250,229,0.5);"></span>Healthy: AV-1SD…AV</div>
      <div><span style="background:rgba(110,231,183,0.5);"></span>Spot-on: AV…AV+1SD</div>
      <div><span style="background:rgba(209,250,229,0.5);"></span>Lively: AV+1SD…AV+2SD</div>
      <div><span style="background:rgba(254,249,195,0.5);"></span>Bloated: AV+2SD…∞</div>
    </div>
    <canvas id="disruptionChart"></canvas>
    <canvas id="cycleChart"></canvas>
  </div>
</div>
<script src="src/logger.js"></script>
<script src="src/jira.js"></script>
<script>
  function appendLog(level, args) {
    const el = document.getElementById('logPanel');
    if (!el) return;
    const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
    el.textContent += `[${level}] ${msg}\n`;
    el.scrollTop = el.scrollHeight;
    el.style.display = '';
  }
  Logger.setLevel('debug');
  Logger.setListener((level, args) => appendLog(level, args));
</script>
<script src="src/disruption.js"></script>
<script src="src/kpis.js"></script>
<script>
  function switchVersion(v){ window.location.href = v; }

  const boardSelect = document.getElementById('boardNum');
  let boardChoices = new Choices(boardSelect, { removeItemButton: true });
  // Keep references to existing Chart.js instances so they can be destroyed
  // when rendering charts multiple times. Without this, Chart.js will throw
  // an error about reusing a canvas that is already in use.
  let completedChartInstance;
  let disruptionChartInstance;
  let cycleChartInstance;
  let sprints = [];
  let removedSprintIds = [];
  let teamVelocityData = {};
  let boardNamesData = {};

  function filterRecentSprints(allSprints, excludeIds = [], desiredCount = 6) {
    const excluded = new Set((excludeIds || []).map(String));
    const sorted = allSprints.slice().sort((a, b) => {
      const ad = a.endDate || a.completeDate || a.startDate || '';
      const bd = b.endDate || b.completeDate || b.startDate || '';
      return ad && bd ? new Date(bd) - new Date(ad) : 0;
    });
    const result = [];
    for (const s of sorted) {
      if (!excluded.has(String(s.id))) result.push(s);
      if (result.length >= desiredCount) break;
    }
    return result;
  }

  function renderSprintList() {
    const wrap = document.getElementById('sprintList');
    if (!wrap) return;
    wrap.innerHTML = sprints.map(s =>
      `<span class="sprint-item">${s.name}<span class="remove" onclick="removeSprint('${s.id}')">&times;</span></span>`
    ).join('');
  }

  function removeSprint(id) {
    const sid = String(id);
    if (!removedSprintIds.includes(sid)) removedSprintIds.push(sid);
    sprints = sprints.filter(s => String(s.id) !== sid);
    renderTable(sprints);
    renderSprintList();
    renderCharts(sprints);
    renderVelocityStats(boardNamesData, teamVelocityData);
  }

  async function populateBoards() {
    const domain = document.getElementById('jiraDomain').value.trim();
    if (!domain) return;
    try {
      const boards = await Jira.fetchBoardsByJql(domain);
      boardChoices.clearChoices();
      boardChoices.setChoices(boards.map(b => ({ value: b.id, label: b.name })), 'value', 'label', true);
    } catch (e) {
      Logger.error('Failed to load boards', e);
    }
  }

  document.getElementById('jiraDomain').addEventListener('change', populateBoards);
  populateBoards();

    async function fetchDisruptionData(jiraDomain, boardNums = []) {
      Logger.info('Fetching disruption data for boards', boardNums.join(','));
      const combined = {};
      const teamVelocity = {};
      const issueCache = new Map();
      try {
        await Promise.all(boardNums.map(async boardNum => {
          const url = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/velocity?rapidViewId=${boardNum}`;
          const resp = await fetch(url, { credentials: 'include' });
          let data = {};
          if (resp.ok) {
            data = await resp.json();
          } else {
            Logger.warn('Velocity report unavailable, falling back to sprint list', resp.status);
          }

          let closed = (data.sprints || []).filter(
            s => s.state === 'CLOSED' && s.startDate && String(s.originBoardId) === String(boardNum)
          );

          if (!closed.length) {
            let allSprints = [];
            let startAt = 0;
            const maxResults = 50;
            let loops = 0;
            while (true) {
              const sUrl = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/sprint?state=closed&maxResults=${maxResults}&startAt=${startAt}`;
              const sResp = await fetch(sUrl, { credentials: 'include' });
              if (!sResp.ok) {
                Logger.error('Failed to fetch sprint list', sResp.status);
                break;
              }
              const sData = await sResp.json();
              const values = sData.values || [];
              allSprints = allSprints.concat(values);
              startAt += values.length;
              loops++;
              if (sData.isLast || values.length < maxResults || loops > 100) break;
            }
            closed = allSprints.filter(
              s => (s.state || '').toUpperCase() === 'CLOSED' && s.startDate && String(s.originBoardId) === String(boardNum)
            );
          }

          closed = filterRecentSprints(closed, removedSprintIds, 6);
          teamVelocity[boardNum] = new Array(closed.length).fill(0);

          await Promise.all(closed.map(async (s, idx) => {
            const surl = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/sprintreport?rapidViewId=${boardNum}&sprintId=${s.id}`;
            try {
              const r = await fetch(surl, { credentials: 'include' });
              if (!r.ok) return;
              const d = await r.json();
              const events = [];
              const collect = (arr, completed = false) => {
                (arr || []).forEach(it => {
                  events.push({
                    key: it.key,
                    points: it.estimateStatistic?.statFieldValue?.value || 0,
                    addedAfterStart: false,
                    blocked: !!it.flagged,
                    movedOut: false,
                    completed
                  });
                });
              };
              collect(d.contents.completedIssues, true);
              collect(d.contents.issuesNotCompletedInCurrentSprint, false);
              collect(d.contents.puntedIssues, false);

              const entry = data.velocityStatEntries?.[s.id] || {};
              let completed = entry.completed?.value || 0;
              let completedSource = 'velocityStatEntries.completed';
              if (!completed) {
                completed = d.contents?.completedIssuesEstimateSum?.value || 0;
                completedSource = 'completedIssuesEstimateSum';
              }
              let initiallyPlanned = entry.estimated?.value || 0;
              let initiallyPlannedSource = 'velocityStatEntries.estimated';
              teamVelocity[boardNum][idx] = completed || 0;
              const sprintStart = s.startDate ? new Date(s.startDate) : null;
              const sprintEnd = s.completeDate ? new Date(s.completeDate) : (s.endDate ? new Date(s.endDate) : null);

              await Promise.all(events.map(async ev => {
                try {
                  let cached = issueCache.get(ev.key);
                  let histories, initialType, currentType, currentStatus, created, resolutionDate;
                  if (cached) {
                    ({ histories, initialType, currentType, currentStatus, created, resolutionDate } = cached);
                  } else {
                    const u = `https://${jiraDomain}/rest/api/3/issue/${ev.key}?expand=changelog&fields=issuetype,flagged,status,created,resolutiondate`;
                    const ir = await fetch(u, { credentials: 'include' });
                    if (!ir.ok) return;
                    const id = await ir.json();
                    histories = id.changelog?.histories || [];
                    currentType = id.fields?.issuetype?.name || '';
                    currentStatus = id.fields?.status?.name || '';
                    created = id.fields?.created;
                    resolutionDate = id.fields?.resolutiondate;
                    ev.blocked = ev.blocked || !!(id.fields?.flagged && id.fields.flagged.length);
                    ev.blocked = ev.blocked || currentStatus.toLowerCase().includes('block');
                    const sorted = histories.slice().sort((a, b) => new Date(a.created) - new Date(b.created));
                    initialType = currentType;
                    for (const h of sorted) {
                      const item = (h.items || []).find(i => i.field === 'issuetype');
                      if (item) {
                        initialType = item.fromString || item.from || item.toString || item.to || initialType;
                        break;
                      }
                    }
                    issueCache.set(ev.key, { histories, initialType, currentType, currentStatus, created, resolutionDate });
                  }

                  const isBlockedStatus = name => (name || '').toLowerCase().includes('block');

                  // determine status at sprint start by walking histories backwards
                  const statusAt = (date) => {
                    let status = currentStatus;
                    const desc = histories.slice().sort((a, b) => new Date(b.created) - new Date(a.created));
                    for (const h of desc) {
                      const changeDate = new Date(h.created);
                      if (changeDate > date) {
                        const stItem = (h.items || []).find(i => i.field === 'status');
                        if (stItem) status = stItem.fromString || stItem.from || status;
                      } else {
                        break;
                      }
                    }
                    return status;
                  };

                  const startStatus = sprintStart ? statusAt(sprintStart) : currentStatus;
                  let curBlocked = isBlockedStatus(startStatus);
                  let blockStart = curBlocked ? sprintStart : null;
                  const blockedPeriods = [];
                  const sortedHist = histories.slice().sort((a, b) => new Date(a.created) - new Date(b.created));
                  for (const h of sortedHist) {
                    const date = new Date(h.created);
                    if (sprintStart && date < sprintStart) continue;
                    if (sprintEnd && date > sprintEnd) break;
                    const stItem = (h.items || []).find(i => i.field === 'status');
                    if (!stItem) continue;
                    const toStatus = stItem.toString || stItem.to || '';
                    const toBlocked = isBlockedStatus(toStatus);
                    if (curBlocked && !toBlocked) {
                      blockedPeriods.push([blockStart, date]);
                      curBlocked = false;
                      blockStart = null;
                    } else if (!curBlocked && toBlocked) {
                      curBlocked = true;
                      blockStart = date;
                    }
                  }
                  if (curBlocked) blockedPeriods.push([blockStart, sprintEnd || new Date()]);
                  if (!blockedPeriods.length && ev.blocked) {
                    blockedPeriods.push([sprintStart, sprintEnd || new Date()]);
                  }
                  ev.blockedDays = blockedPeriods.reduce((sum, [start, end]) => {
                    const sClamped = sprintStart && start < sprintStart ? sprintStart : start;
                    const eClamped = sprintEnd && end > sprintEnd ? sprintEnd : end;
                    return eClamped > sClamped
                      ? sum + Kpis.calculateWorkDays(sClamped, eClamped)
                      : sum;
                  }, 0);
                  ev.blocked = ev.blocked || blockedPeriods.length > 0;
                  ev.completedDate = resolutionDate;
                  if (created && resolutionDate) {
                    ev.cycleTime = Kpis.calculateWorkDays(new Date(created), new Date(resolutionDate));
                  }

                  const allowedTypes = new Set(['task', 'story', 'bug']);
                  let typeChangedDuringSprint = false;
                  for (const h of histories) {
                    const chDate = new Date(h.created);
                    if (sprintStart && chDate >= sprintStart) {
                      for (const item of h.items || []) {
                        if (item.field === 'Sprint') {
                          const from = (item.fromString || item.from || '').toString();
                          const to = (item.toString || item.to || '').toString();
                          const sprintIdStr = String(s.id);
                          const sprintName = s.name || '';
                          const fromHas = from.includes(sprintIdStr) || from.includes(sprintName);
                          const toHas = to.includes(sprintIdStr) || to.includes(sprintName);
                          if (!fromHas && toHas) ev.addedAfterStart = true;
                          if (fromHas && !toHas) ev.movedOut = true;
                        }
                        if (sprintEnd && chDate <= sprintEnd && item.field === 'issuetype') {
                          const fromType = item.fromString || item.from;
                          const toType = item.toString || item.to;
                          if (fromType && toType && fromType !== toType) {
                            typeChangedDuringSprint = true;
                            break;
                          }
                        }
                      }
                    }
                    if (typeChangedDuringSprint) break;
                  }

                  if (typeChangedDuringSprint && allowedTypes.has((initialType || '').toLowerCase()) && currentType && currentType !== initialType) {
                    ev.typeChanged = true;
                  }
                } catch (e) {}
              }));

              if (!initiallyPlanned) {
                initiallyPlanned = events.filter(ev => !ev.addedAfterStart)
                                         .reduce((sum, ev) => sum + ev.points, 0);
                initiallyPlannedSource = 'sum of events not added after start';
              }
              const other = completed > initiallyPlanned ? completed - initiallyPlanned : 0;
              const existing = combined[s.name] || { id: s.id, name: s.name, startDate: s.startDate, events: [], initiallyPlanned: 0, completed: 0, other: 0, initiallyPlannedSource, completedSource };
              existing.id = existing.id || s.id;
              existing.startDate = existing.startDate || s.startDate;
              existing.events = existing.events.concat(events);
              existing.initiallyPlanned += initiallyPlanned || 0;
              existing.completed += completed || 0;
              existing.other += other || 0;
              combined[s.name] = existing;
            } catch (e) {
              Logger.error('sprint fetch failed', e);
            }
          }));
        }));
        Logger.info('Disruption data fetched for', Object.keys(combined).length, 'sprints');
        const sprintsArr = Object.values(combined).sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
        return { sprints: sprintsArr, teamVelocity };
      } catch (e) {
        Logger.error('Failed to fetch disruption data', e);
        alert('Failed to fetch disruption data.');
        return { sprints: [], teamVelocity: {} };
      }
    }

  function renderTable(data) {
    const tbody = document.getElementById('metricsBody');
    let html = '';
    const sorted = data.slice().sort((a, b) => new Date(b.startDate || 0) - new Date(a.startDate || 0));
    sorted.forEach((sprint, idx) => {
      const metrics = Disruption.calculateDisruptionMetrics(sprint.events);
      const detailsId = `details-${idx}`;
      html += `<tr>
        <td>${sprint.name}</td>
        <td title="${sprint.initiallyPlannedSource}">${sprint.initiallyPlanned || 0}</td>
        <td title="${sprint.completedSource}">${sprint.completed || 0}</td>
        <td title="completed minus initially planned">${sprint.other || 0}</td>
        <td title="${metrics.pulledInIssues.join(', ')}">${metrics.pulledIn || 0} (${metrics.pulledInCount || 0})</td>
        <td title="${metrics.blockedIssues.join(', ')}">${Number(metrics.blockedDays || 0).toFixed(1)} (${metrics.blockedCount || 0})</td>
        <td title="${metrics.typeChangedIssues.join(', ')}">${metrics.typeChanged || 0} (${metrics.typeChangedCount || 0})</td>
        <td title="${metrics.movedOutIssues.join(', ')}">${metrics.movedOut || 0} (${metrics.movedOutCount || 0})</td>
        <td><button class="btn details-toggle" onclick="toggleDetails('${detailsId}', this)">Show Details</button></td>
      </tr>`;
      html += `<tr id="${detailsId}" style="display:none"><td colspan="9">
        <table class="story-table">
          <thead><tr><th>Metric</th><th>Stories</th></tr></thead>
          <tbody>
            <tr><td>Pulled In</td><td>${metrics.pulledInIssues.join(', ') || '-'}</td></tr>
            <tr><td>Blocked</td><td>${metrics.blockedIssues.join(', ') || '-'}</td></tr>
            <tr><td>Type Changed</td><td>${metrics.typeChangedIssues.join(', ') || '-'}</td></tr>
            <tr><td>Moved Out</td><td>${metrics.movedOutIssues.join(', ') || '-'}</td></tr>
          </tbody>
        </table>
      </td></tr>`;
    });
    tbody.innerHTML = html;
  }

  function renderVelocityStats(boardNames, teamVelocity) {
    const wrap = document.getElementById('velocityStats');
    if (!wrap) return;

    let html = '<h2>Velocity (last 12 sprints)</h2>';
    html += '<table><thead><tr><th>Team</th><th>Average Velocity</th><th>Std Dev</th></tr></thead><tbody>';

    Object.keys(boardNames).forEach(id => {
      const vals = teamVelocity[id] || [];
      const avg = Kpis.calculateVelocity(vals);
      const sd = Kpis.calculateStdDev(vals, avg);
      html += `<tr><td>${boardNames[id]}</td><td>${avg.toFixed(2)}</td><td>${sd.toFixed(2)}</td></tr>`;
    });
    html += '</tbody></table>';
    wrap.innerHTML = html;
  }

function renderCharts(sprints) {
  const sprintLabels = sprints.map(s => s.name);
  const completedSP = sprints.map(s => s.completed || 0);
  const metricsArr = sprints.map(s => Disruption.calculateDisruptionMetrics(s.events));
  const pulledInCount = metricsArr.map(m => m.pulledInCount || 0);
  const blockedDays = metricsArr.map(m => m.blockedDays || 0);
  const blockedCount = metricsArr.map(m => m.blockedCount || 0);
  const typeChangedCount = metricsArr.map(m => m.typeChangedCount || 0);
  const movedOutCount = metricsArr.map(m => m.movedOutCount || 0);

  const cycleData = sprints.map(s => {
    const events = (s.events || []).filter(ev => ev.completedDate && typeof ev.cycleTime === 'number');
    const avg = events.length ? events.reduce((sum, ev) => sum + ev.cycleTime, 0) / events.length : 0;
    return { avg, count: events.length };
  });
  const avgCycleTime = cycleData.map(c => c.avg);
  const throughputPerSprint = cycleData.map(c => c.count);

  const chartWidth = Math.max(sprintLabels.length * 120, 600);
  ['completedChart','disruptionChart','cycleChart'].forEach(id => {
    const canvas = document.getElementById(id);
    canvas.width = chartWidth;
    canvas.height = 300;
  });

  const zonesBySprint = [];
  const avgBySprint = [];
  completedSP.forEach((_, i) => {
    const start = Math.max(0, i - 3);
    const window = completedSP.slice(start, i + 1);
    const avg = Kpis.calculateVelocity(window);
    const sd = Kpis.calculateStdDev(window, avg);
    const max = Math.max(...window, avg + 2 * sd);
    avgBySprint.push(avg);
    zonesBySprint.push([
      { yMin: 0, yMax: Math.max(avg - 2 * sd, 0), color: 'rgba(254,202,202,0.5)' },
      { yMin: Math.max(avg - 2 * sd, 0), yMax: avg - sd, color: 'rgba(254,249,195,0.5)' },
      { yMin: avg - sd, yMax: avg, color: 'rgba(209,250,229,0.5)' },
      { yMin: avg, yMax: avg + sd, color: 'rgba(110,231,183,0.5)' },
      { yMin: avg + sd, yMax: avg + 2 * sd, color: 'rgba(209,250,229,0.5)' },
      { yMin: avg + 2 * sd, yMax: max, color: 'rgba(254,249,195,0.5)' }
    ]);
  });
  const zoneMaxes = zonesBySprint.map(zs => zs[zs.length - 1].yMax);
  const maxY = Math.max(...completedSP, ...zoneMaxes, ...avgBySprint);

  const ratingZonesPlugin = {
    id: 'ratingZones',
    beforeDraw(chart, args, opts) {
      const { ctx, chartArea: { top, bottom, left, right }, scales: { x, y } } = chart;
      ctx.save();
      opts.zonesBySprint.forEach((zs, i) => {
        if (!zs) return;
        const xStart = Math.max(x.getPixelForValue(i - 0.5), left);
        const xEnd = Math.min(x.getPixelForValue(i + 0.5), right);
        zs.forEach(z => {
          const yStart = y.getPixelForValue(z.yMax);
          const yEnd = y.getPixelForValue(z.yMin);
          ctx.fillStyle = z.color;
          ctx.fillRect(xStart, yStart, xEnd - xStart, yEnd - yStart);
        });
      });
      ctx.restore();
    }
  };

  // Destroy existing charts if they exist to allow re-rendering without errors
  if (completedChartInstance) {
    completedChartInstance.destroy();
  }
  if (disruptionChartInstance) {
    disruptionChartInstance.destroy();
  }
  if (cycleChartInstance) {
    cycleChartInstance.destroy();
  }

  const vctx = document.getElementById('completedChart').getContext('2d');
  completedChartInstance = new Chart(vctx, {
    type: 'line',
    data: {
      labels: sprintLabels,
      datasets: [

        { label: 'Completed SP', data: completedSP, borderColor: '#6366f1', backgroundColor: 'rgba(99,102,241,0.3)', fill: false, tension: 0.1 },
        { label: 'Average Velocity', data: avgBySprint, borderColor: '#000000', borderDash: [5,5], fill: false, tension: 0 }

      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      scales: {

        y: { beginAtZero: true, suggestedMax: maxY, title: { display: true, text: 'Completed Story Points' } }

      },
      plugins: { legend: { position: 'bottom' }, ratingZones: { zonesBySprint } }
    },
    plugins: [ratingZonesPlugin]
  });

  const dctx = document.getElementById('disruptionChart').getContext('2d');
  disruptionChartInstance = new Chart(dctx, {
    type: 'line',
    data: {
      labels: sprintLabels,
      datasets: [
        { label: 'Pulled In Issues', data: pulledInCount, borderColor: '#3b82f6', backgroundColor: '#3b82f6', fill: false, tension: 0.1 },
        { label: 'Blocked Days', data: blockedDays, borderColor: '#ef4444', backgroundColor: '#ef4444', fill: false, tension: 0.1 },
        { label: 'Type Changed Issues', data: typeChangedCount, borderColor: '#f59e0b', backgroundColor: '#f59e0b', fill: false, tension: 0.1 },
        { label: 'Moved Out Issues', data: movedOutCount, borderColor: '#10b981', backgroundColor: '#10b981', fill: false, tension: 0.1 }
      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      scales: {
        y: { beginAtZero: true, title: { display: true, text: 'Issue Count / Blocked Days' } }
      },
      plugins: { legend: { position: 'bottom' } }
    }
  });

  const cctx = document.getElementById('cycleChart').getContext('2d');
  cycleChartInstance = new Chart(cctx, {
    type: 'line',
    data: {
      labels: sprintLabels,
      datasets: [
        { label: 'Mean Cycle Time (days)', data: avgCycleTime, borderColor: '#8b5cf6', backgroundColor: 'rgba(139,92,246,0.3)', yAxisID: 'y1', fill: false, tension: 0.1 },
        { label: 'Throughput per Sprint', data: throughputPerSprint, borderColor: '#f97316', backgroundColor: 'rgba(249,115,22,0.3)', yAxisID: 'y2', fill: false, tension: 0.1 }
      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      scales: {
        y1: { type: 'linear', position: 'left', beginAtZero: true, title: { display: true, text: 'Cycle Time (days)' } },
        y2: { type: 'linear', position: 'right', beginAtZero: true, title: { display: true, text: 'Throughput' }, grid: { drawOnChartArea: false } }
      },
      plugins: { legend: { position: 'bottom' } }
    }
  });
}

  function toggleDetails(id, btn) {
    const row = document.getElementById(id);
    if (row) {
      const hidden = row.style.display === 'none';
      row.style.display = hidden ? '' : 'none';
      if (btn) btn.textContent = hidden ? 'Hide Details' : 'Show Details';
    }
  }

  async function loadDisruption() {
    const jiraDomain = document.getElementById('jiraDomain').value.trim();
    const selected = boardChoices ? boardChoices.getValue() : [];
    const boards = selected.map(b => b.value);
    if (!jiraDomain || !boards.length) {
      alert('Enter Jira domain and select boards.');
      return;
    }
    Logger.info('Loading disruption report for boards', boards.join(','));
    const { sprints: fetchedSprints, teamVelocity } = await fetchDisruptionData(jiraDomain, boards);
    sprints = fetchedSprints;
    renderTable(sprints);
    renderSprintList();
    document.getElementById('sprintRow').style.display = sprints.length ? '' : 'none';
    const boardNames = {};
    selected.forEach(b => { boardNames[b.value] = b.label; });
    boardNamesData = boardNames;
    teamVelocityData = teamVelocity;
    renderVelocityStats(boardNamesData, teamVelocityData);
    renderCharts(sprints);
    Logger.info('Disruption report rendered');
  }

  function exportPDF() {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
    const elem = document.querySelector('.main');
    html2canvas(elem).then(canvas => {
      const img = canvas.toDataURL('image/png');
      const width = pdf.internal.pageSize.getWidth();
      const height = canvas.height * width / canvas.width;
      pdf.addImage(img, 'PNG', 0, 0, width, height);
      pdf.save('Disruption_Report.pdf');
    });
  }

  document.getElementById('versionSelect').value = 'index_disruption.html';
</script>
</body>
</html>
