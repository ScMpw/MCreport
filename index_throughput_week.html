<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stakeholder PI Status Report â€“ MCW with Allocation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" data-pdf-ignore="true">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" data-pdf-ignore="true" />
  <link rel="stylesheet" href="public/tailwind.css">
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <style>
    html { background: #f7f8fa; }
    body { background: #f7f8fa; font-family: 'Inter', Arial, sans-serif; margin: 0; padding: 0; }
    .main { max-width: 950px; margin: 30px auto 40px auto; background: #fff; border-radius: 18px; box-shadow: 0 2px 12px #d1d5db70; padding: 36px 32px; }
    h1 { font-size: 2.3em; margin:0 0 0.7em 0; font-weight: 600; }
    h2 { font-size: 1.3em; margin-top:2em; }
    .btn { background: #6366f1; color: #fff; border: none; border-radius: 6px; padding: 7px 18px; cursor: pointer; font-size:1em; margin: 0 10px 8px 0;}
    .btn:disabled { background: #aaa; }
    .sprint-row label { margin-right: 1.2em; }
    .section-title { font-size: 1.1em; font-weight: 600; margin: 1.7em 0 0.5em 0; }
    .epic-summary-block { margin:2em 0 2.5em 0; border-radius:14px; background: #f3f4f6; box-shadow: 0 1px 6px #e0e7ef70; padding: 24px 24px 18px 24px; position:relative; }
    .epic-risk { border:2px solid #e11d48; box-shadow:0 0 6px #e11d48; }
    .epic-select-label { position:absolute; bottom:8px; right:8px; font-size:0.9em; }
    .epic-select-checkbox { margin-right:4px; }
    .epic-header { font-size: 1.15em; font-weight: 600; color: #374151; }
    .allocation-bar { height: 18px; border-radius: 8px; background: #6366f1; display:inline-block; vertical-align:middle;}
    .prob-table { border-collapse:collapse; margin:12px 0 18px 0;}
    .prob-table th, .prob-table td { border:1px solid #e5e7eb; font-size:0.98em; padding:4px 11px;}
    .prob-table th { background:#e0e7ef;}
    .info-grid { display:grid; grid-template-columns:1.7fr 1.3fr; gap:1.5em; }
    .change-block { font-size: 0.99em; }
    .status-pill { display:inline-block; min-width:64px; font-size:0.96em; border-radius:12px; padding:1.5px 13px; margin-right:6px; margin-bottom:3px;}
    .pill-done { background:#10b981; color:#fff; }
    .pill-prog { background:#f59e0b; color:#fff; }
    .pill-blocked { background:#ef4444; color:#fff; }
    .pill-open { background:#3b82f6; color:#fff; }
    .warn { color:#e11d48; font-weight: 600;}
    .success { color:#059669; font-weight:600;}
    .allocation-row {margin-bottom: 12px;}
    .alloc-label {display:inline-block; min-width: 80px;}
    .editarr { width: 50px;}
    .pdf-cover { font-size:2.1em; text-align:center; margin-top:80px; color:#6366f1;}
    .pdf-sub { font-size:1.1em; color:#374151; text-align:center; margin-top:20px;}
    .pdf-section-title { font-size:1.15em; font-weight:600; margin-top:25px;}
    .details-toggle { margin: 10px 0 6px 0; }
    .story-table { border-collapse: collapse; width: 100%; margin: 6px 0 18px 0; }
    .story-table th, .story-table td { border: 1px solid #e5e7eb; padding: 4px 7px; font-size: 0.98em; text-align:left; }
    .story-table th { background: #e0e7ef; }
    .story-status-current { background: #b3e5fc; }
    .story-status-previous { background: none; }
    .story-status-new { background: #fff9c4; }
    .story-status-open { background: none; }
    .story-status-inprogress { background: none; }
    .story-status-blocked { background: none; }
    .story-status-other { background: #e0e0e0; }
    .story-map { display:flex; gap:12px; overflow-x:auto; }
    .story-lane { flex:1; min-width:180px; background:#fafafa; border:1px solid #e5e7eb; border-radius:6px; padding:6px; }
    .removed-lane { background:#ffe4e6; }
    .removed-lane .story-card.story-status-other { background:#ffd6dc; }
    .story-lane-header { font-weight:600; margin-bottom:4px; font-size:0.96em; color:#374151; }
    .story-card { border:1px solid #e5e7eb; border-radius:4px; padding:4px 5px; margin-bottom:6px; background:white; font-size:0.92em; }
    .story-card.story-status-current { background:#b3e5fc; }
    .story-card.story-status-previous { background:none; }
    .story-card.story-status-new { background:#fff9c4; }
    .story-card.story-status-open { background:none; }
    .story-card.story-status-inprogress { background:none; }
    .story-card.story-status-blocked { background:none; }
    .story-card.story-status-other { background:#e0e0e0; }
    .story-card .tags { margin-top:2px; }
    .story-tag { font-size:0.75em; background:#d1d5db; color:#111; border-radius:3px; padding:1px 4px; margin-right:3px; }
    .story-card .small { font-size:0.8em; color:#555; }
    .story-map-legend span {
      display:inline-block;
      padding:2px 8px;
      border-radius:4px;
      margin-right:6px;
      border:1px solid #9ca3af;
      font-weight:600;
    }
    .info-icon {
      cursor:pointer;
      font-size:0.9em;
      color:#555;
      margin-left:4px;
      position:relative;
      user-select:none;
    }
    .info-icon .tooltip {
      display:none;
      position:absolute;
      top:1.2em;
      left:0;
      background:#333;
      color:#fff;
      padding:3px 6px;
      border-radius:4px;
      font-size:0.82em;
      max-width:220px;
      white-space:normal;
      z-index:20;
    }
    .info-icon.active .tooltip { display:block; }
    /* Choices.js dropdown width */
    .choices__list--dropdown { min-width: 240px; }
    @media (max-width: 800px) {
      .main {padding:14px;}
      .info-grid {grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div class="main">
    <h1>Stakeholder PI Status Report (Monte Carlo, Resource Allocation)</h1>
    <div style="margin-bottom:10px;">
      <label>Version:
        <select id="versionSelect" onchange="switchVersion(this.value)">
          <option value="index.html">Velocity</option>
          <option value="index_throughput_week.html" selected>Weekly Throughput</option>
        </select>
      </label>
    </div>
    <div>
      <label>Board:
        <select id="boardNum">
          <option value="">Select a boardâ€¦</option>
        </select>
      </label>
      <button class="btn" onclick="fetchAllSprints()">Fetch Sprints</button>
    </div>
    <div class="sprint-row" id="sprintRow" style="display:none; margin:1.1em 0;">
      <label>Sprint:
        <select id="sprintSelect"></select>
      </label>
      <button class="btn" onclick="fetchAll()">Load Data</button>
    </div>
    <div id="loadingMessage" style="display:none; font-weight:bold; margin:10px 0;"></div>

    <div id="configSection" style="display:none;">
      <div class="section-title">Throughput History (issues per week, last 12 weeks):</div>
      <div id="throughputWrap"></div>
      <div style="margin:0.9em 0 1.6em 0;">
        <label>Target Weeks for Delivery:
          <input id="targetWeeksInput" type="number" min="1" max="20" value="4" style="width:60px">
        </label>
        <button class="btn" onclick="renderEpicSummary()">Update Report</button>
        <button class="btn" onclick="exportPDF()">Download PDF Report</button>
      </div>
      <div id="filterOptions" style="margin-bottom:15px;"></div>
      <div id="requiredSummary" style="margin-bottom:15px;"></div>
      <div id="epicSummary"></div>
    </div>
  </div>
  <script src="src/jira.js"></script>
  <script>
const DEFAULT_JIRA_DOMAIN = 'aldi-sued.atlassian.net';
let jiraDomain = DEFAULT_JIRA_DOMAIN, boardNum = '', sprints = [], closedSprintsSorted = [];
const boardSelect = document.getElementById('boardNum');
let boardChoices = new Choices(boardSelect, {
  shouldSort: false,
  itemSelectText: '',
  searchPlaceholderValue: 'Search boards...'
});

function createPlaceholder(label = 'Select a boardâ€¦') {
  return { value: '', label, disabled: true, selected: true };
}

async function populateBoards() {
  boardChoices.clearChoices();
  boardChoices.setChoices([createPlaceholder()], 'value', 'label', true);
  try {
    const boards = await Jira.fetchBoardsByJql(DEFAULT_JIRA_DOMAIN);
    if (!boards.length) {
      boardChoices.setChoices([
        createPlaceholder('No boards available')
      ], 'value', 'label', true);
      return;
    }
    boardChoices.setChoices([
      createPlaceholder(),
      ...boards.map(b => ({ value: String(b.id), label: b.name }))
    ], 'value', 'label', true);
  } catch (e) {
    console.error('Failed to load boards', e);
    boardChoices.setChoices([
      createPlaceholder('Failed to load boards')
    ], 'value', 'label', true);
  }
}

populateBoards();

boardSelect.addEventListener('change', () => {
  boardNum = boardSelect.value;
  document.getElementById('sprintRow').style.display = 'none';
  document.getElementById('configSection').style.display = 'none';
});
let allEpics = {}, epicStories = {}, epicStoriesBaseline = {};
let throughputArr = [];
let throughputIssues = [];
let throughputWeekNums = [];
let throughputWeekLabels = [];
let avgThroughput = 0;
let selectedSprintId = '', selectedSprintName = '', targetWeeks = 4;
let baselineSprintId = '';

function deduplicateStoriesByKey(stories) {
  const seen = new Set();
  return (stories || []).filter(story => {
    if (!story || !story.key) return true;
    if (seen.has(story.key)) return false;
    seen.add(story.key);
    return true;
  });
}

function parseTeamString(teamStr = '') {
  const seen = new Set();
  return teamStr
    .split(',')
    .map(t => t.trim())
    .filter(t => {
      if (!t || seen.has(t)) return false;
      seen.add(t);
      return true;
    });
}

function getStoryTeams(story) {
  return parseTeamString(story && story.team ? story.team : '');
}

function matchesTeamFilters(teams, filters = teamFilters) {
  if (!Array.isArray(teams) || !teams.length) return false;
  if (!filters || !Object.keys(filters).length) return false;
  return teams.some(t => filters[t]);
}

function storyMatchesTeamFilters(story, filters = teamFilters) {
  return matchesTeamFilters(getStoryTeams(story), filters);
}
document.getElementById('versionSelect').value = 'index_throughput_week.html';
function switchVersion(page) {
  if (page !== 'index_throughput_week.html') location.href = page;
}
// Note: the KPI report fetches data via sprint and issue endpoints only, so it
// never calls this helper. These dashboards rely on Jira's /search API which
// triggers a CORS preflight when issued as POST from GitHub Pages. Prefer GET
// to avoid the failing preflight and fall back to POST for large queries.
async function jiraSearch(jql, fields = [], options = {}) {
  const searchUrl = `https://${jiraDomain}/rest/api/3/search/jql`;
  const maxResults = options.maxResults || 500;
  let startAt = options.startAt || 0;
  const collected = [];
  const fieldList = Array.isArray(fields) ? fields.filter(Boolean) : (fields ? [fields] : []);
  const expandList = Array.isArray(options.expand)
    ? options.expand.filter(Boolean)
    : (options.expand ? [options.expand] : []);
  let useGet = true;

  const buildPayload = () => {
    const payload = { jql, startAt, maxResults };
    if (fieldList.length) payload.fields = fieldList;
    if (expandList.length) payload.expand = expandList;
    return payload;
  };

  while (true) {
    let resp;
    try {
      if (useGet) {
        const params = new URLSearchParams();
        params.set('jql', jql);
        params.set('startAt', String(startAt));
        params.set('maxResults', String(maxResults));
        if (fieldList.length) params.set('fields', fieldList.join(','));
        if (expandList.length) params.set('expand', expandList.join(','));
        const url = `${searchUrl}?${params.toString()}`;
        resp = await fetch(url, {
          method: 'GET',
          credentials: 'include',
          headers: {
            'Accept': 'application/json'
          }
        });
      } else {
        const payload = buildPayload();
        resp = await fetch(searchUrl, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Atlassian-Token': 'no-check'
          },
          body: JSON.stringify(payload)
        });
      }
    } catch (err) {
      if (useGet) {
        console.warn('Jira search GET request failed, retrying with POST', err);
        useGet = false;
        continue;
      }
      console.error('Jira search request failed', err);
      throw err;
    }

    if (useGet && [405, 413, 414].includes(resp.status)) {
      console.warn(`Jira search GET returned status ${resp.status}, retrying with POST.`);
      useGet = false;
      continue;
    }

    if (!resp.ok) {
      const text = await resp.text();
      console.error('Jira search failed', resp.status, text);
      throw new Error(`Jira search failed (${resp.status})`);
    }

    const data = await resp.json();
    const issues = Array.isArray(data.issues) ? data.issues : [];
    collected.push(...issues);

    const pageSize = data.maxResults || issues.length || maxResults;
    const total = typeof data.total === 'number' ? data.total : null;
    const nextStart = (data.startAt || 0) + pageSize;
    const receivedAll = !issues.length || (total !== null && collected.length >= total) || issues.length < pageSize;

    if (receivedAll) {
      return { issues: collected, total: total !== null ? total : collected.length };
    }

    if (nextStart <= startAt) {
      // Prevent potential infinite loops if the API stops advancing.
      return { issues: collected, total: total !== null ? total : collected.length };
    }

    startAt = nextStart;
  }
}
let epicAllocations = {}, epicBacklogs = {}, epicTotalIssues = {}, epicRequiredAlloc = {}, epicRequiredIssues = {},
    epicRequiredIssuesPrev = {};
let epicForecastResults = {};
let historicData = [];
let storyFilters = { current:true, previous:true, new:true, open:true, removed:true };
let boardTeams = [];
let teamFilters = {};
let statusChoices = null;
let teamChoices = null;

function showLoading(msg) {
  const el = document.getElementById('loadingMessage');
  if (el) {
    el.textContent = msg || 'Loading...';
    el.style.display = '';
  }
}

function hideLoading() {
  const el = document.getElementById('loadingMessage');
  if (el) el.style.display = 'none';
}

function addTooltipListeners() {
  document.querySelectorAll('.info-icon').forEach(icon => {
    icon.addEventListener('click', e => {
      e.stopPropagation();
      const tip = icon.querySelector('.tooltip');
      if (tip) tip.textContent = icon.dataset.tip || '';
      icon.classList.toggle('active');
    });
  });
  document.addEventListener('click', () => {
    document.querySelectorAll('.info-icon.active').forEach(i => i.classList.remove('active'));
  });
}


    function loadHistoricData() {
      try { historicData = JSON.parse(localStorage.getItem('mc_hist')) || []; }
      catch (e) { historicData = []; }
    }

    function saveHistoricData() {
      localStorage.setItem('mc_hist', JSON.stringify(historicData));
    }

    loadHistoricData();
    renderFilterOptions();
    addTooltipListeners();

    const WEEKLY_SPRINT_LOOKBACK = 20;
    const BF_BOARDS = new Set(['6347', '6390']);

    function filterRecentSprints(allSprints = [], desiredCount = WEEKLY_SPRINT_LOOKBACK) {
      const sorted = allSprints.slice().sort((a, b) => {
        const ad = a.endDate || a.completeDate || a.startDate || '';
        const bd = b.endDate || b.completeDate || b.startDate || '';
        return ad && bd ? new Date(bd) - new Date(ad) : 0;
      });
      return sorted.slice(0, desiredCount);
    }

    async function runBatches(items, batchSize, handler) {
      for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        await Promise.all(batch.map(handler));
      }
    }

    function dedupeCompletedIssues(entries) {
      (entries || []).forEach(entry => {
        const completed = entry.completed || [];
        if (!completed.length) return;
        const deduped = new Map();
        let hasDuplicates = false;
        completed.forEach(ev => {
          if (!ev || !ev.key) return;
          if (deduped.has(ev.key)) {
            hasDuplicates = true;
            const existing = deduped.get(ev.key);
            if (!existing.completedDate && ev.completedDate) {
              existing.completedDate = ev.completedDate;
            }
            if (!existing.resolutionName && ev.resolutionName) {
              existing.resolutionName = ev.resolutionName;
            }
          } else {
            deduped.set(ev.key, { ...ev });
          }
        });
        if (hasDuplicates) {
          entry.completed = Array.from(deduped.values());
        }
      });
    }

    async function fetchSprintCompletionData(jiraDomain, boardNum, desiredCount, includeSprintId = '') {
      const results = [];
      const boardId = String(boardNum || '').trim();
      if (!jiraDomain || !boardId) return results;

      const includeId = String(includeSprintId || '').trim();
      let includeSprint = null;

      const velocityUrl = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/velocity?rapidViewId=${boardId}`;
      let closed = [];
      try {
        const resp = await fetch(velocityUrl, { credentials: 'include' });
        if (resp.ok) {
          const data = await resp.json();
          closed = (data.sprints || []).filter(
            s =>
              (s.state === 'CLOSED' || s.state === 'ACTIVE') &&
              s.startDate &&
              String(s.originBoardId) === boardId
          );
          if (includeId) {
            includeSprint = closed.find(s => String(s.id) === includeId) || null;
          }
        } else {
          console.warn('Velocity report unavailable, falling back to sprint list', resp.status);
        }
      } catch (e) {
        console.warn('Velocity report request failed, falling back to sprint list', e);
      }

      if (!closed.length) {
        let allSprints = [];
        let startAt = 0;
        const maxResults = 50;
        let loops = 0;
        while (true) {
          const sUrl = `https://${jiraDomain}/rest/agile/1.0/board/${boardId}/sprint?maxResults=${maxResults}&startAt=${startAt}`;
          try {
            const sResp = await fetch(sUrl, { credentials: 'include' });
            if (!sResp.ok) break;
            const sData = await sResp.json();
            const values = sData.values || [];
            allSprints = allSprints.concat(values);
            startAt += values.length;
            loops++;
            if (sData.isLast || values.length < maxResults || loops > 100) break;
          } catch (err) {
            console.error('Failed to fetch sprint list', err);
            break;
          }
        }
        closed = allSprints.filter(s => {
          const state = (s.state || '').toUpperCase();
          return (
            (state === 'CLOSED' || state === 'ACTIVE') &&
            s.startDate &&
            String(s.originBoardId) === boardId
          );
        });
        if (includeId) {
          includeSprint = closed.find(s => String(s.id) === includeId) || null;
        }
      }

      if (includeId && !includeSprint) {
        try {
          const sprintResp = await fetch(`https://${jiraDomain}/rest/agile/1.0/sprint/${includeId}`, { credentials: 'include' });
          if (sprintResp.ok) {
            const sprintData = await sprintResp.json();
            if (
              sprintData &&
              sprintData.startDate &&
              String(sprintData.originBoardId) === boardId
            ) {
              includeSprint = sprintData;
              closed.push(sprintData);
            }
          }
        } catch (err) {
          console.warn('Failed to fetch include sprint details', err);
        }
      }

      closed = filterRecentSprints(closed, desiredCount);
      if (includeSprint && !closed.some(s => String(s.id) === includeId)) {
        closed.push(includeSprint);
        closed = filterRecentSprints(closed, desiredCount);
      }
      const isBfBoard = BF_BOARDS.has(boardId);
      const byIndex = closed.map(s => ({ sprint: s, completed: [] }));

      for (let i = 0; i < closed.length; i++) {
        const sprint = closed[i];
        const surl = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/sprintreport?rapidViewId=${boardId}&sprintId=${sprint.id}`;
        try {
          const r = await fetch(surl, { credentials: 'include' });
          if (!r.ok) continue;
          const d = await r.json();
          let events = [];
          const collect = (arr, completed = false) => {
            (arr || []).forEach(it => {
              if (!it || !it.key) return;
              events.push({ key: it.key, completed, movedOut: false });
            });
          };
          collect(d.contents?.completedIssues, true);
          collect(d.contents?.issuesNotCompletedInCurrentSprint, false);
          collect(d.contents?.puntedIssues, false);
          (d.contents?.issueKeysRemovedFromSprint || []).forEach(k => {
            if (!k) return;
            const existing = events.find(ev => ev.key === k);
            if (existing) {
              existing.movedOut = true;
              existing.completed = false;
            } else {
              events.push({ key: k, completed: false, movedOut: true });
            }
          });
          if (isBfBoard) {
            events = events.filter(ev => ev.key && ev.key.startsWith('BF-'));
          }
          byIndex[i].completed = events
            .filter(ev => ev.completed && !ev.movedOut)
            .map(ev => ({ key: ev.key }));
        } catch (err) {
          console.error('Failed to fetch sprint report', err);
          byIndex[i].completed = [];
        }
      }

      dedupeCompletedIssues(byIndex);

      const uniqueKeys = Array.from(new Set(
        byIndex.flatMap(entry => entry.completed.map(ev => ev.key)).filter(Boolean)
      ));
      if (uniqueKeys.length) {
        const issueCache = new Map();
        await runBatches(uniqueKeys, 8, async key => {
          try {
            const issueUrl = `https://${jiraDomain}/rest/api/3/issue/${key}?fields=resolution,resolutiondate,status&expand=changelog`;
            const issueResp = await fetch(issueUrl, { credentials: 'include' });
            if (!issueResp.ok) return;
            const issueData = await issueResp.json();
            const fields = issueData.fields || {};
            const resolutionName = fields.resolution?.name || '';
            const resolved = fields.resolutiondate || null;
            const statusName = fields.status?.name || '';
            const resolvedMs = Date.parse(resolved || '');
            let doneMs = Number.isFinite(resolvedMs) ? resolvedMs : null;
            let activeDoneMs = null;
            const histories = Array.isArray(issueData.changelog?.histories)
              ? issueData.changelog.histories
              : [];
            const statusHistory = [];
            histories.forEach(history => {
              const histMs = Date.parse((history && history.created) || '');
              if (!Number.isFinite(histMs)) return;
              (history.items || []).forEach(item => {
                if ((item.field || '').toLowerCase() === 'status') {
                  statusHistory.push({
                    date: histMs,
                    from: item.fromString || item.from || '',
                    to: item.toString || item.to || ''
                  });
                }
              });
            });
            statusHistory.sort((a, b) => a.date - b.date);
            statusHistory.forEach(change => {
              if (!change || !Number.isFinite(change.date)) return;
              const toStr = (change.to || '').toLowerCase();
              const fromStr = (change.from || '').toLowerCase();
              const toDone = toStr.includes('done') || toStr.includes('closed');
              const fromDone = fromStr.includes('done') || fromStr.includes('closed');
              if (toDone) {
                activeDoneMs = change.date;
              }
              if (fromDone && !toDone) {
                activeDoneMs = null;
              }
            });
            if (isDone(statusName)) {
              if (activeDoneMs != null) {
                doneMs = activeDoneMs;
              } else if (!Number.isFinite(doneMs)) {
                for (let i = statusHistory.length - 1; i >= 0; i--) {
                  const change = statusHistory[i];
                  if (!change || !Number.isFinite(change.date)) continue;
                  const toStr = (change.to || '').toLowerCase();
                  if (toStr.includes('done') || toStr.includes('closed')) {
                    doneMs = change.date;
                    break;
                  }
                }
              }
            } else {
              doneMs = null;
            }
            const completedIso = Number.isFinite(doneMs) ? new Date(doneMs).toISOString() : (resolved || null);
            issueCache.set(key, {
              resolutionDate: completedIso,
              resolutionName
            });
          } catch (err) {
            console.error('Failed to fetch issue details', key, err);
          }
        });
        byIndex.forEach(entry => {
          entry.completed.forEach(ev => {
            const info = issueCache.get(ev.key);
            if (info) {
              ev.completedDate = info.resolutionDate;
              ev.resolutionName = info.resolutionName;
            }
          });
        });
      }

      return byIndex;
    }

    async function fetchThroughputFromReport(jiraDomain, boardNum, includeSprintId = '') {
      function weekStart(dt) {
        const d = new Date(dt);
        const day = d.getDay();
        const diff = d.getDate() - day + (day === 0 ? -6 : 1);
        d.setDate(diff);
        d.setHours(0, 0, 0, 0);
        return d;
      }
      function isoWeekNumber(dt) {
        const d = new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()));
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
      }
      function isoWeekYear(dt) {
        const d = new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()));
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day);
        return d.getUTCFullYear();
      }

      try {
        const completions = await fetchSprintCompletionData(jiraDomain, boardNum, WEEKLY_SPRINT_LOOKBACK, includeSprintId);
        if (!completions.length) throw new Error('no-throughput-data');

        const WEEK_COUNT = 12;
        const weeks = new Array(WEEK_COUNT).fill(0).map(() => []);
        const WEEK_MS = 7 * 24 * 60 * 60 * 1000;
        const currentWeekStart = weekStart(new Date());
        const lastCompletedWeekStart = new Date(currentWeekStart);
        lastCompletedWeekStart.setDate(lastCompletedWeekStart.getDate() - 7);

        throughputWeekNums = [];
        throughputWeekLabels = [];
        for (let i = 0; i < WEEK_COUNT; i++) {
          const d = new Date(lastCompletedWeekStart);
          d.setDate(d.getDate() - (WEEK_COUNT - 1 - i) * 7);
          const weekNum = isoWeekNumber(d);
          const weekYear = isoWeekYear(d);
          throughputWeekNums.push(weekNum);
          throughputWeekLabels.push(`KW ${String(weekNum).padStart(2, '0')} (${weekYear})`);
        }

        completions.forEach(entry => {
          (entry.completed || []).forEach(ev => {
            if (!ev.completedDate) return;
            if (!validResolution(ev.resolutionName)) return;
            const w = weekStart(ev.completedDate);
            const diff = Math.round((lastCompletedWeekStart - w) / WEEK_MS);
            if (diff >= 0 && diff < WEEK_COUNT) {
              const idx = WEEK_COUNT - 1 - diff;
              const bucket = weeks[idx];
              if (!bucket.includes(ev.key)) bucket.push(ev.key);
            }
          });
        });

        throughputIssues = weeks;
        const counts = weeks.map(w => w.length);
        console.log('Weekly throughput:', counts.map((c, idx) => `${throughputWeekLabels[idx]}: ${c}`).join(', '));
        return counts;
      } catch (e) {
        console.error('Failed to fetch weekly throughput', e);
        throughputWeekNums = [];
        throughputWeekLabels = [];
        throughputIssues = [];
        alert('Failed to fetch throughput report. Are you logged in to Jira?');
        return [];
      }
    }

    async function fetchBoardTeam() {
      boardTeams = [];
      try {
        const cfgUrl = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/configuration`;
        const cfgResp = await fetch(cfgUrl, { credentials: "include" });
        if (!cfgResp.ok) return;
        const cfg = await cfgResp.json();
        const filterId = cfg.filter && cfg.filter.id;
        if (!filterId) return;
        const fResp = await fetch(`https://${jiraDomain}/rest/api/3/filter/${filterId}`, { credentials: "include" });
        if (!fResp.ok) return;
        const fd = await fResp.json();
        const jql = fd.jql || '';
        const regex = /(?:"Team"|customfield_12600|cf\[12600\])\s*(?:=|in)\s*(\([^\)]*\)|"[^"\n]+")/gi;
        let m;
        while ((m = regex.exec(jql)) !== null) {
          let str = m[1].replace(/[()]/g, '');
          str.split(',').forEach(t => {
            t = t.replace(/"/g, '').trim();
            if (t && !boardTeams.includes(t)) boardTeams.push(t);
          });
        }
      } catch (e) {
        console.error('Failed to fetch board team', e);
      }
      console.log('Board teams:', boardTeams.join(', '));
    }



    // --- SPRINT FETCH & SELECTION (paginated, NO sorting after fetch) ---
    async function fetchAllSprints() {
      jiraDomain = DEFAULT_JIRA_DOMAIN;
      boardNum = boardSelect.value.trim();
      if (!boardNum) return alert("Select a board.");

      showLoading('Fetching sprints...');
      await fetchBoardTeam();

      let allSprintsArr = [];
      let startAt = 0;
      const maxResults = 50; // Jira API typically caps sprint pages at 50
      let total = null;

      while (true) {
        const url = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/sprint?maxResults=${maxResults}&startAt=${startAt}`;
        console.log("Fetching sprints:", url);
        try {
          const resp = await fetch(url, { credentials: "include" });
          if (!resp.ok) {
            const text = await resp.text();
            console.error("API Error Response:", resp.status, text);
            alert("API returned an error. See console for details.");
            hideLoading();
            return;
          }
          const data = await resp.json();
          if (data.values && data.values.length) {
            allSprintsArr = allSprintsArr.concat(data.values);
            total = data.total;
            startAt += data.values.length; // advance by number returned
            if (data.isLast || allSprintsArr.length >= total) break;
          } else {
            break;
          }
        } catch (e) {
          console.error(e);
          alert("Failed to fetch sprints. CORS? Are you logged into Jira?");
          hideLoading();
          return;
        }
      }

      // Log all fetched sprints
      console.log("Fetched sprints:", allSprintsArr.length, allSprintsArr.map(s => s.name + ' (' + (s.startDate ? s.startDate.substr(0,10) : "undefined") + ')'));

      sprints = allSprintsArr.slice(); // keep original order; dropdown reverses
      closedSprintsSorted = sprints.filter(s => s.state === "closed" && s.endDate)
                                   .sort((a, b) => new Date(b.endDate) - new Date(a.endDate));
      populateSprintDropdown();
      hideLoading();
    }

    // --- SPRINT DROPDOWN: show all sprints in reverse order ---
    function populateSprintDropdown() {
      const sel = document.getElementById('sprintSelect');
      sel.innerHTML = '';
      for (let i = sprints.length - 1; i >= 0; i--) {
        const sprint = sprints[i];
        const opt = document.createElement('option');
        opt.value = sprint.id;
        let name = sprint.name || "(no name)";
        if (sprint.startDate) name += " (" + sprint.startDate.substr(0, 10) + ")";
        opt.textContent = (sprint.state === "active" ? "ðŸŸ¢ " : "") + name;
        sel.appendChild(opt);
      }
      document.getElementById('sprintRow').style.display = '';
    }

    function getStoryRowClass(story, currSprintObj) {
      const created = new Date(story.created);
      const resolved = story.resolved ? new Date(story.resolved) : null;
      const sprintStart = currSprintObj && currSprintObj.startDate ? new Date(currSprintObj.startDate) : null;
      const sprintEnd = currSprintObj && currSprintObj.endDate ? new Date(currSprintObj.endDate) : null;
      if (sprintStart && sprintEnd && created >= sprintStart && created < sprintEnd) {
        return "story-status-new";
      }
      if (sprintStart && sprintEnd && resolved && resolved >= sprintStart && resolved < sprintEnd) {
        return "story-status-current";
      }
      if (resolved && sprintStart && resolved < sprintStart) {
        return "story-status-previous";
      }
      if (!resolved || !story.status || !(story.status.toLowerCase().includes("done") || story.status.toLowerCase().includes("closed"))) {
        const st = (story.status||'').toLowerCase();
        if (st.includes('block')) return 'story-status-blocked';
        if (st.includes('progress') || st.includes('development')) return 'story-status-inprogress';
        return 'story-status-open';
      }
      return 'story-status-open';
   }

    // --- MAIN DATA FETCH (Epics/Stories/Throughput) ---
    async function fetchAll() {
      selectedSprintId = document.getElementById('sprintSelect').value;
      selectedSprintName = document.getElementById('sprintSelect').selectedOptions[0].textContent;
      if (!selectedSprintId) return alert("Select a sprint.");
      showLoading('Loading sprint data...');
      if (!boardTeams.length) await fetchBoardTeam();
      let currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
      let currIdx = closedSprintsSorted.findIndex(s => String(s.id) === String(selectedSprintId));
      let baselineSprint = null;
      if (currIdx >= 0) {
        if (currIdx + 1 < closedSprintsSorted.length) {
          baselineSprint = closedSprintsSorted[currIdx + 1];
        }
      } else if (closedSprintsSorted.length) {
        baselineSprint = closedSprintsSorted[0];
      }
      baselineSprintId = baselineSprint ? baselineSprint.id : '';
      const sprintFields = [
        'summary',
        'parent',
        'customfield_10002',
        'customfield_10005',
        'customfield_12600',
        'status',
        'issuetype'
      ];
      const epicKeysSet = new Set();
      try {
        const { issues } = await jiraSearch(`sprint = ${selectedSprintId} ORDER BY key`, sprintFields);
        (issues || []).forEach(issue => {
          if (issue.fields && issue.fields.issuetype && issue.fields.issuetype.name === 'Epic') return;
          const parent = issue.fields && issue.fields.parent;
          if (parent && parent.fields && parent.fields.issuetype && parent.fields.issuetype.name === 'Epic') {
            epicKeysSet.add(parent.key);
            allEpics[parent.key] = parent.fields.summary;
          }
        });
      } catch (e) {
        console.error('Error fetching stories for selected sprint', e);
        alert('Error fetching stories for selected sprint. See console for details.');
        hideLoading();
        return;
      }
      const epicFields = [
        'summary',
        'status',
        'resolution',
        'assignee',
        'customfield_10002',
        'customfield_12600',
        'created',
        'resolutiondate',
        'issuetype',
        'customfield_10005'
      ];
      epicStories = {};
      await Promise.all(Array.from(epicKeysSet).map(async epicKey => {
        try {
          const { issues } = await jiraSearch(`"Epic Link" = ${epicKey}`, epicFields, { expand: ['changelog'] });
          epicStories[epicKey] = deduplicateStoriesByKey((issues || [])
            .filter(story => validResolution(story.fields.resolution && story.fields.resolution.name))
            .map(story => {
              const created = story.fields.created;
              const resolved = story.fields.resolutiondate;
              const createdMs = Date.parse(created || '');
              const resolvedMs = Date.parse(resolved || '');
              const statusHistory = [];
              const histories = story.changelog && Array.isArray(story.changelog.histories)
                ? story.changelog.histories
                : [];
              histories.forEach(history => {
                const histMs = Date.parse((history && history.created) || '');
                if (!Number.isFinite(histMs)) return;
                (history.items || []).forEach(item => {
                  if ((item.field || '').toLowerCase() === 'status') {
                    statusHistory.push({
                      date: histMs,
                      from: item.fromString || item.from || '',
                      to: item.toString || item.to || ''
                    });
                  }
                });
              });
              statusHistory.sort((a, b) => a.date - b.date);
              let doneMs = Number.isFinite(resolvedMs) ? resolvedMs : null;
              let activeDoneMs = null;
              statusHistory.forEach(change => {
                if (!change || !Number.isFinite(change.date)) return;
                const toStr = (change.to || '').toLowerCase();
                const fromStr = (change.from || '').toLowerCase();
                const toDone = toStr.includes('done') || toStr.includes('closed');
                const fromDone = fromStr.includes('done') || fromStr.includes('closed');
                if (toDone) {
                  activeDoneMs = change.date;
                }
                if (fromDone && !toDone) {
                  activeDoneMs = null;
                }
              });
              const statusName = story.fields.status && story.fields.status.name;
              const currentlyDone = isDone(statusName);
              if (currentlyDone) {
                if (activeDoneMs != null) {
                  doneMs = activeDoneMs;
                } else if (!Number.isFinite(doneMs)) {
                  for (let i = statusHistory.length - 1; i >= 0; i--) {
                    const change = statusHistory[i];
                    if (!change || !Number.isFinite(change.date)) continue;
                    const toStr = (change.to || '').toLowerCase();
                    if (toStr.includes('done') || toStr.includes('closed')) {
                      doneMs = change.date;
                      break;
                    }
                  }
                }
              } else {
                doneMs = null;
              }
              const resolvedDisplay = story.fields.resolutiondate || (Number.isFinite(doneMs) ? new Date(doneMs).toISOString() : null);
              return {
                key: story.key,
                summary: story.fields.summary,
                status: story.fields.status && story.fields.status.name,
                resolution: story.fields.resolution && story.fields.resolution.name,
                assignee: story.fields.assignee && story.fields.assignee.displayName,
                points: Number(story.fields.customfield_10002) || 0,
                team: (story.fields.customfield_12600 || []).join(', '),
                created,
                resolved: resolvedDisplay,
                createdTs: Number.isFinite(createdMs) ? createdMs : null,
                resolvedTs: Number.isFinite(doneMs) ? doneMs : null,
                doneTs: Number.isFinite(doneMs) ? doneMs : null,
                sprint: (story.fields.customfield_10005||[]).map(s=>s.name).join(', '),
                issuetype: story.fields.issuetype && story.fields.issuetype.name,
                statusHistory
              };
            }));
        } catch (e) {
          console.error(`Failed to fetch stories for epic ${epicKey}`, e);
          epicStories[epicKey] = [];
        }
      }));
      epicStoriesBaseline = {};
      await Promise.all(Array.from(epicKeysSet).map(async epicKey => {
        try {
          const { issues } = await jiraSearch(`"Epic Link" = ${epicKey}`, epicFields);
          epicStoriesBaseline[epicKey] = deduplicateStoriesByKey((issues || [])
            .filter(story => {
              let created = new Date(story.fields.created);
              let resolved = story.fields.resolutiondate ? new Date(story.fields.resolutiondate) : null;
              let baseSprint = closedSprintsSorted.find(s=>s.id==baselineSprintId);
              let end = baseSprint ? new Date(baseSprint.endDate) : null;
              if (!validResolution(story.fields.resolution && story.fields.resolution.name)) return false;
              return created <= end && (!resolved || resolved > end);
            }).map(story => ({
            key: story.key,
            summary: story.fields.summary,
            status: story.fields.status && story.fields.status.name,
            resolution: story.fields.resolution && story.fields.resolution.name,
            assignee: story.fields.assignee && story.fields.assignee.displayName,
            points: Number(story.fields.customfield_10002) || 0,
            team: (story.fields.customfield_12600 || []).join(', '),
            created: story.fields.created,
            resolved: story.fields.resolutiondate,
            sprint: (story.fields.customfield_10005||[]).map(s=>s.name).join(', '),
            issuetype: story.fields.issuetype && story.fields.issuetype.name,
          })));
        } catch (e) {
          console.error(`Failed to fetch baseline stories for epic ${epicKey}`, e);
          epicStoriesBaseline[epicKey] = [];
        }
      }));
      let allTeams = new Set();
      Object.values(epicStories).forEach(arr => {
        arr.forEach(st => {
          getStoryTeams(st).forEach(t => { if (t) allTeams.add(t); });
        });
      });
      teamFilters = {};
      allTeams.forEach(t => { teamFilters[t] = false; });
      // --- FETCH HISTORICAL THROUGHPUT FROM JIRA REPORT ---
      throughputArr = await fetchThroughputFromReport(jiraDomain, boardNum, selectedSprintId);
      document.getElementById('configSection').style.display = '';
      renderThroughputInputs();
      renderEpicSummary();
      hideLoading();
    }

    // --- THROUGHPUT INPUTS ---
    function renderThroughputInputs() {
      let vhtml = throughputArr.map((v, i) => {
        const issues = (throughputIssues[i] || []).join(', ');
        const label = throughputWeekLabels[i] || (throughputWeekNums[i] ? `KW ${String(throughputWeekNums[i]).padStart(2,'0')}` : `Week ${i+1}`);
        return `<span style="white-space:nowrap;">${label}: <input class="editarr" type="number" min="0" value="${v}" onchange="editThroughput(this,${i})"><span class="info-icon" data-tip="${issues}" title="${issues}">&#9432;<span class="tooltip"></span></span></span>`;
      }).join(', ');
      document.getElementById('throughputWrap').innerHTML = vhtml;
      addTooltipListeners();
    }
    function editThroughput(inp, idx) { throughputArr[idx] = Number(inp.value) || 0; }

    function updateHistoricTotals() {
      const entry = {
        sprint: selectedSprintName || ('#'+selectedSprintId),
        date: new Date().toISOString().substr(0,10),
        epicBacklogs: Object.assign({}, epicBacklogs),
        backlog: Object.values(epicBacklogs).reduce((a,b)=>a+b,0)
      };
      historicData.push(entry);
      if (historicData.length>12) historicData.shift();
      saveHistoricData();
    }


    function renderFilterOptions() {
      if (statusChoices) { statusChoices.destroy(); statusChoices = null; }
      if (teamChoices) { teamChoices.destroy(); teamChoices = null; }

      const statusOpts = [
        ['current','Done this sprint'],
        ['previous','Done before'],
        ['new','New story'],
        ['open','Open/In Progress'],
        ['removed','Removed']
      ];

      const statusSelectHtml =
        '<select id="statusSelect" multiple>'+
        statusOpts.map(o=>`<option value="${o[0]}" ${storyFilters[o[0]]?'selected':''}>${o[1]}</option>`).join('')+
        '</select>';

      const teamSelectHtml =
        '<select id="teamSelect" multiple>'+
        Object.keys(teamFilters).sort().map(t=>`<option value="${t}" ${teamFilters[t]?'selected':''}>${t}</option>`).join('')+
        '</select>';

      document.getElementById('filterOptions').innerHTML =
        '<span class="section-title" style="display:block;margin-top:0;">Story Map Filters:<span class="info-icon" data-tip="Toggle visibility of stories by status in the story map.">&#9432;<span class="tooltip"></span></span></span>'+
        statusSelectHtml+
        (Object.keys(teamFilters).length ? '<br><span class="section-title" style="display:block;margin-top:0.8em;">Team Filter:<span class="info-icon" data-tip="Filter stories shown by their assigned teams.">&#9432;<span class="tooltip"></span></span></span>'+teamSelectHtml : '');

      const statusEl = document.getElementById('statusSelect');
      const teamEl = document.getElementById('teamSelect');

      statusChoices = new Choices(statusEl, { removeItemButton:true, shouldSort:false });
      if (teamEl) teamChoices = new Choices(teamEl, { removeItemButton:true, searchResultLimit:15, shouldSort:true });

      statusEl.addEventListener('change', ()=>{
        const sel = new Set(statusChoices.getValue(true));
        statusOpts.forEach(o=>{ storyFilters[o[0]] = sel.has(o[0]); });
        applyStoryFilters();
      });

      if (teamEl) teamEl.addEventListener('change', ()=>{
        const sel = new Set(teamChoices.getValue(true));
        Object.keys(teamFilters).forEach(t=>{ teamFilters[t] = sel.has(t); });
        renderEpicSummary(true);
      });
    }

      function applyStoryFilters() {
        document.querySelectorAll('.story-status-current').forEach(el=>el.style.display = storyFilters.current? '':'none');
        document.querySelectorAll('.story-status-previous').forEach(el=>el.style.display = storyFilters.previous? '':'none');
        document.querySelectorAll('.story-status-new').forEach(el=>el.style.display = storyFilters.new? '':'none');
        document.querySelectorAll('.story-status-open').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-inprogress').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-blocked').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-other').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.removed-lane').forEach(el=>el.style.display = storyFilters.removed? '':'none');
        document.querySelectorAll('.story-card').forEach(el=>{
          if (el.style.display==='none') return;
          const teams = parseTeamString(el.dataset.teams || '');
          if (!matchesTeamFilters(teams)) el.style.display='none';
        });
        updateEpicStatusCounts();
      }

      function updateEpicStatusCounts() {
        const currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
        const sprintEndRaw = currSprintObj && currSprintObj.endDate ? Date.parse(currSprintObj.endDate) : NaN;
        const snapshotTime = (currSprintObj && (currSprintObj.state||'').toLowerCase() === 'closed' && Number.isFinite(sprintEndRaw))
          ? sprintEndRaw
          : null;
        Object.keys(epicStories).forEach(epicKey => {
          let done=0, prog=0, open=0, blocked=0;
          let ptsDone=0, ptsProg=0, ptsOpen=0, ptsBlocked=0;
          (epicStories[epicKey]||[]).forEach(story => {
            let show=true;
            let cls = getStoryRowClass(story, currSprintObj);
            if (cls==='story-status-current' && !storyFilters.current) show=false;
            else if (cls==='story-status-previous' && !storyFilters.previous) show=false;
            else if (cls==='story-status-new' && !storyFilters.new) show=false;
            else if ((cls==='story-status-open' || cls==='story-status-inprogress' || cls==='story-status-blocked' || cls==='story-status-other') && !storyFilters.open) show=false;
            if (!show) return;
            if (!storyMatchesTeamFilters(story)) return;
            if (!storyIncludedAtTime(story, snapshotTime)) return;
            const grp = statusGroupAtTime(story, snapshotTime);
            if (grp==='Done') { done++; ptsDone+=story.points; }
            else if (grp==='In Progress') { prog++; ptsProg+=story.points; }
            else if (grp==='Open') { open++; ptsOpen+=story.points; }
            else if (grp==='Blocked') { blocked++; ptsBlocked+=story.points; }

          });
          const block=document.getElementById(`storyMap_${epicKey.replace(/[^a-zA-Z0-9]/g,'')}`);
          if (!block) return;
          const container=block.closest('.epic-summary-block');
          if (!container) return;
          const doneSpan=container.querySelector('.pill-done');
          const progSpan=container.querySelector('.pill-prog');
          const blockedSpan=container.querySelector('.pill-blocked');
          const openSpan=container.querySelector('.pill-open');
          if (doneSpan) doneSpan.textContent=`${done} Done (${ptsDone} SP)`;
          if (progSpan) progSpan.textContent=`${prog} In Progress (${ptsProg} SP)`;
          if (blockedSpan) blockedSpan.textContent=`${blocked} Blocked (${ptsBlocked} SP)`;
          if (openSpan) openSpan.textContent=`${open} Open (${ptsOpen} SP)`;
        });
      }

    function scopeIncreaseConsistent(epicKey) {
      if (historicData.length < 3) return false;
      const recs = historicData.slice(-3);
      const b1 = recs[0].epicBacklogs[epicKey] || 0;
      const b2 = recs[1].epicBacklogs[epicKey] || 0;
      const b3 = recs[2].epicBacklogs[epicKey] || 0;
      return (b2 > b1 && b3 > b2);
    }

    // --- MAIN REPORT RENDER ---
    function renderEpicSummary(skipHistory = false) {
      targetWeeks = Number(document.getElementById('targetWeeksInput').value) || 4;
      let throughput = throughputArr.filter(v=>v>0);
      if (throughput.length<3) {
        document.getElementById('epicSummary').innerHTML = '<div class="warn">Please set at least 3 recent throughput values.</div>';
        return;
      }
      avgThroughput = throughput.reduce((a,b)=>a+b,0)/throughput.length;
      const baselineSprintObj = closedSprintsSorted.find(s=>s.id==baselineSprintId);
      const baselineEnd = baselineSprintObj ? new Date(baselineSprintObj.endDate) : null;
      const baselineEndMs = baselineEnd ? baselineEnd.getTime() : NaN;
      const baselineEndTime = Number.isFinite(baselineEndMs) ? baselineEndMs : null;
      const currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
      const sprintStartRaw = currSprintObj && currSprintObj.startDate ? Date.parse(currSprintObj.startDate) : NaN;
      const sprintEndRaw = currSprintObj && currSprintObj.endDate ? Date.parse(currSprintObj.endDate) : NaN;
      const sprintStartTime = Number.isFinite(sprintStartRaw) ? sprintStartRaw : null;
      const sprintEndTime = Number.isFinite(sprintEndRaw) ? sprintEndRaw : null;
      const nowTime = Date.now();
      const snapshotTime = (currSprintObj && (currSprintObj.state||'').toLowerCase() === 'closed' && sprintEndTime != null)
        ? sprintEndTime
        : null;
      const comparisonEndTime = snapshotTime != null
        ? snapshotTime
        : (sprintEndTime != null ? Math.min(nowTime, sprintEndTime) : nowTime);
      const effectiveEndTime = Number.isFinite(comparisonEndTime) ? comparisonEndTime : null;
      const changeStartTime = baselineEndTime != null
        ? baselineEndTime
        : (sprintStartTime != null ? sprintStartTime : null);
      epicBacklogs = {};
      epicTotalIssues = {};
      let totalBacklog = 0;
      let totalSprintIssues = 0;
      Object.keys(epicStories).forEach(epicKey => {
        let stories = epicStories[epicKey]||[];
        let backlog = 0;
        let totalIssues = 0;
        stories.forEach(st => {
          if (!validResolution(st.resolution)) return;
          if (!storyMatchesTeamFilters(st)) return;
          if (!storyIncludedAtTime(st, snapshotTime)) return;
          totalIssues++;
          const grp = statusGroupAtTime(st, snapshotTime);
          if (grp === 'Done') return;
          backlog++;
        });
        epicBacklogs[epicKey] = backlog;
        totalBacklog += backlog;
        epicTotalIssues[epicKey] = totalIssues;
        totalSprintIssues += totalIssues;
      });
      epicAllocations = {};
      Object.keys(epicStories).forEach(epicKey => {
        const totalIssues = epicTotalIssues[epicKey] || 0;
        epicAllocations[epicKey] = totalSprintIssues ? Math.ceil(100*totalIssues/totalSprintIssues) : 0;
      });
      if (!skipHistory) updateHistoricTotals();
      renderFilterOptions();
      applyStoryFilters();
      epicForecastResults = {};
      epicRequiredAlloc = {};
      epicRequiredIssues = {};
      epicRequiredIssuesPrev = {};
      Object.keys(epicStories).forEach(epicKey => {
        let stories = epicStories[epicKey]||[];
        let backlogPts = epicBacklogs[epicKey];
        if (backlogPts <= 0) {
          epicForecastResults[epicKey] = [0];
          epicRequiredAlloc[epicKey] = { "75": 0, "95": 0 };
          epicRequiredIssues[epicKey] = { "75": 0, "95": 0 };
          return;
        }
        let alloc = epicAllocations[epicKey];
        let allocTPs = throughput.map(v=>v*alloc/100);
        let mcRuns = [];
        for (let i=0; i<10000; i++) {
          let b = backlogPts, w=0;
          while (b>0 && w<100) {
            let v = allocTPs[Math.floor(Math.random()*allocTPs.length)];
            if (v<1) v=1;
            b -= v; w++;
          }
          mcRuns.push(w);
        }
        mcRuns.sort((a,b)=>a-b);
        epicForecastResults[epicKey] = mcRuns;
        let allocNeeded = { "75": null, "95": null };
        for (let pct=1;pct<=100;pct++) {
          let testTPs = throughput.map(v=>v*pct/100);
          let runs = [];
          for (let i=0;i<5000;i++) {
            let b = backlogPts, w=0;
            while (b>0 && w<100) {
              let v = testTPs[Math.floor(Math.random()*testTPs.length)];
              if (v<1) v=1;
              b -= v; w++;
            }
            runs.push(w);
          }
          runs.sort((a,b)=>a-b);
          if (allocNeeded["75"] === null && runs[Math.floor(0.75*runs.length)]<=targetWeeks) allocNeeded["75"] = pct;
          if (allocNeeded["95"] === null && runs[Math.floor(0.95*runs.length)]<=targetWeeks) allocNeeded["95"] = pct;
          if (allocNeeded["75"] && allocNeeded["95"]) break;
        }
        epicRequiredAlloc[epicKey] = allocNeeded;
        epicRequiredIssues[epicKey] = {
          "75": allocNeeded["75"] ? Math.ceil(avgThroughput * allocNeeded["75"] / 100) : null,
          "95": allocNeeded["95"] ? Math.ceil(avgThroughput * allocNeeded["95"] / 100) : null
        };
    });

      Object.keys(epicStoriesBaseline).forEach(epicKey => {
        let stories = epicStoriesBaseline[epicKey] || [];
        let backlogPts = stories.filter(st => {
          if (!storyMatchesTeamFilters(st)) return false;
          if (!validResolution(st.resolution)) return false;
          let res = st.resolved ? new Date(st.resolved) : null;
          if (baselineEnd && res && res <= baselineEnd) return false;
          return true;
        }).length;
        if (backlogPts <= 0) {
          epicRequiredIssuesPrev[epicKey] = { "75": 0, "95": 0 };
          return;
        }
        let allocNeeded = { "75": null, "95": null };
        for (let pct=1;pct<=100;pct++) {
          let testTPs = throughput.map(v=>v*pct/100);
          let runs = [];
          for (let i=0;i<5000;i++) {
            let b = backlogPts, w=0;
            while (b>0 && w<100) {
              let v = testTPs[Math.floor(Math.random()*testTPs.length)];
              if (v<1) v=1;
              b -= v; w++;
            }
            runs.push(w);
          }
          runs.sort((a,b)=>a-b);
          if (allocNeeded["75"] === null && runs[Math.floor(0.75*runs.length)]<=targetWeeks) allocNeeded["75"] = pct;
          if (allocNeeded["95"] === null && runs[Math.floor(0.95*runs.length)]<=targetWeeks) allocNeeded["95"] = pct;
          if (allocNeeded["75"] && allocNeeded["95"]) break;
        }
        epicRequiredIssuesPrev[epicKey] = {
          "75": allocNeeded["75"] ? Math.ceil(avgThroughput * allocNeeded["75"] / 100) : null,
          "95": allocNeeded["95"] ? Math.ceil(avgThroughput * allocNeeded["95"] / 100) : null
        };
      });

      let totalAlloc = Object.values(epicAllocations).reduce((a,b)=>a+b,0);
      let allocWarn = '';
      if (totalAlloc < 99) allocWarn = `<span class="warn">Warning: Not all team capacity is assigned to listed epics (${totalAlloc}% total).</span>`;
      else if (totalAlloc > 101) allocWarn = `<span class="warn">Warning: Allocations exceed 100% of capacity! (${totalAlloc}%)</span>`;
      else allocWarn = `<span class="success">Team allocation: ${totalAlloc}%</span>`;

      let totalReq75 = 0, totalReq95 = 0;
      Object.values(epicRequiredAlloc).forEach(r => {
        totalReq75 += r["75"] != null ? r["75"] : 101;
        totalReq95 += r["95"] != null ? r["95"] : 101;
      });
      totalReq75 = Math.ceil(totalReq75);
      totalReq95 = Math.ceil(totalReq95);
      let reqWarn = (totalReq75 > 100 || totalReq95 > 100)
        ? `<span class="warn">Required allocations exceed team capacity. Not all epics likely to finish.</span>`
        : `<span class="success">Required allocations within team capacity.</span>`;
      document.getElementById('requiredSummary').innerHTML =
        `<div><b>Sum of required allocation to finish in ${targetWeeks} weeks:</b><span class="info-icon" data-tip="Combined team capacity needed across all epics to meet the target goal.">&#9432;<span class="tooltip"></span></span> `+
        `${totalReq75}% at 75% confidence &nbsp; | &nbsp; ${totalReq95}% at 95% confidence`+
        `<br>${reqWarn}</div>`;
      // The total allocation info is still calculated for simulations but no longer displayed in the UI
      let html = '';

      Object.keys(epicStories).forEach((epicKey, idx) => {
        let stories = epicStories[epicKey];
        if (!stories || !stories.length) return;
        const relevantStories = stories.filter(story => storyIncludedAtTime(story, snapshotTime));
        let statusCounts = {done:0,prog:0,open:0,blocked:0};
        let ptsDone=0, ptsProg=0, ptsOpen=0, ptsBlocked=0;
        let unestimated = 0;
        relevantStories.forEach(story => {
          const sgrp = statusGroupAtTime(story, snapshotTime);
          if (sgrp==='Done') { statusCounts.done++; ptsDone+=story.points; }
          else if (sgrp==='In Progress') { statusCounts.prog++; ptsProg+=story.points; }
          else if (sgrp==='Open') { statusCounts.open++; ptsOpen+=story.points; }
          else if (sgrp==='Blocked') { statusCounts.blocked++; ptsBlocked+=story.points; }

          if (!story.points && sgrp!=='Done') unestimated++;
        });
        let totalEstimate = ptsDone+ptsProg+ptsOpen+ptsBlocked;
        let backlog = ptsProg+ptsOpen+ptsBlocked;
        let alloc = epicAllocations[epicKey];
        let required = epicRequiredAlloc[epicKey];
        let mc = epicForecastResults[epicKey];
        let probRows = [[50,mc[Math.floor(0.5*mc.length)]],[75,mc[Math.floor(0.75*mc.length)]],[95,mc[Math.floor(0.95*mc.length)]]];

        let baseStories = (epicStoriesBaseline[epicKey]||[]).filter(st => storyMatchesTeamFilters(st));
        const currStories = relevantStories;
        let currKeys = new Set(currStories.map(s=>s.key));
        let newStories = currStories.filter(s => {
          if (!Number.isFinite(sprintStartTime) || effectiveEndTime == null) return false;
          const createdTime = typeof s.createdTs === 'number'
            ? s.createdTs
            : (s.created ? Date.parse(s.created) : NaN);
          if (!Number.isFinite(createdTime)) return false;
          return createdTime >= sprintStartTime && createdTime < effectiveEndTime;
        });
        let removedStories = baseStories.filter(s=>!currKeys.has(s.key));
        let doneSince = effectiveEndTime == null
          ? 0
          : relevantStories
            .filter(s => storyResolvedBetween(s, changeStartTime, effectiveEndTime))
            .reduce((a,b)=>a + b.points, 0);
        let estimateBaseline = baseStories.map(s=>s.points).reduce((a,b)=>a+b,0);

        let deltaEstimate = backlog - estimateBaseline;
        const storyMapId = `storyMap_${epicKey.replace(/[^a-zA-Z0-9]/g, '')}`;
        const risk = ((required["75"] && required["75"]-alloc>15) || scopeIncreaseConsistent(epicKey));
        html += `
        <div class="epic-summary-block ${risk?'epic-risk':''}">
          <div class="epic-header">${epicKey}: ${allEpics[epicKey]||''}</div>
          <div style="margin-top:4px;margin-bottom:10px;">
            <span class="status-pill pill-done">${statusCounts.done} Done (${ptsDone} SP)</span>
            <span class="status-pill pill-prog">${statusCounts.prog} In Progress (${ptsProg} SP)</span>
            <span class="status-pill pill-blocked">${statusCounts.blocked} Blocked (${ptsBlocked} SP)</span>
            <span class="status-pill pill-open">${statusCounts.open} Open (${ptsOpen} SP)</span><br>
            <b>Total:</b> ${totalEstimate} SP &nbsp; | &nbsp; <b>Backlog:</b> ${backlog} SP &nbsp; | &nbsp; <b>Unestimated:</b> ${unestimated}
          </div>
          <div class="info-grid">
            <div>
              <div style="margin-bottom:4px;">
                <b>Team allocation for this epic:</b><span class="info-icon" data-tip="Percentage of team capacity dedicated to this epic.">&#9432;<span class="tooltip"></span></span>
                <span style="font-size:1.1em;font-weight:600;">${alloc}%</span>
                <div class="allocation-bar" style="width:${2*alloc}px"></div>
              </div>
              <div>
                <table class="prob-table">
                  <tr><th>Confidence</th><th>Weeks Needed</th></tr>
                  ${probRows.map(r=>`<tr><td>${r[0]}%</td><td>${r[1]}</td></tr>`).join('')}
                </table>
              </div>
              <div style="margin-bottom:8px;">
                <b>Required allocation${unestimated>0?'+':''} to finish in ${targetWeeks} weeks:</b>
                <ul style="margin:3px 0 0 0;padding-left:1.3em;">
                  ${(() => {
                    const fmt = pct => {
                      const sp = epicRequiredIssues[epicKey][pct];
                      if (sp != null) {
                        const plus = unestimated>0?'+':'';
                        return `${sp}${plus} issues/week (${required[pct]}${plus}%)`;
                      }
                      return '<span class="warn">Over 100%</span>';
                    };
                    const prev = pct => {
                      const sp = (epicRequiredIssuesPrev[epicKey]||{})[pct];
                      return sp != null ? `${sp} issues` : 'n/a';
                    };
                    return [
                      `<li>75% confidence: ${fmt("75")} <span style="font-size:0.9em;color:#555;">(last week: ${prev("75")})</span><span class="info-icon" data-tip="Estimated capacity per week for a 75% chance of finishing on time. Calculated using Monte Carlo simulations.">&#9432;<span class="tooltip"></span></span></li>`,
                      `<li>95% confidence: ${fmt("95")} <span style="font-size:0.9em;color:#555;">(last week: ${prev("95")})</span><span class="info-icon" data-tip="Capacity needed for a 95% likelihood of completion within the target weeks. Based on Monte Carlo results.">&#9432;<span class="tooltip"></span></span></li>`
                    ].join('');
                  })()}
                </ul>
              </div>
              <div style="font-size:0.99em;">
                ${probRows[1][1] > targetWeeks ?
                  `<span class="warn">At 75% confidence, this epic is <b>not likely</b> to finish in ${targetWeeks} weeks.<br>
                  More allocation or throughput needed.</span>`
                  :
                  `<span class="success">On track to finish in ${targetWeeks} weeks at 75% confidence.</span>`
                }
              </div>
            </div>
            <div>
                <div class="pdf-section-title" style="margin-top:0;">Changes since last sprint:<span class="info-icon" data-tip="Summary of completed, new and removed stories plus overall scope change since the previous sprint.">&#9432;<span class="tooltip"></span></span></div>
              <div class="change-block">
                <ul>
                  <li>Story points completed: <b>${doneSince}</b></li>
                  <li>New stories: <b>${newStories.length}</b> (${newStories.reduce((a,b)=>a+b.points,0)} SP)</li>
                  <li>Removed stories: <b>${removedStories.length}</b> (${removedStories.reduce((a,b)=>a+b.points,0)} SP)</li>
                  <li>
                    Scope change: ${
                      deltaEstimate===0 ? "No change"
                      : (deltaEstimate>0?'<span class="warn">Increased (+'
                        +deltaEstimate+')</span>':'<span class="success">Reduced ('+deltaEstimate+')</span>')
                    }
                    
                  </li>
                </ul>
              </div>
            </div>
          </div>
          <label class="epic-select-label"><input type="checkbox" class="epic-select-checkbox" data-epic="${epicKey}" checked> Include in PDF</label>
          <button class="btn details-toggle" onclick="toggleEpicDetails(this, '${storyMapId}')">Show Details</button>
          <div id="${storyMapId}" style="display:none; margin-top:10px;">
            <div class="story-map">
              ${(() => {
                const newSet = new Set(newStories.map(s=>s.key));
                const lanes = [
                  ['Done', currStories.filter(s=>statusGroupAtTime(s, snapshotTime)==='Done')],
                  ['In Progress', currStories.filter(s=>statusGroupAtTime(s, snapshotTime)==='In Progress')],
                  ['Open', currStories.filter(s=>statusGroupAtTime(s, snapshotTime)==='Open')],
                  ['Blocked', currStories.filter(s=>statusGroupAtTime(s, snapshotTime)==='Blocked')]
                ];
                return lanes.map(l => `
                  <div class="story-lane">
                    <div class="story-lane-header">${l[0]}</div>
                    ${l[1].map(st => {
                      const c = getStoryRowClass(st, currSprintObj);
                      const tags = [];
                      if (newSet.has(st.key)) tags.push('New');
                      if (c==='story-status-current') tags.push('Done now');
                      if (st.issuetype) tags.push(st.issuetype);
                      return `<div class="story-card ${c}" data-teams="${st.team}">
                        <div><b>${st.key}</b> (${st.points} SP)</div>
                        <div>${st.summary}</div>
                        <div class="small">${st.status}${st.assignee? ' - '+st.assignee : (st.team?' - '+st.team:'')}</div>
                        <div class="small">${st.created?st.created.substr(0,10):''}${st.resolved?' â†’ '+st.resolved.substr(0,10):''}</div>
                        ${tags.length?`<div class="tags">${tags.map(t=>`<span class="story-tag">${t}</span>`).join('')}</div>`:''}
                      </div>`;
                    }).join('')}
                  </div>
                `).join('');
              })()}
              ${removedStories.length?`
                <div class="story-lane removed-lane">
                  <div class="story-lane-header">Removed since last sprint</div>
                  ${removedStories.map(st=>`<div class="story-card story-status-other" data-teams="${st.team}"><b>${st.key}</b> (${st.points} SP)${st.resolution?` - ${st.resolution}`:''}${st.issuetype?`<div class="tags"><span class="story-tag">${st.issuetype}</span></div>`:''}</div>`).join('')}
                </div>
              `:''}
            </div>
            <div class="story-map-legend" style="font-size:0.95em;margin-top:8px;">
              <span class="story-status-current">Done this sprint</span>
              <span class="story-status-new">New story</span>
              <span class="removed-lane">Removed since last sprint</span>
            </div>
          </div>
        </div>
        `;
      });
      document.getElementById('epicSummary').innerHTML = html;
      applyStoryFilters();
      addTooltipListeners();
    }

    function toggleEpicDetails(btn, id) {
      const block = document.getElementById(id);
      if (block.style.display === "none") {
        block.style.display = "";
        btn.textContent = "Hide Details";
      } else {
        block.style.display = "none";
        btn.textContent = "Show Details";
      }
    }

    function isDone(status) {
      status = (status||'').toLowerCase();
      return status.includes("done") || status.includes("closed");
    }
    function validResolution(res) {
      if (!res) return true;
      res = res.toLowerCase().trim();
      const invalid = [
        'duplicate',
        "won't do", 'wont do',
        "won't fix", 'wont fix',
        'reject', 'rejected',
        'canceled', 'cancelled',
        'cannot reproduce', "can't reproduce",
        'other'
      ];
      if (invalid.some(v => res.includes(v))) return false;
      const validKeywords = [
        'done',
        'implement',
        'fixed',
        'resolve',
        'complete', 'completed',
        'close',
        'accept',
        'release'
      ];
      return validKeywords.some(v => res.includes(v));
    }
    function statusGroup(s) {
      s = (s||"").toLowerCase();
      if (s.includes("done") || s.includes("closed")) return "Done";
      if (s.includes("block")) return "Blocked";
      if (s.includes("progress") || s.includes("development")) return "In Progress";
      return "Open";
    }

    function getStatusAtTime(story, targetTime) {
      if (!Number.isFinite(targetTime) || !story) return story ? story.status : '';
      let status = story.status || '';
      const history = Array.isArray(story.statusHistory) ? story.statusHistory : [];
      for (let i = history.length - 1; i >= 0; i--) {
        const change = history[i];
        if (!change) continue;
        const changeTime = typeof change.date === 'number' ? change.date : NaN;
        if (!Number.isFinite(changeTime)) continue;
        if (changeTime > targetTime) {
          status = change.from || status;
        } else {
          break;
        }
      }
      return status;
    }

    function statusGroupAtTime(story, targetTime) {
      const statusStr = Number.isFinite(targetTime) ? getStatusAtTime(story, targetTime) : (story ? story.status : '');
      return statusGroup(statusStr);
    }

    function storyIncludedAtTime(story, targetTime) {
      if (!storyMatchesTeamFilters(story)) return false;
      if (Number.isFinite(targetTime)) {
        const createdTime = typeof story.createdTs === 'number'
          ? story.createdTs
          : (story.created ? Date.parse(story.created) : NaN);
        if (Number.isFinite(createdTime) && createdTime > targetTime) return false;
      }
      return true;
    }

    function storyResolvedBetween(story, startTime, endTime) {
      if (!story) return false;
      let doneTime = typeof story.resolvedTs === 'number' ? story.resolvedTs : null;
      if (doneTime == null && typeof story.doneTs === 'number') doneTime = story.doneTs;
      if (doneTime == null) return false;
      if (Number.isFinite(endTime) && doneTime > endTime) return false;
      if (Number.isFinite(startTime) && doneTime <= startTime) return false;
      if (Number.isFinite(endTime) && statusGroupAtTime(story, endTime) !== 'Done') return false;
      return true;
    }

    function hexToRgb(hex) {
      const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      return m ? {
        r: parseInt(m[1], 16),
        g: parseInt(m[2], 16),
        b: parseInt(m[3], 16)
      } : {r:0,g:0,b:0};
    }

    function temporarilyRemoveExternalStylesheets() {
      const removed = [];
      document.querySelectorAll('link[rel="stylesheet"][data-pdf-ignore="true"]').forEach(link => {
        removed.push({
          parent: link.parentNode,
          nextSibling: link.nextSibling,
          element: link
        });
        if (link.parentNode) link.parentNode.removeChild(link);
      });
      return () => {
        removed.forEach(({ parent, element, nextSibling }) => {
          if (!parent) return;
          if (nextSibling && nextSibling.parentNode === parent) {
            parent.insertBefore(element, nextSibling);
          } else if (!element.parentNode) {
            parent.appendChild(element);
          }
        });
      };
    }

    // --- PDF EXPORT (CLEAN SUMMARY ONLY) ---
    async function exportPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit:'pt', format:'a4' });
      const blocks = Array.from(document.querySelectorAll('.epic-summary-block'))
        .filter(b => b.querySelector('.epic-select-checkbox')?.checked);
      if (!blocks.length) return alert('Select at least one epic for PDF');

      const restoreExternalStyles = temporarilyRemoveExternalStylesheets();
      const margin = 20;
      try {
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const maxWidth = pageWidth - margin * 2;
        const maxHeight = pageHeight - margin * 2;
        // KPI_Report.html can export charts directly because Chart.js already paints
        // everything onto <canvas> elements. The weekly throughput report renders
        // complex HTML cards instead, so we rasterise each block with html-to-image
        // before embedding it into the PDF.
        for (let i=0; i<blocks.length; i++) {
          if (i>0) pdf.addPage();
          const dataUrl = await htmlToImage.toPng(blocks[i], {
            pixelRatio: 2,
            skipFonts: true,
            cacheBust: true
          });
          const imgProps = pdf.getImageProperties(dataUrl);
          const ratio = Math.min(maxWidth / imgProps.width, maxHeight / imgProps.height, 1);
          const renderWidth = imgProps.width * ratio;
          const renderHeight = imgProps.height * ratio;
          const x = margin + (maxWidth - renderWidth) / 2;
          const y = margin;
          pdf.addImage(dataUrl, 'PNG', x, y, renderWidth, renderHeight, undefined, 'FAST');
        }
        const dateStr = new Date().toISOString().split('T')[0];
        pdf.save(`Stakeholder_StatusReport_WeeklyThroughput_${dateStr}.pdf`);
      } catch (err) {
        console.error('PDF export failed', err);
        alert('Unable to generate the PDF report. Please try again.');
      } finally {
        restoreExternalStyles();
      }
    }
  </script>
</body>
</html>
