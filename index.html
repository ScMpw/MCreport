<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stakeholder PI Status Report – MCW with Allocation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" data-pdf-ignore="true">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" data-pdf-ignore="true" />
  <link rel="stylesheet" href="public/tailwind.css">
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <style>
    html { background: #f7f8fa; }
    body { background: #f7f8fa; font-family: 'Inter', Arial, sans-serif; margin: 0; padding: 0; }
    .main { max-width: 950px; margin: 30px auto 40px auto; background: #fff; border-radius: 18px; box-shadow: 0 2px 12px #d1d5db70; padding: 36px 32px; }
    h1 { font-size: 2.3em; margin:0 0 0.7em 0; font-weight: 600; }
    h2 { font-size: 1.3em; margin-top:2em; }
    .btn { background: #6366f1; color: #fff; border: none; border-radius: 6px; padding: 7px 18px; cursor: pointer; font-size:1em; margin: 0 10px 8px 0;}
    .btn:disabled { background: #aaa; }
    .sprint-row label { margin-right: 1.2em; }
    .section-title { font-size: 1.1em; font-weight: 600; margin: 1.7em 0 0.5em 0; }
    .epic-summary-block { margin:2em 0 2.5em 0; border-radius:14px; background: #f3f4f6; box-shadow: 0 1px 6px #e0e7ef70; padding: 24px 24px 18px 24px; position:relative; }
    .epic-risk { border:2px solid #e11d48; box-shadow:0 0 6px #e11d48; }
    .epic-select-label { position:absolute; bottom:8px; right:8px; font-size:0.9em; }
    .epic-select-checkbox { margin-right:4px; }
    .epic-header { font-size: 1.15em; font-weight: 600; color: #374151; }
    .allocation-bar { height: 18px; border-radius: 8px; background: #6366f1; display:inline-block; vertical-align:middle;}
    .prob-table { border-collapse:collapse; margin:12px 0 18px 0;}
    .prob-table th, .prob-table td { border:1px solid #e5e7eb; font-size:0.98em; padding:4px 11px;}
    .prob-table th { background:#e0e7ef;}
    .info-grid { display:grid; grid-template-columns:1.7fr 1.3fr; gap:1.5em; }
    .change-block { font-size: 0.99em; }
    .status-pill { display:inline-block; min-width:64px; font-size:0.96em; border-radius:12px; padding:1.5px 13px; margin-right:6px; margin-bottom:3px;}
    .pill-done { background:#10b981; color:#fff; }
    .pill-prog { background:#f59e0b; color:#fff; }
    .pill-blocked { background:#ef4444; color:#fff; }
    .pill-open { background:#3b82f6; color:#fff; }
    .warn { color:#e11d48; font-weight: 600;}
    .success { color:#059669; font-weight:600;}
    .allocation-row {margin-bottom: 12px;}
    .alloc-label {display:inline-block; min-width: 80px;}
    .editarr { width: 50px;}
    .pdf-cover { font-size:2.1em; text-align:center; margin-top:80px; color:#6366f1;}
    .pdf-sub { font-size:1.1em; color:#374151; text-align:center; margin-top:20px;}
    .pdf-section-title { font-size:1.15em; font-weight:600; margin-top:25px;}
    .details-toggle { margin: 10px 0 6px 0; }
    .story-table { border-collapse: collapse; width: 100%; margin: 6px 0 18px 0; }
    .story-table th, .story-table td { border: 1px solid #e5e7eb; padding: 4px 7px; font-size: 0.98em; text-align:left; }
    .story-table th { background: #e0e7ef; }
    .story-status-current { background: #b3e5fc; }
    .story-status-previous { background: none; }
    .story-status-new { background: #fff9c4; }
    .story-status-open { background: none; }
    .story-status-inprogress { background: none; }
    .story-status-blocked { background: none; }
    .story-status-other { background: #e0e0e0; }
    .story-map { display:flex; gap:12px; overflow-x:auto; }
    .story-lane { flex:1; min-width:180px; background:#fafafa; border:1px solid #e5e7eb; border-radius:6px; padding:6px; }
    .removed-lane { background:#ffe4e6; }
    .removed-lane .story-card.story-status-other { background:#ffd6dc; }
    .story-lane-header { font-weight:600; margin-bottom:4px; font-size:0.96em; color:#374151; }
    .story-card { border:1px solid #e5e7eb; border-radius:4px; padding:4px 5px; margin-bottom:6px; background:white; font-size:0.92em; }
    .story-card.story-status-current { background:#b3e5fc; }
    .story-card.story-status-previous { background:none; }
    .story-card.story-status-new { background:#fff9c4; }
    .story-card.story-status-open { background:none; }
    .story-card.story-status-inprogress { background:none; }
    .story-card.story-status-blocked { background:none; }
    .story-card.story-status-other { background:#e0e0e0; }
    .story-card .tags { margin-top:2px; }
    .story-tag { font-size:0.75em; background:#d1d5db; color:#111; border-radius:3px; padding:1px 4px; margin-right:3px; }
    .story-card .small { font-size:0.8em; color:#555; }
    .story-map-legend span {
      display:inline-block;
      padding:2px 8px;
      border-radius:4px;
      margin-right:6px;
      border:1px solid #9ca3af;
      font-weight:600;
    }
    .info-icon {
      cursor:pointer;
      font-size:0.9em;
      color:#555;
      margin-left:4px;
      position:relative;
      user-select:none;
    }
    .info-icon .tooltip {
      display:none;
      position:absolute;
      top:1.2em;
      left:0;
      background:#333;
      color:#fff;
      padding:3px 6px;
      border-radius:4px;
      font-size:0.82em;
      max-width:220px;
      white-space:normal;
      z-index:20;
    }
    .info-icon.active .tooltip { display:block; }
    /* Choices.js dropdown width */
    .choices__list--dropdown { min-width: 240px; }
    @media (max-width: 800px) {
      .main {padding:14px;}
      .info-grid {grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div class="main">
    <h1>Stakeholder PI Status Report (Monte Carlo, Resource Allocation)</h1>
    <div style="margin-bottom:10px;">
      <label>Version:
        <select id="versionSelect" onchange="switchVersion(this.value)">
          <option value="index.html" selected>Velocity</option>
          <option value="index_throughput_week.html">Weekly Throughput</option>
        </select>
      </label>
    </div>
    <div>
      <label>Board:
        <select id="boardNum">
          <option value="">Select a board…</option>
        </select>
      </label>
      <button class="btn" onclick="fetchAllSprints()">Fetch Sprints</button>
    </div>
    <div class="sprint-row" id="sprintRow" style="display:none; margin:1.1em 0;">
      <label>Sprint:
        <select id="sprintSelect"></select>
      </label>
      <button class="btn" onclick="fetchAll()">Load Data</button>
    </div>
    <div id="loadingMessage" style="display:none; font-weight:bold; margin:10px 0;"></div>

    <div id="configSection" style="display:none;">
      <div class="section-title">Velocity History (editable, last 6 closed sprints):</div>
      <div id="velocityWrap"></div>
      <div style="margin:0.9em 0 1.6em 0;">
        <label>Target Sprints for Delivery:
          <input id="targetSprintsInput" type="number" min="1" max="20" value="4" style="width:60px">
        </label>
        <button class="btn" onclick="renderEpicSummary()">Update Report</button>
        <button class="btn" onclick="exportPDF()">Download PDF Report</button>
      </div>
      <div id="filterOptions" style="margin-bottom:15px;"></div>
      <div id="requiredSummary" style="margin-bottom:15px;"></div>
      <div id="epicSummary"></div>
    </div>
  </div>
  <script src="src/jira.js"></script>
  <script>
const DEFAULT_JIRA_DOMAIN = 'aldi-sued.atlassian.net';
let jiraDomain = DEFAULT_JIRA_DOMAIN, boardNum = '', sprints = [], closedSprintsSorted = [];
const boardSelect = document.getElementById('boardNum');
let boardChoices = new Choices(boardSelect, {
  shouldSort: false,
  itemSelectText: '',
  searchPlaceholderValue: 'Search boards...'
});

function createPlaceholder(label = 'Select a board…') {
  return { value: '', label, disabled: true, selected: true };
}

async function populateBoards() {
  boardChoices.clearChoices();
  boardChoices.setChoices([createPlaceholder()], 'value', 'label', true);
  try {
    const boards = await Jira.fetchBoardsByJql(DEFAULT_JIRA_DOMAIN);
    if (!boards.length) {
      boardChoices.setChoices([
        createPlaceholder('No boards available')
      ], 'value', 'label', true);
      return;
    }
    boardChoices.setChoices([
      createPlaceholder(),
      ...boards.map(b => ({ value: String(b.id), label: b.name }))
    ], 'value', 'label', true);
  } catch (e) {
    console.error('Failed to load boards', e);
    boardChoices.setChoices([
      createPlaceholder('Failed to load boards')
    ], 'value', 'label', true);
  }
}

populateBoards();

boardSelect.addEventListener('change', () => {
  boardNum = boardSelect.value;
  document.getElementById('sprintRow').style.display = 'none';
  document.getElementById('configSection').style.display = 'none';
});

let allEpics = {}, epicStories = {}, epicStoriesBaseline = {};
let velocityArr = [];
let avgVelocity = 0;
let selectedSprintId = '', selectedSprintName = '', targetSprints = 4;
let baselineSprintId = '';

function deduplicateStoriesByKey(stories) {
  const seen = new Set();
  return (stories || []).filter(story => {
    if (!story || !story.key) return true;
    if (seen.has(story.key)) return false;
    seen.add(story.key);
    return true;
  });
}

function escapeHtml(str = '') {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function parseTeamString(teamStr = '') {
  const seen = new Set();
  return teamStr
    .split(',')
    .map(t => t.trim())
    .filter(t => {
      if (!t || seen.has(t)) return false;
      seen.add(t);
      return true;
    });
}

function getStoryTeams(story) {
  return parseTeamString(story && story.team ? story.team : '');
}

function matchesTeamFilters(teams, filters = teamFilters) {
  if (!filters || !Object.keys(filters).length) return true;
  const active = Object.keys(filters).filter(key => filters[key]);
  if (!active.length) return true;
  if (!Array.isArray(teams) || !teams.length) return false;
  return teams.some(t => filters[t]);
}

function storyMatchesTeamFilters(story, filters = teamFilters) {
  return matchesTeamFilters(getStoryTeams(story), filters);
}
document.getElementById('versionSelect').value = 'index.html';
function switchVersion(page) {
  if (page !== 'index.html') location.href = page;
}
// Note: the KPI report fetches data via sprint and issue endpoints only, so it
// never calls this helper. These dashboards rely on Jira's /search API which
// triggers a CORS preflight when issued as POST from GitHub Pages. Prefer GET
// to avoid the failing preflight and fall back to POST for large queries.
async function jiraSearch(jql, fields = [], options = {}) {
  const searchUrl = `https://${jiraDomain}/rest/api/3/search/jql`;
  const maxResults = options.maxResults || 500;
  let startAt = options.startAt || 0;
  const collected = [];
  const fieldList = Array.isArray(fields) ? fields.filter(Boolean) : (fields ? [fields] : []);
  const expandList = Array.isArray(options.expand)
    ? options.expand.filter(Boolean)
    : (options.expand ? [options.expand] : []);
  let useGet = true;

  const buildPayload = () => {
    const payload = { jql, startAt, maxResults };
    if (fieldList.length) payload.fields = fieldList;
    if (expandList.length) payload.expand = expandList;
    return payload;
  };

  while (true) {
    let resp;
    try {
      if (useGet) {
        const params = new URLSearchParams();
        params.set('jql', jql);
        params.set('startAt', String(startAt));
        params.set('maxResults', String(maxResults));
        if (fieldList.length) params.set('fields', fieldList.join(','));
        if (expandList.length) params.set('expand', expandList.join(','));
        const url = `${searchUrl}?${params.toString()}`;
        resp = await fetch(url, {
          method: 'GET',
          credentials: 'include',
          headers: {
            'Accept': 'application/json'
          }
        });
      } else {
        const payload = buildPayload();
        resp = await fetch(searchUrl, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Atlassian-Token': 'no-check'
          },
          body: JSON.stringify(payload)
        });
      }
    } catch (err) {
      if (useGet) {
        console.warn('Jira search GET request failed, retrying with POST', err);
        useGet = false;
        continue;
      }
      console.error('Jira search request failed', err);
      throw err;
    }

    if (useGet && [405, 413, 414].includes(resp.status)) {
      console.warn(`Jira search GET returned status ${resp.status}, retrying with POST.`);
      useGet = false;
      continue;
    }

    if (!resp.ok) {
      const text = await resp.text();
      console.error('Jira search failed', resp.status, text);
      throw new Error(`Jira search failed (${resp.status})`);
    }

    const data = await resp.json();
    const issues = Array.isArray(data.issues) ? data.issues : [];
    collected.push(...issues);

    const pageSize = data.maxResults || issues.length || maxResults;
    const total = typeof data.total === 'number' ? data.total : null;
    const nextStart = (data.startAt || 0) + pageSize;
    const receivedAll = !issues.length || (total !== null && collected.length >= total) || issues.length < pageSize;

    if (receivedAll) {
      return { issues: collected, total: total !== null ? total : collected.length };
    }

    if (nextStart <= startAt) {
      return { issues: collected, total: total !== null ? total : collected.length };
    }

    startAt = nextStart;
  }
}
let epicAllocations = {}, epicBacklogs = {}, epicRequiredAlloc = {}, epicRequiredSP = {},
    epicRequiredSPPrev = {};
let epicForecastResults = {};
let historicData = [];
let storyFilters = { current:true, previous:true, new:true, open:true, removed:true };
let boardTeams = [];
let teamFilters = {};
let statusChoices = null;
let teamChoices = null;

function showLoading(msg) {
  const el = document.getElementById('loadingMessage');
  if (el) {
    el.textContent = msg || 'Loading...';
    el.style.display = '';
  }
}

function hideLoading() {
  const el = document.getElementById('loadingMessage');
  if (el) el.style.display = 'none';
}

function addTooltipListeners() {
  document.querySelectorAll('.info-icon').forEach(icon => {
    icon.addEventListener('click', e => {
      e.stopPropagation();
      const tip = icon.querySelector('.tooltip');
      if (tip) tip.textContent = icon.dataset.tip || '';
      icon.classList.toggle('active');
    });
  });
  document.addEventListener('click', () => {
    document.querySelectorAll('.info-icon.active').forEach(i => i.classList.remove('active'));
  });
}


    function loadHistoricData() {
      try { historicData = JSON.parse(localStorage.getItem('mc_hist')) || []; }
      catch (e) { historicData = []; }
    }

    function saveHistoricData() {
      localStorage.setItem('mc_hist', JSON.stringify(historicData));
    }

    loadHistoricData();
    renderFilterOptions();
    addTooltipListeners();

    // --- NEW: FETCH JIRA VELOCITY REPORT (Greenhopper REST API) ---
    async function fetchVelocityFromReport(jiraDomain, boardNum) {
      const url = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/velocity?rapidViewId=${boardNum}`;
      const resp = await fetch(url, { credentials: "include" });
      if (!resp.ok) {
        alert("Failed to fetch velocity report. Are you logged in to Jira?");
        return [];
      }
      const data = await resp.json();
      // Attempt to read velocity values from the standard report
      let closed = (data.sprints || []).filter(s => s.state === "CLOSED");
      closed.sort((a, b) => {
        const ad = a.endDate || a.completeDate || a.startDate || '';
        const bd = b.endDate || b.completeDate || b.startDate || '';
        return ad && bd ? new Date(bd) - new Date(ad) : 0;
      });
      closed = closed.slice(0, 6);
      let velocities = closed.map(s => {
        const entry = data.velocityStatEntries[s.id];
        return entry ? entry.completed.value : 0;
      });
      console.log('Most recent 6 sprint velocities:', velocities, closed.map(s=>s.name));

      // Fallback: if fewer than 3 velocities are non-zero, try sprint reports
      if (velocities.filter(v => v > 0).length < 3) {
        velocities = await Promise.all(closed.map(async s => {
          const surl = `https://${jiraDomain}/rest/greenhopper/1.0/rapid/charts/sprintreport?rapidViewId=${boardNum}&sprintId=${s.id}`;
          try {
            const r = await fetch(surl, { credentials: "include" });
            if (!r.ok) return 0;
            const d = await r.json();
            return d.contents?.completedIssuesEstimateSum?.value || 0;
          } catch (e) { return 0; }
        }));
        console.log('Fallback sprint report velocities:', velocities);
      }
      return velocities;
    }

    async function fetchBoardTeam() {
      boardTeams = [];
      try {
        const cfgUrl = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/configuration`;
        const cfgResp = await fetch(cfgUrl, { credentials: "include" });
        if (!cfgResp.ok) return;
        const cfg = await cfgResp.json();
        const filterId = cfg.filter && cfg.filter.id;
        if (!filterId) return;
        const fResp = await fetch(`https://${jiraDomain}/rest/api/3/filter/${filterId}`, { credentials: "include" });
        if (!fResp.ok) return;
        const fd = await fResp.json();
        const jql = fd.jql || '';
        const regex = /(?:"Team"|customfield_12600|cf\[12600\])\s*(?:=|in)\s*(\([^\)]*\)|"[^"\n]+")/gi;
        let m;
        while ((m = regex.exec(jql)) !== null) {
          let str = m[1].replace(/[()]/g, '');
          str.split(',').forEach(t => {
            t = t.replace(/"/g, '').trim();
            if (t && !boardTeams.includes(t)) boardTeams.push(t);
          });
        }
      } catch (e) {
        console.error('Failed to fetch board team', e);
      }
      console.log('Board teams:', boardTeams.join(', '));
    }



    // --- SPRINT FETCH & SELECTION (paginated, NO sorting after fetch) ---
    async function fetchAllSprints() {
      jiraDomain = DEFAULT_JIRA_DOMAIN;
      boardNum = boardSelect.value.trim();
      if (!boardNum) return alert("Select a board.");

      showLoading('Fetching sprints...');
      await fetchBoardTeam();

      let allSprintsArr = [];
      let startAt = 0;
      const maxResults = 50; // Jira API typically caps sprint pages at 50
      let total = null;

      while (true) {
        const url = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/sprint?maxResults=${maxResults}&startAt=${startAt}`;
        console.log("Fetching sprints:", url);
        try {
          const resp = await fetch(url, { credentials: "include" });
          if (!resp.ok) {
            const text = await resp.text();
            console.error("API Error Response:", resp.status, text);
            alert("API returned an error. See console for details.");
            hideLoading();
            return;
          }
          const data = await resp.json();
          if (data.values && data.values.length) {
            allSprintsArr = allSprintsArr.concat(data.values);
            total = data.total;
            startAt += data.values.length; // advance by number returned
            if (data.isLast || allSprintsArr.length >= total) break;
          } else {
            break;
          }
        } catch (e) {
          console.error(e);
          alert("Failed to fetch sprints. CORS? Are you logged into Jira?");
          hideLoading();
          return;
        }
      }

      // Log all fetched sprints
      console.log("Fetched sprints:", allSprintsArr.length, allSprintsArr.map(s => s.name + ' (' + (s.startDate ? s.startDate.substr(0,10) : "undefined") + ')'));

      sprints = allSprintsArr.slice(); // keep original order; dropdown reverses
      closedSprintsSorted = sprints.filter(s => s.state === "closed" && s.endDate)
                                   .sort((a, b) => new Date(b.endDate) - new Date(a.endDate));
      populateSprintDropdown();
      hideLoading();
    }

    // --- SPRINT DROPDOWN: show all sprints in reverse order ---
    function populateSprintDropdown() {
      const sel = document.getElementById('sprintSelect');
      sel.innerHTML = '';
      for (let i = sprints.length - 1; i >= 0; i--) {
        const sprint = sprints[i];
        const opt = document.createElement('option');
        opt.value = sprint.id;
        let name = sprint.name || "(no name)";
        if (sprint.startDate) name += " (" + sprint.startDate.substr(0, 10) + ")";
        opt.textContent = (sprint.state === "active" ? "🟢 " : "") + name;
        sel.appendChild(opt);
      }
      document.getElementById('sprintRow').style.display = '';
    }

    function getStoryRowClass(story, currSprintObj) {
      const created = new Date(story.created);
      const resolved = story.resolved ? new Date(story.resolved) : null;
      const sprintStart = currSprintObj && currSprintObj.startDate ? new Date(currSprintObj.startDate) : null;
      const sprintEnd = currSprintObj && currSprintObj.endDate ? new Date(currSprintObj.endDate) : null;
      if (sprintStart && sprintEnd && created >= sprintStart && created < sprintEnd) {
        return "story-status-new";
      }
      if (sprintStart && sprintEnd && resolved && resolved >= sprintStart && resolved < sprintEnd) {
        return "story-status-current";
      }
      if (resolved && sprintStart && resolved < sprintStart) {
        return "story-status-previous";
      }
      if (!resolved || !story.status || !(story.status.toLowerCase().includes("done") || story.status.toLowerCase().includes("closed"))) {
        const st = (story.status||'').toLowerCase();
        if (st.includes('block')) return 'story-status-blocked';
        if (st.includes('progress') || st.includes('development')) return 'story-status-inprogress';
        return 'story-status-open';
      }
      return 'story-status-open';
   }

    // --- MAIN DATA FETCH (Epics/Stories/Velocity) ---
    async function fetchAll() {
      selectedSprintId = document.getElementById('sprintSelect').value;
      selectedSprintName = document.getElementById('sprintSelect').selectedOptions[0].textContent;
      if (!selectedSprintId) return alert("Select a sprint.");
      showLoading('Loading sprint data...');
      if (!boardTeams.length) await fetchBoardTeam();
      let currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
      let currIdx = closedSprintsSorted.findIndex(s => String(s.id) === String(selectedSprintId));
      let baselineSprint = null;
      if (currIdx >= 0) {
        if (currIdx + 1 < closedSprintsSorted.length) {
          baselineSprint = closedSprintsSorted[currIdx + 1];
        }
      } else if (closedSprintsSorted.length) {
        baselineSprint = closedSprintsSorted[0];
      }
      baselineSprintId = baselineSprint ? baselineSprint.id : '';
      const sprintFields = [
        'summary',
        'parent',
        'customfield_10002',
        'customfield_10005',
        'customfield_12600',
        'status',
        'issuetype'
      ];
      const epicKeysSet = new Set();
      try {
        const { issues } = await jiraSearch(`sprint = ${selectedSprintId} ORDER BY key`, sprintFields);
        (issues || []).forEach(issue => {
          if (issue.fields && issue.fields.issuetype && issue.fields.issuetype.name === 'Epic') return;
          const parent = issue.fields && issue.fields.parent;
          if (parent && parent.fields && parent.fields.issuetype && parent.fields.issuetype.name === 'Epic') {
            epicKeysSet.add(parent.key);
            allEpics[parent.key] = parent.fields.summary;
          }
        });
      } catch (e) {
        console.error('Error fetching stories for selected sprint', e);
        alert('Error fetching stories for selected sprint. See console for details.');
        hideLoading();
        return;
      }
      const epicFields = [
        'summary',
        'status',
        'resolution',
        'assignee',
        'customfield_10002',
        'customfield_12600',
        'created',
        'resolutiondate',
        'issuetype',
        'customfield_10005'
      ];
      epicStories = {};
      await Promise.all(Array.from(epicKeysSet).map(async epicKey => {
        try {
          const { issues } = await jiraSearch(`"Epic Link" = ${epicKey}`, epicFields);
          epicStories[epicKey] = deduplicateStoriesByKey((issues || []).map(story => ({
            key: story.key,
            summary: story.fields.summary,
            status: story.fields.status && story.fields.status.name,
            resolution: story.fields.resolution && story.fields.resolution.name,
            assignee: story.fields.assignee && story.fields.assignee.displayName,
            points: Number(story.fields.customfield_10002) || 0,
            team: (story.fields.customfield_12600 || []).join(', '),
            created: story.fields.created,
            resolved: story.fields.resolutiondate,
            sprint: (story.fields.customfield_10005||[]).map(s=>s.name).join(', '),
            issuetype: story.fields.issuetype && story.fields.issuetype.name,
          })));
        } catch (e) {
          console.error(`Failed to fetch stories for epic ${epicKey}`, e);
          epicStories[epicKey] = [];
        }
      }));
      epicStoriesBaseline = {};
      await Promise.all(Array.from(epicKeysSet).map(async epicKey => {
        try {
          const { issues } = await jiraSearch(`"Epic Link" = ${epicKey}`, epicFields);
          epicStoriesBaseline[epicKey] = deduplicateStoriesByKey((issues || [])
            .filter(story => {
              let created = new Date(story.fields.created);
              let resolved = story.fields.resolutiondate ? new Date(story.fields.resolutiondate) : null;
              let baseSprint = closedSprintsSorted.find(s=>s.id==baselineSprintId);
              let end = baseSprint ? new Date(baseSprint.endDate) : null;
              return created <= end && (!resolved || resolved > end);
            }).map(story => ({
            key: story.key,
            summary: story.fields.summary,
            status: story.fields.status && story.fields.status.name,
            resolution: story.fields.resolution && story.fields.resolution.name,
            assignee: story.fields.assignee && story.fields.assignee.displayName,
            points: Number(story.fields.customfield_10002) || 0,
            team: (story.fields.customfield_12600 || []).join(', '),
            created: story.fields.created,
            resolved: story.fields.resolutiondate,
            sprint: (story.fields.customfield_10005||[]).map(s=>s.name).join(', '),
            issuetype: story.fields.issuetype && story.fields.issuetype.name,
          })));
        } catch (e) {
          console.error(`Failed to fetch baseline stories for epic ${epicKey}`, e);
          epicStoriesBaseline[epicKey] = [];
        }
      }));
      let allTeams = new Set();
      Object.values(epicStories).forEach(arr => {
        arr.forEach(st => {
          getStoryTeams(st).forEach(t => { if (t) allTeams.add(t); });
        });
      });
      teamFilters = {};
      allTeams.forEach(t => { teamFilters[t] = false; });
      // --- FETCH HISTORICAL VELOCITY FROM JIRA REPORT ---
      velocityArr = await fetchVelocityFromReport(jiraDomain, boardNum);
      document.getElementById('configSection').style.display = '';
      renderVelocityInputs();
      renderEpicSummary();
      hideLoading();
    }

    // --- VELOCITY INPUTS ---
    function renderVelocityInputs() {
      let vhtml = velocityArr.map((v, i) =>
        `<input class="editarr" type="number" min="0" value="${v}" onchange="editVelocity(this,${i})">`).join(', ');
      document.getElementById('velocityWrap').innerHTML = vhtml;
    }
    function editVelocity(inp, idx) { velocityArr[idx] = Number(inp.value) || 0; }

    function updateHistoricTotals() {
      const entry = {
        sprint: selectedSprintName || ('#'+selectedSprintId),
        date: new Date().toISOString().substr(0,10),
        epicBacklogs: Object.assign({}, epicBacklogs),
        backlog: Object.values(epicBacklogs).reduce((a,b)=>a+b,0)
      };
      historicData.push(entry);
      if (historicData.length>12) historicData.shift();
      saveHistoricData();
    }


    function renderFilterOptions() {
      if (statusChoices) { statusChoices.destroy(); statusChoices = null; }
      if (teamChoices) { teamChoices.destroy(); teamChoices = null; }

      const statusOpts = [
        ['current','Done this sprint'],
        ['previous','Done before'],
        ['new','New story'],
        ['open','Open/In Progress'],
        ['removed','Removed']
      ];

      const statusSelectHtml =
        '<select id="statusSelect" multiple>'+
        statusOpts.map(o=>`<option value="${o[0]}" ${storyFilters[o[0]]?'selected':''}>${o[1]}</option>`).join('')+
        '</select>';

      const teamSelectHtml =
        '<select id="teamSelect" multiple>'+
        Object.keys(teamFilters)
          .sort()
          .map(team => {
            const option = escapeHtml(team);
            const selected = teamFilters[team] ? ' selected' : '';
            return `<option value="${option}"${selected}>${option}</option>`;
          })
          .join('')+
        '</select>';

      document.getElementById('filterOptions').innerHTML =
        '<span class="section-title" style="display:block;margin-top:0;">Story Map Filters:<span class="info-icon" data-tip="Toggle visibility of stories by status in the story map.">&#9432;<span class="tooltip"></span></span></span>'+
        statusSelectHtml+
        (Object.keys(teamFilters).length ? '<br><span class="section-title" style="display:block;margin-top:0.8em;">Team Filter:<span class="info-icon" data-tip="Filter stories shown by their assigned teams.">&#9432;<span class="tooltip"></span></span></span>'+teamSelectHtml : '');

      const statusEl = document.getElementById('statusSelect');
      const teamEl = document.getElementById('teamSelect');

      statusChoices = new Choices(statusEl, { removeItemButton:true, shouldSort:false });
      if (teamEl) teamChoices = new Choices(teamEl, { removeItemButton:true, searchResultLimit:15, shouldSort:true });

      statusEl.addEventListener('change', ()=>{
        const sel = new Set(statusChoices.getValue(true));
        statusOpts.forEach(o=>{ storyFilters[o[0]] = sel.has(o[0]); });
        applyStoryFilters();
      });

      if (teamEl) teamEl.addEventListener('change', ()=>{
        const sel = new Set(teamChoices.getValue(true));
        Object.keys(teamFilters).forEach(t=>{ teamFilters[t] = sel.has(t); });
        renderEpicSummary(true);
      });
    }

      function applyStoryFilters() {
        document.querySelectorAll('.story-status-current').forEach(el=>el.style.display = storyFilters.current? '':'none');
        document.querySelectorAll('.story-status-previous').forEach(el=>el.style.display = storyFilters.previous? '':'none');
        document.querySelectorAll('.story-status-new').forEach(el=>el.style.display = storyFilters.new? '':'none');
        document.querySelectorAll('.story-status-open').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-inprogress').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-blocked').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.story-status-other').forEach(el=>el.style.display = storyFilters.open? '':'none');
        document.querySelectorAll('.removed-lane').forEach(el=>el.style.display = storyFilters.removed? '':'none');
        document.querySelectorAll('.story-card').forEach(el=>{
          if (el.style.display==='none') return;
          const teams = parseTeamString(el.dataset.teams || '');
          if (!matchesTeamFilters(teams)) el.style.display='none';
        });
        updateEpicStatusCounts();
      }

      function updateEpicStatusCounts() {
        const currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
        Object.keys(epicStories).forEach(epicKey => {
          let done=0, prog=0, open=0, blocked=0;
          let ptsDone=0, ptsProg=0, ptsOpen=0, ptsBlocked=0;
          (epicStories[epicKey]||[]).forEach(story => {
            let show=true;
            let cls = getStoryRowClass(story, currSprintObj);
            if (cls==='story-status-current' && !storyFilters.current) show=false;
            else if (cls==='story-status-previous' && !storyFilters.previous) show=false;
            else if (cls==='story-status-new' && !storyFilters.new) show=false;
            else if ((cls==='story-status-open' || cls==='story-status-inprogress' || cls==='story-status-blocked' || cls==='story-status-other') && !storyFilters.open) show=false;
            if (show && !storyMatchesTeamFilters(story)) show=false;
            if (!show) return;
            let grp=statusGroup(story.status);
            if (grp==='Done') { done++; ptsDone+=story.points; }
            else if (grp==='In Progress') { prog++; ptsProg+=story.points; }
            else if (grp==='Open') { open++; ptsOpen+=story.points; }
            else if (grp==='Blocked') { blocked++; ptsBlocked+=story.points; }
            
          });
          const block=document.getElementById(`storyMap_${epicKey.replace(/[^a-zA-Z0-9]/g,'')}`);
          if (!block) return;
          const container=block.closest('.epic-summary-block');
          if (!container) return;
          const doneSpan=container.querySelector('.pill-done');
          const progSpan=container.querySelector('.pill-prog');
          const blockedSpan=container.querySelector('.pill-blocked');
          const openSpan=container.querySelector('.pill-open');
          if (doneSpan) doneSpan.textContent=`${done} Done (${ptsDone} SP)`;
          if (progSpan) progSpan.textContent=`${prog} In Progress (${ptsProg} SP)`;
          if (blockedSpan) blockedSpan.textContent=`${blocked} Blocked (${ptsBlocked} SP)`;
          if (openSpan) openSpan.textContent=`${open} Open (${ptsOpen} SP)`;
        });
      }

    function scopeIncreaseConsistent(epicKey) {
      if (historicData.length < 3) return false;
      const recs = historicData.slice(-3);
      const b1 = recs[0].epicBacklogs[epicKey] || 0;
      const b2 = recs[1].epicBacklogs[epicKey] || 0;
      const b3 = recs[2].epicBacklogs[epicKey] || 0;
      return (b2 > b1 && b3 > b2);
    }

    // --- MAIN REPORT RENDER ---
    function renderEpicSummary(skipHistory = false) {
      targetSprints = Number(document.getElementById('targetSprintsInput').value) || 4;
      let velocity = velocityArr.filter(v=>v>0);
      if (velocity.length<3) {
        document.getElementById('epicSummary').innerHTML = '<div class="warn">Please set at least 3 recent velocity values.</div>';
        return;
      }
      avgVelocity = velocity.reduce((a,b)=>a+b,0)/velocity.length;
      const baselineSprintObj = closedSprintsSorted.find(s=>s.id==baselineSprintId);
      const baselineEnd = baselineSprintObj ? new Date(baselineSprintObj.endDate) : null;
      epicBacklogs = {};
      let totalBacklog = 0;
      Object.keys(epicStories).forEach(epicKey => {
        let stories = epicStories[epicKey]||[];
        let backlog = stories.filter(st => {
          if (isDone(st.status)) return false;
          if (!storyMatchesTeamFilters(st)) return false;
          return true;
        }).reduce((a,b)=>a+b.points,0);
        epicBacklogs[epicKey] = backlog;
        totalBacklog += backlog;
      });
      epicAllocations = {};
      Object.keys(epicStories).forEach(epicKey => {
        epicAllocations[epicKey] = totalBacklog ? Math.ceil(100*epicBacklogs[epicKey]/totalBacklog) : 0;
      });
      if (!skipHistory) updateHistoricTotals();
      renderFilterOptions();
      applyStoryFilters();
      epicForecastResults = {};
      epicRequiredAlloc = {};
      epicRequiredSP = {};
      epicRequiredSPPrev = {};
      Object.keys(epicStories).forEach(epicKey => {
        let stories = epicStories[epicKey]||[];
        let backlogPts = epicBacklogs[epicKey];
        if (backlogPts <= 0) {
          epicForecastResults[epicKey] = [0];
          epicRequiredAlloc[epicKey] = { "75": 0, "95": 0 };
          epicRequiredSP[epicKey] = { "75": 0, "95": 0 };
          return;
        }
        let alloc = epicAllocations[epicKey];
        let allocVels = velocity.map(v=>v*alloc/100);
        let mcRuns = [];
        for (let i=0; i<10000; i++) {
          let b = backlogPts, s=0;
          while (b>0 && s<100) {
            let v = allocVels[Math.floor(Math.random()*allocVels.length)];
            if (v<1) v=1;
            b -= v; s++;
          }
          mcRuns.push(s);
        }
        mcRuns.sort((a,b)=>a-b);
        epicForecastResults[epicKey] = mcRuns;
        let allocNeeded = { "75": null, "95": null };
        for (let pct=1;pct<=100;pct++) {
          let testVels = velocity.map(v=>v*pct/100);
          let runs = [];
          for (let i=0;i<5000;i++) {
            let b = backlogPts, s=0;
            while (b>0 && s<100) {
              let v = testVels[Math.floor(Math.random()*testVels.length)];
              if (v<1) v=1;
              b -= v; s++;
            }
            runs.push(s);
          }
          runs.sort((a,b)=>a-b);
          if (allocNeeded["75"] === null && runs[Math.floor(0.75*runs.length)]<=targetSprints) allocNeeded["75"] = pct;
          if (allocNeeded["95"] === null && runs[Math.floor(0.95*runs.length)]<=targetSprints) allocNeeded["95"] = pct;
          if (allocNeeded["75"] && allocNeeded["95"]) break;
        }
        epicRequiredAlloc[epicKey] = allocNeeded;
        epicRequiredSP[epicKey] = {
          "75": allocNeeded["75"] ? Math.ceil(avgVelocity * allocNeeded["75"] / 100) : null,
          "95": allocNeeded["95"] ? Math.ceil(avgVelocity * allocNeeded["95"] / 100) : null
        };
    });

      Object.keys(epicStoriesBaseline).forEach(epicKey => {
        let stories = epicStoriesBaseline[epicKey] || [];
        let backlogPts = stories.filter(st => {
          if (!storyMatchesTeamFilters(st)) return false;
          let res = st.resolved ? new Date(st.resolved) : null;
          if (baselineEnd && res && res <= baselineEnd) return false;
          return true;
        }).reduce((a,b)=>a+b.points,0);
        if (backlogPts <= 0) {
          epicRequiredSPPrev[epicKey] = { "75": 0, "95": 0 };
          return;
        }
        let allocNeeded = { "75": null, "95": null };
        for (let pct=1;pct<=100;pct++) {
          let testVels = velocity.map(v=>v*pct/100);
          let runs = [];
          for (let i=0;i<5000;i++) {
            let b = backlogPts, s=0;
            while (b>0 && s<100) {
              let v = testVels[Math.floor(Math.random()*testVels.length)];
              if (v<1) v=1;
              b -= v; s++;
            }
            runs.push(s);
          }
          runs.sort((a,b)=>a-b);
          if (allocNeeded["75"] === null && runs[Math.floor(0.75*runs.length)]<=targetSprints) allocNeeded["75"] = pct;
          if (allocNeeded["95"] === null && runs[Math.floor(0.95*runs.length)]<=targetSprints) allocNeeded["95"] = pct;
          if (allocNeeded["75"] && allocNeeded["95"]) break;
        }
        epicRequiredSPPrev[epicKey] = {
          "75": allocNeeded["75"] ? Math.ceil(avgVelocity * allocNeeded["75"] / 100) : null,
          "95": allocNeeded["95"] ? Math.ceil(avgVelocity * allocNeeded["95"] / 100) : null
        };
      });

      let totalAlloc = Object.values(epicAllocations).reduce((a,b)=>a+b,0);
      let allocWarn = '';
      if (totalAlloc < 99) allocWarn = `<span class="warn">Warning: Not all team capacity is assigned to listed epics (${totalAlloc}% total).</span>`;
      else if (totalAlloc > 101) allocWarn = `<span class="warn">Warning: Allocations exceed 100% of capacity! (${totalAlloc}%)</span>`;
      else allocWarn = `<span class="success">Team allocation: ${totalAlloc}%</span>`;

      let totalReq75 = 0, totalReq95 = 0;
      Object.values(epicRequiredAlloc).forEach(r => {
        totalReq75 += r["75"] != null ? r["75"] : 101;
        totalReq95 += r["95"] != null ? r["95"] : 101;
      });
      totalReq75 = Math.ceil(totalReq75);
      totalReq95 = Math.ceil(totalReq95);
      let reqWarn = (totalReq75 > 100 || totalReq95 > 100)
        ? `<span class="warn">Required allocations exceed team capacity. Not all epics likely to finish.</span>`
        : `<span class="success">Required allocations within team capacity.</span>`;
      document.getElementById('requiredSummary').innerHTML =
        `<div><b>Sum of required allocation to finish in ${targetSprints} sprints:</b><span class="info-icon" data-tip="Combined team capacity needed across all epics to meet the target sprint goal.">&#9432;<span class="tooltip"></span></span> `+
        `${totalReq75}% at 75% confidence &nbsp; | &nbsp; ${totalReq95}% at 95% confidence`+
        `<br>${reqWarn}</div>`;
      // The total allocation info is still calculated for simulations but no longer displayed in the UI
      let html = '';

      Object.keys(epicStories).forEach((epicKey, idx) => {
        let stories = epicStories[epicKey];
        if (!stories || !stories.length) return;
        let statusCounts = {done:0,prog:0,open:0,blocked:0};
        let ptsDone=0, ptsProg=0, ptsOpen=0, ptsBlocked=0;
        let unestimated = 0;
        stories.forEach(story => {
          if (!storyMatchesTeamFilters(story)) return;
          let sgrp = statusGroup(story.status);
          if (sgrp==='Done') { statusCounts.done++; ptsDone+=story.points; }
          else if (sgrp==='In Progress') { statusCounts.prog++; ptsProg+=story.points; }
          else if (sgrp==='Open') { statusCounts.open++; ptsOpen+=story.points; }
          else if (sgrp==='Blocked') { statusCounts.blocked++; ptsBlocked+=story.points; }
          
          if (!story.points && sgrp!=='Done') unestimated++;
        });
        let totalEstimate = ptsDone+ptsProg+ptsOpen+ptsBlocked;
        let backlog = ptsProg+ptsOpen+ptsBlocked;
        let alloc = epicAllocations[epicKey];
        let required = epicRequiredAlloc[epicKey];
        let mc = epicForecastResults[epicKey];
        let probRows = [[50,mc[Math.floor(0.5*mc.length)]],[75,mc[Math.floor(0.75*mc.length)]],[95,mc[Math.floor(0.95*mc.length)]]];

        let baseStories = (epicStoriesBaseline[epicKey]||[]).filter(st => storyMatchesTeamFilters(st));
        let baseKeys = new Set(baseStories.map(s=>s.key));
        let currStories = stories.filter(s => storyMatchesTeamFilters(s));
        let currKeys = new Set(currStories.map(s=>s.key));
        const currSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
        const sprintStart = currSprintObj && currSprintObj.startDate ? new Date(currSprintObj.startDate) : null;
        const sprintEnd = currSprintObj && currSprintObj.endDate ? new Date(currSprintObj.endDate) : null;
        let newStories = currStories.filter(s => {
          if (!s.created) return false;
          const created = new Date(s.created);
          return sprintStart && sprintEnd && created >= sprintStart && created < sprintEnd;
        });
        let removedStories = baseStories.filter(s=>!currKeys.has(s.key));

        let baseDone = (epicStories[epicKey]||[]).filter(s=>{
          if (!storyMatchesTeamFilters(s)) return false;
          let res = s.resolved ? new Date(s.resolved) : null;
          return baselineEnd && res && res <= baselineEnd;
        }).map(s=>s.points).reduce((a,b)=>a+b,0);
        let doneSince = ptsDone - baseDone;
        let estimateBaseline = baseStories.map(s=>s.points).reduce((a,b)=>a+b,0);

        let deltaEstimate = backlog - estimateBaseline;
        const storyMapId = `storyMap_${epicKey.replace(/[^a-zA-Z0-9]/g, '')}`;
        const risk = ((required["75"] && required["75"]-alloc>15) || scopeIncreaseConsistent(epicKey));
        html += `
        <div class="epic-summary-block ${risk?'epic-risk':''}">
          <div class="epic-header">${epicKey}: ${allEpics[epicKey]||''}</div>
          <div style="margin-top:4px;margin-bottom:10px;">
            <span class="status-pill pill-done">${statusCounts.done} Done (${ptsDone} SP)</span>
            <span class="status-pill pill-prog">${statusCounts.prog} In Progress (${ptsProg} SP)</span>
            <span class="status-pill pill-blocked">${statusCounts.blocked} Blocked (${ptsBlocked} SP)</span>
            <span class="status-pill pill-open">${statusCounts.open} Open (${ptsOpen} SP)</span><br>
            <b>Total:</b> ${totalEstimate} SP &nbsp; | &nbsp; <b>Backlog:</b> ${backlog} SP &nbsp; | &nbsp; <b>Unestimated:</b> ${unestimated}
          </div>
          <div class="info-grid">
            <div>
              <div style="margin-bottom:4px;">
                <b>Team allocation for this epic:</b><span class="info-icon" data-tip="Percentage of team capacity dedicated to this epic.">&#9432;<span class="tooltip"></span></span>
                <span style="font-size:1.1em;font-weight:600;">${alloc}%</span>
                <div class="allocation-bar" style="width:${2*alloc}px"></div>
              </div>
              <div>
                <table class="prob-table">
                  <tr><th>Confidence</th><th>Sprints Needed</th></tr>
                  ${probRows.map(r=>`<tr><td>${r[0]}%</td><td>${r[1]}</td></tr>`).join('')}
                </table>
              </div>
              <div style="margin-bottom:8px;">
                <b>Required allocation${unestimated>0?'+':''} to finish in ${targetSprints} sprints:</b>
                <ul style="margin:3px 0 0 0;padding-left:1.3em;">
                  ${(() => {
                    const fmt = pct => {
                      const sp = epicRequiredSP[epicKey][pct];
                      if (sp != null) {
                        const plus = unestimated>0?'+':'';
                        return `${sp}${plus} SP/sprint (${required[pct]}${plus}%)`;
                      }
                      return '<span class="warn">Over 100%</span>';
                    };
                    const prev = pct => {
                      const sp = (epicRequiredSPPrev[epicKey]||{})[pct];
                      return sp != null ? `${sp} SP` : 'n/a';
                    };
                    return [
                      `<li>75% confidence: ${fmt("75")} <span style="font-size:0.9em;color:#555;">(last sprint: ${prev("75")})</span><span class="info-icon" data-tip="Estimated capacity per sprint for a 75% chance of finishing on time. Calculated using Monte Carlo simulations.">&#9432;<span class="tooltip"></span></span></li>`,
                      `<li>95% confidence: ${fmt("95")} <span style="font-size:0.9em;color:#555;">(last sprint: ${prev("95")})</span><span class="info-icon" data-tip="Capacity needed for a 95% likelihood of completion within the target sprints. Based on Monte Carlo results.">&#9432;<span class="tooltip"></span></span></li>`
                    ].join('');
                  })()}
                </ul>
              </div>
              <div style="font-size:0.99em;">
                ${probRows[1][1] > targetSprints ?
                  `<span class="warn">At 75% confidence, this epic is <b>not likely</b> to finish in ${targetSprints} sprints.<br>
                  More allocation or velocity needed.</span>`
                  :
                  `<span class="success">On track to finish in ${targetSprints} sprints at 75% confidence.</span>`
                }
              </div>
            </div>
            <div>
                <div class="pdf-section-title" style="margin-top:0;">Changes since last sprint:<span class="info-icon" data-tip="Summary of completed, new and removed stories plus overall scope change since the previous sprint.">&#9432;<span class="tooltip"></span></span></div>
              <div class="change-block">
                <ul>
                  <li>Story points completed: <b>${doneSince}</b></li>
                  <li>New stories: <b>${newStories.length}</b> (${newStories.reduce((a,b)=>a+b.points,0)} SP)</li>
                  <li>Removed stories: <b>${removedStories.length}</b> (${removedStories.reduce((a,b)=>a+b.points,0)} SP)</li>
                  <li>
                    Scope change: ${
                      deltaEstimate===0 ? "No change"
                      : (deltaEstimate>0?'<span class="warn">Increased (+'
                        +deltaEstimate+')</span>':'<span class="success">Reduced ('+deltaEstimate+')</span>')
                    }
                    
                  </li>
                </ul>
              </div>
            </div>
          </div>
          <label class="epic-select-label"><input type="checkbox" class="epic-select-checkbox" data-epic="${epicKey}" checked> Include in PDF</label>
          <button class="btn details-toggle" onclick="toggleEpicDetails(this, '${storyMapId}')">Show Details</button>
          <div id="${storyMapId}" style="display:none; margin-top:10px;">
            <div class="story-map">
              ${(() => {
                const newSet = new Set(newStories.map(s=>s.key));
                const lanes = [
                  ['Done', currStories.filter(s=>statusGroup(s.status)==='Done')],
                  ['In Progress', currStories.filter(s=>statusGroup(s.status)==='In Progress')],
                  ['Open', currStories.filter(s=>statusGroup(s.status)==='Open')],
                  ['Blocked', currStories.filter(s=>statusGroup(s.status)==='Blocked')]
                ];
                return lanes.map(l => `
                  <div class="story-lane">
                    <div class="story-lane-header">${l[0]}</div>
                    ${l[1].map(st => {
                      const c = getStoryRowClass(st, currSprintObj);
                      const tags = [];
                      if (newSet.has(st.key)) tags.push('New');
                      if (c==='story-status-current') tags.push('Done now');
                      if (st.issuetype) tags.push(st.issuetype);
                      const safeTeams = escapeHtml(st.team || '');
                      const safeKey = escapeHtml(st.key);
                      const safeSummary = escapeHtml(st.summary);
                      const safeStatus = escapeHtml(st.status);
                      const safeAssignee = escapeHtml(st.assignee);
                      const safeCreated = escapeHtml(st.created ? st.created.substr(0,10) : '');
                      const safeResolved = escapeHtml(st.resolved ? st.resolved.substr(0,10) : '');
                      return `<div class="story-card ${c}" data-teams="${safeTeams}">
                        <div><b>${safeKey}</b> (${st.points} SP)</div>
                        <div>${safeSummary}</div>
                        <div class="small">${safeStatus}${st.assignee? ' - '+safeAssignee : (st.team?' - '+safeTeams:'')}</div>
                        <div class="small">${safeCreated}${st.resolved?' → '+safeResolved:''}</div>
                        ${tags.length?`<div class="tags">${tags.map(t=>`<span class="story-tag">${escapeHtml(t)}</span>`).join('')}</div>`:''}
                      </div>`;
                    }).join('')}
                  </div>
                `).join('');
              })()}
              ${removedStories.length?`
                <div class="story-lane removed-lane">
                  <div class="story-lane-header">Removed since last sprint</div>
                  ${removedStories.map(st=>{
                    const safeTeams = escapeHtml(st.team || '');
                    const safeKey = escapeHtml(st.key);
                    const safeResolution = escapeHtml(st.resolution);
                    const safeIssueType = escapeHtml(st.issuetype);
                    return `<div class="story-card story-status-other" data-teams="${safeTeams}"><b>${safeKey}</b> (${st.points} SP)${st.resolution?` - ${safeResolution}`:''}${st.issuetype?`<div class="tags"><span class="story-tag">${safeIssueType}</span></div>`:''}</div>`;
                  }).join('')}
                </div>
              `:''}
            </div>
            <div class="story-map-legend" style="font-size:0.95em;margin-top:8px;">
              <span class="story-status-current">Done this sprint</span>
              <span class="story-status-new">New story</span>
              <span class="removed-lane">Removed since last sprint</span>
            </div>
          </div>
        </div>
        `;
      });
      document.getElementById('epicSummary').innerHTML = html;
      applyStoryFilters();
      addTooltipListeners();
    }

    function toggleEpicDetails(btn, id) {
      const block = document.getElementById(id);
      if (block.style.display === "none") {
        block.style.display = "";
        btn.textContent = "Hide Details";
      } else {
        block.style.display = "none";
        btn.textContent = "Show Details";
      }
    }

    function isDone(status) {
      status = (status||'').toLowerCase();
      return status.includes("done") || status.includes("closed");
    }
    function statusGroup(s) {
      s = (s||"").toLowerCase();
      if (s.includes("done") || s.includes("closed")) return "Done";
      if (s.includes("block")) return "Blocked";
      if (s.includes("progress") || s.includes("development")) return "In Progress";
      return "Open";
    }

    function hexToRgb(hex) {
      const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      return m ? {
        r: parseInt(m[1], 16),
        g: parseInt(m[2], 16),
        b: parseInt(m[3], 16)
      } : {r:0,g:0,b:0};
    }

    // --- PDF EXPORT (CLEAN SUMMARY ONLY) ---
    async function exportPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit:'pt', format:'a4' });
      const blocks = Array.from(document.querySelectorAll('.epic-summary-block'))
        .filter(b => b.querySelector('.epic-select-checkbox')?.checked);
      if (!blocks.length) return alert('Select at least one epic for PDF');
      const margin = 20;
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const maxWidth = pageWidth - margin * 2;
      const maxHeight = pageHeight - margin * 2;
      for (let i=0; i<blocks.length; i++) {
        const dataUrl = await htmlToImage.toJpeg(blocks[i], {
          quality: 0.85,
          backgroundColor: '#ffffff',
          pixelRatio: 2,
          skipFonts: true,
          cacheBust: true
        });
        const props = pdf.getImageProperties(dataUrl);
        const ratio = Math.min(maxWidth / props.width, maxHeight / props.height, 1);
        const renderWidth = props.width * ratio;
        const renderHeight = props.height * ratio;
        if (i>0) pdf.addPage();
        pdf.addImage(
          dataUrl,
          'JPEG',
          margin + (maxWidth - renderWidth) / 2,
          margin,
          renderWidth,
          renderHeight,
          undefined,
          'FAST'
        );
      }
      const dateStr = new Date().toISOString().split('T')[0];
      pdf.save(`Stakeholder_StatusReport_Velocity_${dateStr}.pdf`);
    }
  </script>
</body>
</html>
