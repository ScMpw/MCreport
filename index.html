<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stakeholder Report (Jira + MCW, MCW-style Visualisation)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 30px; background: #f9f9f9; }
    h1 { font-size: 1.6em; }
    .btn { background: #6366f1; color: #fff; border: none; border-radius: 6px; padding: 7px 15px; cursor: pointer; margin-right: 8px;}
    .btn:disabled { background: #aaa; }
    .section-title { font-size: 1.2em; margin-bottom: .2em; }
    .storymap-epic { background: #fff; border-radius: 10px; box-shadow: 0 0 4px #ddd; padding: 1em; min-width: 180px;}
    .story-badge { display: block; border-radius: 6px; padding: 2px 6px; margin: 2px 0; }
    .story-done { background: #bbf7d0; }
    .story-indev { background: #fde68a; }
    .story-open { background: #f1f5f9; }
    .summary-box { background: #fff; border-radius: 12px; box-shadow: 0 0 8px #eee; padding: 1em; margin-bottom: 2em;}
    .risk-high { color: #e11d48; font-weight: bold; }
    .risk-low { color: #10b981; font-weight: bold; }
    .targetSprintBox { margin: 1em 0 1em 0; }
    .targetSprintBox label { margin-right: .5em; }
    table { border-collapse: collapse; background: #fff; }
    th, td { border: 1px solid #ccc; padding: 6px 10px; }
    th { background: #f0f0f0; }
    .editarr { width: 60px; }
    @media print { .no-print { display: none !important; } }
  </style>
</head>
<body>
  <h1>Stakeholder Report Generator (Jira + MCW Probability Curve)</h1>
  <div class="input-row">
    <label>Jira Domain: <input id="jiraDomain" value="aldi-sued.atlassian.net" size="30"></label>
    <label>Board Number: <input id="boardNum" value="" size="6"></label>
    <button class="btn" onclick="fetchSprints()">Fetch Sprints</button>
    <span class="tip">Login to Jira, enable your CORS plugin if needed.</span>
  </div>
  <div class="input-row" id="sprintRow" style="display:none;">
    <label>Sprint:
      <select id="sprintSelect"></select>
    </label>
    <button class="btn" onclick="fetchIssues()">Fetch Issues</button>
  </div>

  <div id="importArea" style="display:none;">
    <div class="section-title">Velocity History (editable, last 6 closed sprints):</div>
    <div id="velocityWrap"></div>
    <div class="targetSprintBox">
      <label>Target sprints to finish (for forecast):</label>
      <input id="targetSprintsInput" type="number" min="1" max="20" value="4" style="width:60px">
      <button class="btn" onclick="runAllEpicSimulations()">Run Simulations</button>
      <button class="btn" onclick="exportPDF()">Download PDF Report</button>
    </div>
    <hr>
    <div class="section-title">Epic Story Maps & Monte Carlo Forecasts</div>
    <div id="epicSimResults"></div>
    <hr>
    <div class="section-title">Editable Story Table</div>
    <div id="storyTableWrap"></div>
  </div>

  <script>
    // Globals
    let jiraDomain = '', boardNum = '', sprints = [];
    let stories = [], epicStoryMap = {};
    let velocityArr = [];
    let selectedSprintId = '';
    let selectedSprintName = '';
    let editableData = [];
    let closedSprintsSorted = [];

    // ---- FETCH SPRINTS ----
    async function fetchSprints() {
      jiraDomain = document.getElementById('jiraDomain').value.trim();
      boardNum = document.getElementById('boardNum').value.trim();
      if (!jiraDomain || !boardNum) return alert("Enter Jira domain and board number.");
      const url = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/sprint?state=active,closed,future`;
      try {
        const resp = await fetch(url, { credentials: "include" });
        const data = await resp.json();
        if (data.values && data.values.length) {
          sprints = data.values;
          closedSprintsSorted = data.values
            .filter(s => s.state === "closed" && s.endDate)
            .sort((a,b) => new Date(a.endDate) - new Date(b.endDate));
          populateSprintDropdown();
        } else {
          alert("No sprints found for this board.");
        }
      } catch (e) {
        alert("Failed to fetch sprints. CORS? Are you logged into Jira?");
      }
    }
    function populateSprintDropdown() {
      const sel = document.getElementById('sprintSelect');
      sel.innerHTML = '';
      sprints.sort((a,b) => new Date(a.startDate||0) - new Date(b.startDate||0));
      sprints.forEach(sprint => {
        const opt = document.createElement('option');
        opt.value = sprint.id;
        opt.textContent = (sprint.state === "active" ? "ðŸŸ¢ " : "") + sprint.name;
        sel.appendChild(opt);
      });
      document.getElementById('sprintRow').style.display = '';
    }

    // ---- FETCH ISSUES ----
    async function fetchIssues() {
      selectedSprintId = document.getElementById('sprintSelect').value;
      selectedSprintName = document.getElementById('sprintSelect').selectedOptions[0].textContent;
      if (!selectedSprintId) return alert("Select a sprint.");

      let currentSprintObj = sprints.find(s => String(s.id) === String(selectedSprintId));
      let currEndDate = currentSprintObj && currentSprintObj.endDate ? new Date(currentSprintObj.endDate) : new Date();
      let velocityClosedSprints = closedSprintsSorted
        .filter(s => new Date(s.endDate) <= currEndDate)
        .slice(-6);

      let sprintIdsToFetch = velocityClosedSprints.map(s=>s.id);
      if (!sprintIdsToFetch.includes(Number(selectedSprintId))) {
        sprintIdsToFetch.push(Number(selectedSprintId));
      }

      let allIssues = [];
      for (let sid of sprintIdsToFetch) {
        const jql = encodeURIComponent(`sprint = ${sid} ORDER BY key`);
        const url = `https://${jiraDomain}/rest/api/3/search?jql=${jql}&fields=summary,status,parent,customfield_10002,customfield_12600,customfield_10005,issuetype&expand=parent.fields&maxResults=200`;
        try {
          const resp = await fetch(url, { credentials: "include" });
          const data = await resp.json();
          if (data.issues && data.issues.length) {
            allIssues.push({sprint: sid, issues: data.issues});
          }
        } catch (e) {
          alert("Failed to fetch issues for sprint " + sid);
        }
      }

      let velocityArrRaw = [];
      let epicMap = {};
      stories = [];
      for (let i = 0; i < velocityClosedSprints.length; i++) {
        let sid = velocityClosedSprints[i].id;
        let batch = allIssues.find(b => Number(b.sprint) === Number(sid));
        let pointsDone = 0;
        if (batch) {
          for (let issue of batch.issues) {
            let typeObj = issue.fields.issuetype;
            if (typeObj && (typeObj.subtask || typeObj.name === "Epic")) continue;
            let pts = Number(issue.fields.customfield_10002) || 1;
            let status = issue.fields.status && issue.fields.status.name;
            if (status && (status.toLowerCase().includes("done") || status.toLowerCase().includes("closed"))) pointsDone += pts;
          }
        }
        velocityArrRaw.push(pointsDone);
      }

      let selectedBatch = allIssues.find(b => Number(b.sprint) === Number(selectedSprintId));
      if (selectedBatch) {
        for (let issue of selectedBatch.issues) {
          let typeObj = issue.fields.issuetype;
          if (typeObj && (typeObj.subtask || typeObj.name === "Epic")) continue;
          let parent = issue.fields.parent;
          let isEpic = parent && parent.fields && parent.fields.issuetype && parent.fields.issuetype.name === "Epic";
          let epicKey = isEpic ? parent.key : "No Epic";
          let epicSummary = isEpic ? parent.fields.summary : "";
          let sprintsArr = issue.fields.customfield_10005 || [];
          let currentSprint = (sprintsArr.find(s => s.state === "active") || sprintsArr[sprintsArr.length-1] || {}).name || "None";
          let responsibleTeams = (issue.fields.customfield_12600 || []).join(', ');
          let status = issue.fields.status && issue.fields.status.name;
          let pts = Number(issue.fields.customfield_10002) || 1;
          if (!epicMap[epicKey]) epicMap[epicKey] = [];
          epicMap[epicKey].push({
            key: issue.key,
            summary: issue.fields.summary,
            status: status,
            epic: epicKey,
            epicSummary: epicSummary,
            team: responsibleTeams,
            sprint: currentSprint,
            points: pts
          });
          stories.push({
            key: issue.key,
            summary: issue.fields.summary,
            status: status,
            epic: epicKey,
            epicSummary: epicSummary,
            team: responsibleTeams,
            sprint: currentSprint,
            points: pts
          });
        }
      }
      epicStoryMap = epicMap;
      velocityArr = velocityArrRaw;
      editableData = stories.map(s => ({ ...s }));
      showImportArea();
    }

    function showImportArea() {
      let vhtml = velocityArr.map((v, i) =>
        `<input class="editarr" type="number" min="0" value="${v}" onchange="editVelocity(this,${i})">`).join(', ');
      document.getElementById('velocityWrap').innerHTML = vhtml;
      buildStoryTable();
      document.getElementById('importArea').style.display = '';
      document.getElementById('epicSimResults').innerHTML = '';
    }
    function editVelocity(inp, idx) {
      velocityArr[idx] = Number(inp.value) || 0;
    }

    function buildStoryMap(epicKey) {
      let byEpic = epicStoryMap[epicKey] || [];
      let html = `<div class="storymap-epic"><h4>${epicKey}</h4>`;
      for (let story of byEpic) {
        let c = story.status.toLowerCase().includes("done") || story.status.toLowerCase().includes("closed")
          ? "story-done"
          : story.status.toLowerCase().includes("progress") || story.status.toLowerCase().includes("development")
            ? "story-indev"
            : "story-open";
        html += `<span class="story-badge ${c}">${story.key}: ${story.summary}</span>`;
      }
      html += `</div>`;
      return html;
    }

    function buildStoryTable() {
      const container = document.getElementById('storyTableWrap');
      let html = `<table><thead>
        <tr><th>Epic</th><th>Story Key</th><th>Summary</th><th>Status</th><th>Team</th><th>Sprint</th><th>Points</th></tr>
        </thead><tbody>`;
      for (let i = 0; i < editableData.length; i++) {
        const s = editableData[i];
        html += `<tr>
          <td>${s.epic}</td>
          <td>${s.key}</td>
          <td>${s.summary}</td>
          <td>
            <select data-idx="${i}" onchange="editStatus(this)">
              <option${s.status.toLowerCase().includes('done')||s.status.toLowerCase().includes('closed')?' selected':''}>Done</option>
              <option${s.status.toLowerCase().includes('progress')||s.status.toLowerCase().includes('development')?' selected':''}>In Progress</option>
              <option${!(s.status.toLowerCase().includes('done')||s.status.toLowerCase().includes('closed')||s.status.toLowerCase().includes('progress')||s.status.toLowerCase().includes('development'))?' selected':''}>To Do</option>
            </select>
          </td>
          <td>${s.team}</td>
          <td>${s.sprint}</td>
          <td><input type="number" min="1" style="width:40px" value="${s.points}" data-idx="${i}" onchange="editPoints(this)"></td>
        </tr>`;
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }
    window.editStatus = function(sel) {
      const idx = sel.getAttribute('data-idx');
      editableData[idx].status = sel.value;
    }
    window.editPoints = function(input) {
      const idx = input.getAttribute('data-idx');
      editableData[idx].points = Number(input.value) || 1;
    }

    // ---- MCW SIMULATION with Probability Cone ----
    function runAllEpicSimulations() {
      let velocity = velocityArr.filter(v => v>0);
      const resultsArea = document.getElementById('epicSimResults');
      const targetSprints = Number(document.getElementById('targetSprintsInput').value) || 4;
      resultsArea.innerHTML = '';
      Object.keys(epicStoryMap).forEach((epicKey, epicIdx) => {
        const epicStories = epicStoryMap[epicKey];
        const notDone = epicStories.filter(s =>
          !(s.status.toLowerCase().includes("done") || s.status.toLowerCase().includes("closed"))
        );
        const backlog = notDone.reduce((sum, s) => sum + Number(s.points), 0);
        if (backlog === 0) return;

        // MCW: Run MC simulation
        const mcRuns = [];
        for (let i=0; i<10000; i++) {
          let b = backlog, s=0;
          while (b>0 && s<100) {
            let v = velocity[Math.floor(Math.random()*velocity.length)];
            if (v<1) v=1;
            b -= v; s++;
          }
          mcRuns.push(s);
        }
        mcRuns.sort((a,b)=>a-b);

        // Probability grid (MCW cone)
        const probGrid = [];
        for(let p=0;p<=100;p+=5) probGrid.push(p);
        const yValues = probGrid.map(pct => {
          const idx = Math.floor((pct/100)*(mcRuns.length-1));
          return mcRuns[idx];
        });

        // Table of percentiles (same grid as chart)
        let probTable = `<table><tr>${probGrid.map(x=>`<th>${x}%</th>`).join('')}</tr>
        <tr>${yValues.map(x=>`<td>${x}</td>`).join('')}</tr></table>`;

        const neededVelocity = Math.ceil(backlog / targetSprints);
        const percentile75 = mcRuns[Math.floor(0.75*mcRuns.length)];
        let html = `
          <div class="summary-box">
            <h3>Epic: ${epicKey} (${epicStories[0]?.epicSummary || ''})</h3>
            <b>Remaining stories:</b> ${notDone.length} | <b>Backlog (points):</b> ${backlog}<br>
            ${buildStoryMap(epicKey)}
            <ul>
              <li>Median (50% conf): ${mcRuns[Math.floor(0.5*mcRuns.length)]} sprints</li>
              <li>75% confidence: ${percentile75} sprints</li>
              <li>90% confidence: ${mcRuns[Math.floor(0.9*mcRuns.length)]} sprints</li>
              <li>95% confidence: ${mcRuns[Math.floor(0.95*mcRuns.length)]} sprints</li>
            </ul>
            <span class="${percentile75>targetSprints?'risk-high':'risk-low'}">
              ${
                percentile75<=targetSprints
                  ? `Good: Likely deliverable within <b>${targetSprints}</b> sprints.`
                  : `Warning: At 75% confidence, NOT likely deliverable in <b>${targetSprints}</b> sprints.<br>
                    <b>Required average velocity:</b> <u>${neededVelocity} points/sprint</u> to deliver in ${targetSprints} sprints.`
              }
            </span>
            <div style="width:100%; max-width:550px"><canvas id="mcChart${epicIdx}" height="170"></canvas></div>
            <div style="margin-top:1em;"><b>Probability Table:</b> ${probTable}</div>
          </div>
        `;
        resultsArea.innerHTML += html;
        setTimeout(()=>drawMCWCone(`mcChart${epicIdx}`, probGrid, yValues, epicKey),0);
      });
    }

    // MCW-style cumulative probability line chart
    function drawMCWCone(canvasId, probGrid, yValues, label) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: probGrid,
          datasets: [{ label, data: yValues, fill:false, borderColor: '#6366f1', tension:0.2 }]
        },
        options: {
          plugins: { legend: { display: false } },
          scales: {
            x: { title: { display: true, text: 'Probability (%)' }, min: 0, max: 100 },
            y: { title: { display: true, text: 'Sprints Needed' }, beginAtZero: true }
          }
        }
      });
    }

    // ---- PDF EXPORT ----
    async function exportPDF() {
      const area = document.getElementById('importArea');
      area.style.background = '#fff';
      window.scrollTo(0,0);
      const canvas = await html2canvas(area, {scale:2});
      const imgData = canvas.toDataURL('image/png');
      const pdf = new window.jspdf.jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: 'a4'
      });
      const pageWidth = pdf.internal.pageSize.getWidth();
      const imgWidth = pageWidth - 40;
      const ratio = imgWidth / canvas.width;
      const imgHeight = canvas.height * ratio;
      pdf.addImage(imgData, 'PNG', 20, 20, imgWidth, imgHeight);
      pdf.save(`Stakeholder_Report_${selectedSprintName||''}.pdf`);
    }
  </script>
</body>
</html>
