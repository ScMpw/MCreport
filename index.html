<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stakeholder Report (Jira + MCW, Per-Epic)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 30px; background: #f9f9f9; }
    h1 { font-size: 1.6em; }
    .input-row { margin-bottom: 1em; }
    table { border-collapse: collapse; background: #fff; }
    th, td { border: 1px solid #ccc; padding: 6px 10px; }
    th { background: #f0f0f0; }
    .storymap { display: flex; gap: 30px; margin-bottom: 2em;}
    .storymap-epic { background: #fff; border-radius: 10px; box-shadow: 0 0 4px #ddd; padding: 1em; min-width: 180px;}
    .story-badge { display: block; border-radius: 6px; padding: 2px 6px; margin: 2px 0; }
    .story-done { background: #bbf7d0; }
    .story-indev { background: #fde68a; }
    .story-open { background: #f1f5f9; }
    .btn { background: #6366f1; color: #fff; border: none; border-radius: 6px; padding: 7px 15px; cursor: pointer; margin-right: 8px;}
    .btn:disabled { background: #aaa; }
    .summary-box { background: #fff; border-radius: 12px; box-shadow: 0 0 8px #eee; padding: 1em; margin-bottom: 2em;}
    .pdf-area { background: #fff; padding: 20px; border-radius: 16px; }
    .tip { font-size: 0.92em; color: #555; }
    .risk-high { color: #e11d48; font-weight: bold; }
    .risk-low { color: #10b981; font-weight: bold; }
    .section-title { font-size: 1.2em; margin-bottom: .2em; }
    .story-badge input { width: 60px; }
    .editarr { width: 60px; }
    @media print { .no-print { display: none !important; } }
  </style>
</head>
<body>
  <h1>Stakeholder Report Generator (Jira + MCW Simulation, per Epic)</h1>
  <div class="input-row">
    <label>Jira Domain: <input id="jiraDomain" value="aldi-sued.atlassian.net" size="30"></label>
    <label>Board Number: <input id="boardNum" value="" size="6"></label>
    <button class="btn" onclick="fetchSprints()">Fetch Sprints</button>
    <span class="tip">Login to Jira, enable your CORS plugin if needed.</span>
  </div>
  <div class="input-row" id="sprintRow" style="display:none;">
    <label>Sprint:
      <select id="sprintSelect"></select>
    </label>
    <button class="btn" onclick="fetchIssues()">Fetch Issues</button>
  </div>

  <div id="importArea" style="display:none;">
    <div class="section-title">Velocity History (editable, last 6 sprints):</div>
    <div id="velocityWrap"></div>
    <div>
      <button class="btn" onclick="runAllEpicSimulations()">Run Simulations</button>
      <button class="btn" onclick="exportPDF()">Download PDF Report</button>
    </div>
    <hr>
    <div class="section-title">Epic Story Maps & Monte Carlo Forecasts</div>
    <div id="epicSimResults"></div>
    <hr>
    <div class="section-title">Editable Story Table</div>
    <div id="storyTableWrap"></div>
  </div>

  <script>
    // Globals
    let jiraDomain = '', boardNum = '', sprints = [];
    let stories = [], epicStoryMap = {};
    let velocityArr = [];
    let selectedSprintId = '';
    let selectedSprintName = '';
    let editableData = [];

    // ---- FETCH SPRINTS ----
    async function fetchSprints() {
      jiraDomain = document.getElementById('jiraDomain').value.trim();
      boardNum = document.getElementById('boardNum').value.trim();
      if (!jiraDomain || !boardNum) return alert("Enter Jira domain and board number.");
      const url = `https://${jiraDomain}/rest/agile/1.0/board/${boardNum}/sprint?state=active,closed,future`;
      try {
        const resp = await fetch(url, { credentials: "include" });
        const data = await resp.json();
        if (data.values && data.values.length) {
          sprints = data.values;
          populateSprintDropdown();
        } else {
          alert("No sprints found for this board.");
        }
      } catch (e) {
        alert("Failed to fetch sprints. CORS? Are you logged into Jira?");
      }
    }
    function populateSprintDropdown() {
      const sel = document.getElementById('sprintSelect');
      sel.innerHTML = '';
      // Sort by startDate, show most recent first
      sprints.sort((a,b) => new Date(b.startDate||0) - new Date(a.startDate||0));
      sprints.forEach(sprint => {
        const opt = document.createElement('option');
        opt.value = sprint.id;
        opt.textContent = (sprint.state === "active" ? "ðŸŸ¢ " : "") + sprint.name;
        sel.appendChild(opt);
      });
      document.getElementById('sprintRow').style.display = '';
    }

    // ---- FETCH ISSUES ----
    async function fetchIssues() {
      selectedSprintId = document.getElementById('sprintSelect').value;
      selectedSprintName = document.getElementById('sprintSelect').selectedOptions[0].textContent;
      if (!selectedSprintId) return alert("Select a sprint.");
      // Fetch issues for current and previous 5 sprints (total 6 for velocity)
      let sprintIdx = sprints.findIndex(s => s.id == selectedSprintId);
      let sprintIds = [];
      for (let i = sprintIdx; i > sprintIdx - 6 && i >= 0; i--) sprintIds.push(sprints[i].id);

      let allIssues = [];
      for (let sid of sprintIds) {
        const jql = encodeURIComponent(`sprint = ${sid} ORDER BY key`);
        const url = `https://${jiraDomain}/rest/api/3/search?jql=${jql}&fields=summary,status,parent,customfield_10002,customfield_12600,customfield_10005,issuetype&expand=parent.fields&maxResults=200`;
        try {
          const resp = await fetch(url, { credentials: "include" });
          const data = await resp.json();
          if (data.issues && data.issues.length) {
            allIssues.push({sprint: sid, issues: data.issues});
          }
        } catch (e) {
          alert("Failed to fetch issues for sprint " + sid);
        }
      }
      // Parse issues
      let velocityArrRaw = [];
      let epicMap = {};
      stories = []; // stories in selected sprint only
      for (let batch of allIssues) {
        let pointsDone = 0;
        for (let issue of batch.issues) {
          let typeObj = issue.fields.issuetype;
          if (typeObj && (typeObj.subtask || typeObj.name === "Epic")) continue; // SKIP sub-tasks and Epics!
          let pts = Number(issue.fields.customfield_10002) || 1;
          let status = issue.fields.status && issue.fields.status.name;
          if (status && (status.toLowerCase().includes("done") || status.toLowerCase().includes("closed"))) pointsDone += pts;
        }
        velocityArrRaw.push(pointsDone);

        // For selected sprint only, collect all issues for display/backlog
        if (batch.sprint == selectedSprintId) {
          for (let issue of batch.issues) {
            let typeObj = issue.fields.issuetype;
            if (typeObj && (typeObj.subtask || typeObj.name === "Epic")) continue;
            let parent = issue.fields.parent;
            let isEpic = parent && parent.fields && parent.fields.issuetype && parent.fields.issuetype.name === "Epic";
            let epicKey = isEpic ? parent.key : "No Epic";
            let epicSummary = isEpic ? parent.fields.summary : "";
            let sprintsArr = issue.fields.customfield_10005 || [];
            let currentSprint = (sprintsArr.find(s => s.state === "active") || sprintsArr[sprintsArr.length-1] || {}).name || "None";
            let responsibleTeams = (issue.fields.customfield_12600 || []).join(', ');
            let status = issue.fields.status && issue.fields.status.name;
            let pts = Number(issue.fields.customfield_10002) || 1;
            if (!epicMap[epicKey]) epicMap[epicKey] = [];
            epicMap[epicKey].push({
              key: issue.key,
              summary: issue.fields.summary,
              status: status,
              epic: epicKey,
              epicSummary: epicSummary,
              team: responsibleTeams,
              sprint: currentSprint,
              points: pts
            });
            stories.push({
              key: issue.key,
              summary: issue.fields.summary,
              status: status,
              epic: epicKey,
              epicSummary: epicSummary,
              team: responsibleTeams,
              sprint: currentSprint,
              points: pts
            });
          }
        }
      }
      epicStoryMap = epicMap;
      velocityArr = velocityArrRaw.reverse(); // oldest to newest
      editableData = stories.map(s => ({ ...s }));
      showImportArea();
    }

    // ---- DISPLAY IMPORT/EDIT AREA ----
    function showImportArea() {
      // Velocity array
      let vhtml = velocityArr.map((v, i) =>
        `<input class="editarr" type="number" min="0" value="${v}" onchange="editVelocity(this,${i})">`).join(', ');
      document.getElementById('velocityWrap').innerHTML = vhtml;
      // Table
      buildStoryTable();
      // Show area
      document.getElementById('importArea').style.display = '';
      // Reset results view
      document.getElementById('epicSimResults').innerHTML = '';
    }
    function editVelocity(inp, idx) {
      velocityArr[idx] = Number(inp.value) || 0;
    }

    // ---- STORY MAP ----
    function buildStoryMap(epicKey) {
      let byEpic = epicStoryMap[epicKey] || [];
      let html = `<div class="storymap-epic"><h4>${epicKey}</h4>`;
      for (let story of byEpic) {
        let c = story.status.toLowerCase().includes("done") || story.status.toLowerCase().includes("closed")
          ? "story-done"
          : story.status.toLowerCase().includes("progress") || story.status.toLowerCase().includes("development")
            ? "story-indev"
            : "story-open";
        html += `<span class="story-badge ${c}">${story.key}: ${story.summary}</span>`;
      }
      html += `</div>`;
      return html;
    }

    // ---- EDITABLE TABLE ----
    function buildStoryTable() {
      const container = document.getElementById('storyTableWrap');
      let html = `<table><thead>
        <tr><th>Epic</th><th>Story Key</th><th>Summary</th><th>Status</th><th>Team</th><th>Sprint</th><th>Points</th></tr>
        </thead><tbody>`;
      for (let i = 0; i < editableData.length; i++) {
        const s = editableData[i];
        html += `<tr>
          <td>${s.epic}</td>
          <td>${s.key}</td>
          <td>${s.summary}</td>
          <td>
            <select data-idx="${i}" onchange="editStatus(this)">
              <option${s.status.toLowerCase().includes('done')||s.status.toLowerCase().includes('closed')?' selected':''}>Done</option>
              <option${s.status.toLowerCase().includes('progress')||s.status.toLowerCase().includes('development')?' selected':''}>In Progress</option>
              <option${!(s.status.toLowerCase().includes('done')||s.status.toLowerCase().includes('closed')||s.status.toLowerCase().includes('progress')||s.status.toLowerCase().includes('development'))?' selected':''}>To Do</option>
            </select>
          </td>
          <td>${s.team}</td>
          <td>${s.sprint}</td>
          <td><input type="number" min="1" style="width:40px" value="${s.points}" data-idx="${i}" onchange="editPoints(this)"></td>
        </tr>`;
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }
    window.editStatus = function(sel) {
      const idx = sel.getAttribute('data-idx');
      editableData[idx].status = sel.value;
    }
    window.editPoints = function(input) {
      const idx = input.getAttribute('data-idx');
      editableData[idx].points = Number(input.value) || 1;
    }

    // ---- MONTE CARLO SIMULATION (MCW-style, per-epic) ----
    function runAllEpicSimulations() {
      let velocity = velocityArr.filter(v => v>0);
      const resultsArea = document.getElementById('epicSimResults');
      resultsArea.innerHTML = '';
      Object.keys(epicStoryMap).forEach((epicKey, epicIdx) => {
        const epicStories = epicStoryMap[epicKey];
        // Only stories not done/closed
        const notDone = epicStories.filter(s =>
          !(s.status.toLowerCase().includes("done") || s.status.toLowerCase().includes("closed"))
        );
        const backlog = notDone.reduce((sum, s) => sum + Number(s.points), 0);
        if (backlog === 0) return; // skip epics that are already done

        // Monte Carlo for this epic
        const mcResult = mcwSimulate(backlog, velocity, 10000);
        // Draw results and chart for this epic
        let html = `
          <div class="summary-box">
            <h3>Epic: ${epicKey} (${epicStories[0]?.epicSummary || ''})</h3>
            <b>Remaining stories:</b> ${notDone.length} | <b>Backlog (points):</b> ${backlog}<br>
            ${buildStoryMap(epicKey)}
            <ul>
              <li>Median (50% conf): ${mcResult.percentiles[50]} sprints</li>
              <li>75% confidence: ${mcResult.percentiles[75]} sprints</li>
              <li>90% confidence: ${mcResult.percentiles[90]} sprints</li>
              <li>95% confidence: ${mcResult.percentiles[95]} sprints</li>
            </ul>
            <span class="${mcResult.percentiles[75]>4?'risk-high':'risk-low'}">
              ${(mcResult.percentiles[75]>4)?
                "Warning: Risk of not delivering in 4 sprints!":
                "Good: Likely deliverable within 4 sprints."
              }
            </span>
            <canvas id="mcChart${epicIdx}" width="420" height="170"></canvas>
          </div>
        `;
        resultsArea.innerHTML += html;

        // Draw chart
        setTimeout(()=>drawEpicChart(`mcChart${epicIdx}`, mcResult.dist), 0);
      });
    }

    // ---- MCW SIMULATION ----
    function mcwSimulate(backlog, velocityArr, numRuns) {
      let outcomes = [];
      for (let i=0; i<numRuns; i++) {
        let backlogLeft = backlog;
        let sprints = 0;
        while (backlogLeft > 0 && sprints<100) {
          let v = velocityArr[Math.floor(Math.random()*velocityArr.length)];
          if (v < 1) v = 1;
          backlogLeft -= v;
          sprints++;
        }
        outcomes.push(sprints);
      }
      outcomes.sort((a,b)=>a-b);
      function perc(p) {
        let idx = Math.floor(numRuns * (p/100));
        return outcomes[idx];
      }
      // Histogram for chart
      let dist = {};
      for (let s of outcomes) dist[s] = (dist[s]||0)+1;
      return {
        percentiles: {
          50: perc(50),
          75: perc(75),
          90: perc(90),
          95: perc(95)
        },
        dist
      };
    }

    function drawEpicChart(canvasId, dist) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      const labels = Object.keys(dist).sort((a,b)=>a-b);
      const data = labels.map(k=>dist[k]);
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{ label: 'Runs', data }]
        },
        options: {
          plugins: { legend: { display: false } },
          scales: {
            x: { title: { display: true, text: 'Sprints to completion' }},
            y: { title: { display: true, text: 'Simulations' }, ticks: { precision:0 } }
          }
        }
      });
    }

    // ---- PDF EXPORT ----
    async function exportPDF() {
      const area = document.getElementById('importArea');
      area.style.background = '#fff';
      window.scrollTo(0,0);
      const canvas = await html2canvas(area, {scale:2});
      const imgData = canvas.toDataURL('image/png');
      const pdf = new window.jspdf.jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: 'a4'
      });
      const pageWidth = pdf.internal.pageSize.getWidth();
      const imgWidth = pageWidth - 40;
      const ratio = imgWidth / canvas.width;
      const imgHeight = canvas.height * ratio;
      pdf.addImage(imgData, 'PNG', 20, 20, imgWidth, imgHeight);
      pdf.save(`Stakeholder_Report_${selectedSprintName||''}.pdf`);
    }
  </script>
</body>
</html>
