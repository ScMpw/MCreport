<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PI & Target Version Planning Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <link rel="stylesheet" href="public/tailwind.css">
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    html { background: #f7f8fa; }
    body { background: #f7f8fa; font-family: 'Inter', Arial, sans-serif; margin:0; padding:0; }
    .main { max-width: 1200px; margin: 30px auto 40px auto; background: #fff; border-radius: 18px; box-shadow: 0 2px 12px #d1d5db70; padding: 36px 32px 48px 32px; }
    h1 { font-size: 2.2em; margin:0 0 0.7em 0; font-weight: 600; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: flex-end; margin-bottom: 20px; }
    .controls label { display:flex; flex-direction:column; font-size:0.95em; color:#374151; }
    .controls input, .controls select { padding:7px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:0.95em; }
    .btn { background:#6366f1; color:#fff; border:none; border-radius:8px; padding:9px 18px; cursor:pointer; font-size:0.95em; font-weight:600; transition: background 0.15s ease; }
    .btn.secondary { background:#f3f4f6; color:#374151; }
    .btn:disabled { background:#c4c6f5; cursor: default; }
    .section-title { font-size: 1.2em; font-weight:600; margin: 30px 0 14px; color:#111827; }
    .filters { background:#f9fafb; border:1px solid #e5e7eb; border-radius:16px; padding:20px 24px; display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:18px; }
    .filter-block label { font-size:0.85em; color:#6b7280; margin-bottom:6px; display:block; font-weight:600; text-transform:uppercase; letter-spacing:0.02em; }
    .filter-block select { width:100%; }
    .suffix-toggles { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }
    .suffix-toggles label { background:#e0e7ff; color:#4338ca; padding:4px 10px; border-radius:999px; font-size:0.82em; display:flex; align-items:center; gap:6px; font-weight:600; }
    .suffix-toggles input { margin:0; }
    .kpi-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:16px; margin-top:20px; }
    .kpi-card { background:#f9fafb; border:1px solid #e5e7eb; border-radius:16px; padding:18px 20px; box-shadow: inset 0 1px 0 #fff; }
    .kpi-label { font-size:0.9em; color:#6b7280; text-transform:uppercase; letter-spacing:0.04em; margin-bottom:6px; font-weight:600; }
    .kpi-value { font-size:2em; font-weight:600; color:#111827; }
    .chart-section { margin-top:32px; }
    .chart-wrapper { background:#fff; border-radius:16px; border:1px solid #e5e7eb; padding:20px; box-shadow: 0 2px 6px #e5e7f070; }
    .chart-toolbar { display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px; margin-bottom:10px; }
    .chart-toolbar .toggle-group label { margin-right:12px; font-size:0.92em; color:#374151; font-weight:600; }
    .chart-toolbar .toggle-group input { margin-right:4px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #e5e7eb; padding:8px 10px; font-size:0.9em; text-align:left; }
    th { background:#f3f4f6; text-transform:uppercase; font-size:0.76em; letter-spacing:0.06em; color:#4b5563; }
    .table-controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; flex-wrap:wrap; gap:10px; }
    .table-controls input { padding:7px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:0.9em; }
    .timeline { position:relative; margin-top:16px; padding-left:24px; }
    .timeline::before { content:''; position:absolute; left:8px; top:0; bottom:0; width:2px; background:#e5e7eb; }
    .timeline-item { position:relative; margin-bottom:20px; padding-left:16px; }
    .timeline-item:last-child { margin-bottom:0; }
    .timeline-marker { position:absolute; left:-16px; top:6px; width:12px; height:12px; border-radius:999px; background:#6366f1; box-shadow:0 0 0 4px rgba(99,102,241,0.15); }
    .timeline-content { background:#f9fafb; border:1px solid #e5e7eb; border-radius:14px; padding:14px 16px; box-shadow:0 1px 2px rgba(15,23,42,0.05); }
    .timeline-title { font-size:1.05em; font-weight:600; color:#111827; margin-bottom:6px; }
    .timeline-dates { display:flex; flex-wrap:wrap; gap:12px; font-size:0.9em; color:#4b5563; }
    .timeline-dates span { display:flex; align-items:center; gap:6px; }
    .timeline-date-label { font-weight:600; text-transform:uppercase; font-size:0.75em; letter-spacing:0.08em; color:#6b7280; }
    .timeline-issues { margin-top:12px; display:flex; flex-direction:column; gap:10px; }
    .timeline-issue { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; display:flex; flex-direction:column; gap:6px; }
    .timeline-issue.no-target { background:#fef2f2; border-color:#fecaca; }
    .timeline-issue.epic { border-left:4px solid #f59e0b; background:#fffbeb; box-shadow:0 1px 3px rgba(251, 191, 36, 0.25); }
    .timeline-issue.inherited-target { border-style:dashed; border-color:#c7d2fe; background:#eef2ff; }
    .timeline-issue-header { display:flex; flex-wrap:wrap; gap:8px; align-items:center; font-weight:600; color:#1f2937; }
    .timeline-issue-header a { color:#4338ca; text-decoration:none; }
    .timeline-issue-header a:hover { text-decoration:underline; }
    .timeline-issue-summary { flex:1; color:#374151; font-weight:500; }
    .timeline-issue-meta { display:flex; flex-wrap:wrap; gap:8px; font-size:0.82em; color:#4b5563; align-items:center; }
    .timeline-issue-meta .badge { background:#e0e7ff; color:#3730a3; }
    .timeline-issue-meta .badge.epic-badge { background:#fef3c7; color:#b45309; }
    .timeline-issue-meta .issue-team { background:#f1f5f9; border-radius:999px; padding:2px 8px; font-weight:600; }
    .timeline-issue-meta span.issue-epic { display:flex; align-items:center; gap:6px; }
    .timeline-issue-meta span.issue-epic a { color:#4338ca; text-decoration:none; font-weight:600; }
    .timeline-issue-meta span.issue-epic a:hover { text-decoration:underline; }
    .timeline-no-issues { margin-top:12px; padding:14px; border-radius:12px; background:#f8fafc; color:#6b7280; font-size:0.9em; border:1px dashed #cbd5f5; text-align:center; }
    .timeline-empty { background:#f9fafb; border:1px dashed #cbd5f5; border-radius:12px; padding:30px; text-align:center; color:#6b7280; font-size:0.95em; margin-top:20px; }
    .badge { background:#e5e7eb; border-radius:999px; padding:2px 10px; font-size:0.78em; font-weight:600; color:#374151; }
    .status-pill { border-radius:999px; padding:2px 10px; font-size:0.78em; font-weight:600; color:#fff; display:inline-block; }
    .status-pill.default { background:#6b7280; }
    .status-pill.done { background:#10b981; }
    .status-pill.progress { background:#6366f1; }
    .status-pill.blocked { background:#ef4444; }
    .empty-state { background:#f9fafb; border:1px dashed #cbd5f5; border-radius:12px; padding:30px; text-align:center; color:#6b7280; font-size:0.95em; margin-top:20px; }
    .loading { margin:14px 0; font-weight:600; color:#4338ca; }
    .error { margin:14px 0; font-weight:600; color:#dc2626; }
    details.collapsible { margin-top:30px; }
    details.collapsible[open] { margin-bottom:10px; }
    summary.collapsible-summary { list-style:none; cursor:pointer; font-size:1.2em; font-weight:600; color:#111827; display:flex; align-items:center; justify-content:space-between; padding:0; }
    summary.collapsible-summary::marker { display:none; }
    summary.collapsible-summary::after { content:'\25BC'; font-size:0.8em; transition:transform 0.2s ease; color:#6b7280; }
    details[open] > summary.collapsible-summary::after { transform:rotate(180deg); }
    summary.collapsible-summary::-webkit-details-marker { display:none; }
    @media (max-width: 840px) {
      .controls { flex-direction:column; align-items:flex-start; }
      .chart-toolbar { flex-direction:column; align-items:flex-start; }
    }
  </style>
</head>
<body>
  <div class="main" id="pdfContent">
    <h1>PI & Target Version Planning Dashboard</h1>
    <div style="margin-bottom:14px;">
      <label>Version:
        <select id="versionSelect">
          <option value="index.html">Velocity</option>
          <option value="index_throughput.html">Throughput</option>
          <option value="index_throughput_week.html">Weekly Throughput</option>
          <option value="index_disruption.html">Disruption</option>
          <option value="KPI_Report.html">KPI Report</option>
          <option value="target_release_dashboard.html">PI &amp; Target Version Planning Dashboard</option>
        </select>
      </label>
    </div>
    <div class="controls">
      <label>Jira Domain
        <input id="jiraDomain" value="aldi-sued.atlassian.net" placeholder="your-domain.atlassian.net">
      </label>
      <label style="flex:1; min-width:220px;">Boards
        <select id="boardSelect" multiple></select>
      </label>
      <button class="btn" id="loadDataBtn">Load Planning Data</button>
      <button class="btn secondary" id="exportBtn">Export as PDF</button>
    </div>
    <div id="loadingMessage" class="loading" style="display:none;"></div>
    <div id="errorMessage" class="error" style="display:none;"></div>

    <div id="filtersSection" style="display:none;">
      <div class="section-title">Filters</div>
      <div class="filters">
        <div class="filter-block">
          <label for="targetVersionSelect">Target Versions</label>
          <select id="targetVersionSelect" multiple></select>
          <div style="font-size:0.78em; color:#6b7280; margin-top:6px;">Defaults to all target versions from open epics.</div>
        </div>
        <div class="filter-block">
          <label for="piSelect">Product Increments</label>
          <select id="piSelect" multiple></select>
          <div class="suffix-toggles">
            <label><input type="checkbox" id="suffixCommitted" checked> Committed</label>
            <label><input type="checkbox" id="suffixPlanned" checked> Planned</label>
            <label><input type="checkbox" id="suffixSpillover" checked> Spillover</label>
          </div>
        </div>
        <div class="filter-block">
          <label for="teamSelect">Responsible Teams</label>
          <select id="teamSelect" multiple></select>
        </div>
        <div class="filter-block">
          <label for="boardFilterSelect">Boards (Filter)</label>
          <select id="boardFilterSelect" multiple></select>
        </div>
      </div>
    </div>

    <div id="kpiSection" style="display:none;">
      <div class="section-title">Key Metrics</div>
      <div class="kpi-grid">
        <div class="kpi-card">
          <div class="kpi-label">Total Items</div>
          <div class="kpi-value" id="kpiTotal">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">With Target Version</div>
          <div class="kpi-value" id="kpiWith">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">Without Target Version</div>
          <div class="kpi-value" id="kpiWithout">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">% With Target Version</div>
          <div class="kpi-value" id="kpiPct">0%</div>
        </div>
      </div>
    </div>

    <div id="releasesSection" style="display:none;">
      <div class="section-title">Upcoming Releases</div>
      <div class="table-controls">
        <div style="font-size:0.85em; color:#6b7280;">Unreleased or future-dated versions from the selected boards.</div>
        <input id="releaseSearch" placeholder="Search releases...">
      </div>
      <div id="releasesTimeline" class="timeline"></div>
      <div id="releasesEmpty" class="timeline-empty" style="display:none;">No upcoming releases were found for the selected boards.</div>
    </div>

    <div id="epicSection" style="display:none;">
      <details id="epicDetails" class="collapsible" open>
        <summary class="collapsible-summary">Open Epics</summary>
        <div class="table-controls">
          <div style="font-size:0.85em; color:#6b7280;">Epics grouped by target version for the selected boards.</div>
          <input id="epicSearch" placeholder="Search by epic, summary, target version...">
        </div>
        <div class="table-wrap" style="overflow-x:auto;">
          <table>
            <thead>
              <tr>
                <th>Epic</th>
                <th>Summary</th>
                <th>Target Version</th>
                <th>Responsible Team</th>
                <th>Product Increments</th>
                <th>Child Items</th>
                <th>With Target</th>
                <th>Coverage</th>
                <th>Boards</th>
              </tr>
            </thead>
            <tbody id="epicTableBody"></tbody>
          </table>
        </div>
        <div id="epicEmpty" class="empty-state" style="display:none;">No epics match the current filters.</div>
      </details>
    </div>

    <div id="chartsSection" style="display:none;">
      <div class="section-title">Target Version Coverage</div>
      <div class="chart-section">
        <div class="chart-toolbar">
          <div class="toggle-group">
            <label><input type="radio" name="stackedDimension" value="targetVersion" checked> By Target Version</label>
            <label><input type="radio" name="stackedDimension" value="pi"> By Product Increment</label>
          </div>
          <div style="font-size:0.85em; color:#6b7280;">Stacks display with/without target version per responsible team.</div>
        </div>
        <div class="chart-wrapper">
          <canvas id="stackedChart" height="360"></canvas>
        </div>
      </div>

      <div class="chart-section" style="margin-top:36px;">
        <div class="chart-toolbar">
          <div class="toggle-group">
            <label for="distributionMode">Distribution View:</label>
            <select id="distributionMode">
              <option value="team">By Team</option>
              <option value="targetVersion">By Target Version</option>
              <option value="pi">By Product Increment</option>
            </select>
          </div>
          <div style="font-size:0.85em; color:#6b7280;">Shows ratio of issues with/without target versions.</div>
        </div>
        <div class="chart-wrapper">
          <canvas id="distributionChart" height="360"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script src="src/logger.js"></script>
  <script src="src/jira.js"></script>
  <script>
    Logger.setLevel('info');

    const state = {
      domain: '',
      boards: [],
      boardsMap: new Map(),
      normalizedIssues: [],
      responsibleFieldKey: 'responsible-team',
      filteredIssues: [],
      aggregated: null,
      releases: [],
      releaseIndex: new Map(),
      epics: [],
      epicMap: new Map(),
      filteredEpics: [],
    };

    let boardChoices, targetVersionChoices, piChoices, teamChoices, boardFilterChoices;
    let stackedChart, distributionChart;
    const teamColorMap = new Map();
    const palette = ['#6366f1', '#ec4899', '#10b981', '#f97316', '#14b8a6', '#8b5cf6', '#f59e0b', '#ef4444', '#3b82f6', '#22c55e'];

    function initChoices() {
      boardChoices = new Choices('#boardSelect', { removeItemButton: true, shouldSort: false });
      targetVersionChoices = new Choices('#targetVersionSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'All target versions' });
      piChoices = new Choices('#piSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'Select Product Increments' });
      teamChoices = new Choices('#teamSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'All teams' });
      boardFilterChoices = new Choices('#boardFilterSelect', { removeItemButton: true, shouldSort: false });
    }

    function setLoading(message) {
      const el = document.getElementById('loadingMessage');
      if (message) {
        el.textContent = message;
        el.style.display = '';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function setError(message) {
      const el = document.getElementById('errorMessage');
      if (message) {
        el.textContent = message;
        el.style.display = '';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    async function fetchWithRetry(url, options = {}, retries = 3, baseDelay = 800) {
      let attempt = 0;
      while (true) {
        try {
          const resp = await fetch(url, { credentials: 'include', ...options });
          if (resp.status === 429 && attempt < retries) {
            const retryAfter = Number(resp.headers.get('Retry-After'));
            const delay = Number.isFinite(retryAfter) ? retryAfter * 1000 : baseDelay * Math.pow(2, attempt);
            Logger.warn('Rate limited, retrying', url, 'delay', delay);
            await sleep(delay);
            attempt++;
            continue;
          }
          if (!resp.ok) {
            const error = new Error(`Request failed ${resp.status}`);
            error.status = resp.status;
            throw error;
          }
          return resp;
        } catch (err) {
          Logger.error('Request error', url, err);
          if (attempt >= retries) throw err;
          await sleep(baseDelay * Math.pow(2, attempt));
          attempt++;
        }
      }
    }

    const releaseCache = new Map();
    const projectCache = new Map();
    const boardConfigCache = new Map();

    function stripOrderByClause(jql) {
      if (!jql || typeof jql !== 'string') return '';
      let inSingle = false;
      let inDouble = false;
      const upper = jql.toUpperCase();
      for (let i = 0; i < upper.length; i++) {
        const char = jql[i];
        if (char === "'" && !inDouble) {
          const escaped = i > 0 && jql[i - 1] === '\\';
          if (!escaped) inSingle = !inSingle;
        } else if (char === '"' && !inSingle) {
          const escaped = i > 0 && jql[i - 1] === '\\';
          if (!escaped) inDouble = !inDouble;
        }
        if (!inSingle && !inDouble && upper.startsWith('ORDER BY', i)) {
          const prevChar = i > 0 ? jql[i - 1] : ' ';
          if (/\s|\)/.test(prevChar)) {
            return jql.slice(0, i).trim();
          }
        }
      }
      return jql.trim();
    }

    function extractTeamsFromJql(jql, responsibleFieldKey) {
      if (!jql || typeof jql !== 'string') return [];
      const variants = new Set();
      const addVariant = token => {
        if (token) variants.add(token);
      };

      addVariant('Team');
      addVariant('"Team"');
      addVariant('responsible-team');
      addVariant('"responsible-team"');
      addVariant('Responsible Team');
      addVariant('"Responsible Team"');

      if (responsibleFieldKey) {
        addVariant(responsibleFieldKey);
        addVariant(`"${responsibleFieldKey}"`);
        const cleaned = responsibleFieldKey.replace(/[_-]+/g, ' ');
        addVariant(cleaned);
        addVariant(`"${cleaned}"`);
        const titled = cleaned.replace(/\b\w/g, c => c.toUpperCase());
        addVariant(titled);
        addVariant(`"${titled}"`);
        const customMatch = responsibleFieldKey.match(/customfield_(\d+)/i);
        if (customMatch) {
          const id = customMatch[1];
          addVariant(`customfield_${id}`);
          addVariant(`"customfield_${id}"`);
          addVariant(`cf[${id}]`);
          addVariant(`"cf[${id}]"`);
        }
      }

      const escapeRegexToken = token => token.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
      const pattern = Array.from(variants)
        .filter(Boolean)
        .map(escapeRegexToken)
        .join('|');
      if (!pattern) return [];

      const regex = new RegExp(`(?:${pattern})\\s*(?:=|in)\\s*(\\([^\\)]*\\)|\"[^\"\\n]+\")`, 'gi');
      const teams = new Set();

      const addTeam = raw => {
        if (!raw) return;
        const cleaned = raw.replace(/^\s*["']?|["']?\s*$/g, '').trim();
        if (cleaned) teams.add(cleaned);
      };

      let match;
      while ((match = regex.exec(jql)) !== null) {
        const value = match[1] ? match[1].trim() : '';
        if (!value) continue;
        if (value.startsWith('(') && value.endsWith(')')) {
          value.slice(1, -1).split(',').forEach(part => addTeam(part));
        } else {
          addTeam(value);
        }
      }

      return Array.from(teams);
    }

    async function fetchBoardConfiguration(domain, boardId, responsibleFieldKey) {
      const cacheKey = `${domain}:board-config:${boardId}:${responsibleFieldKey || 'responsible-team'}`;
      if (boardConfigCache.has(cacheKey)) return boardConfigCache.get(cacheKey);

      const promise = (async () => {
        const url = `https://${domain}/rest/agile/1.0/board/${boardId}/configuration`;
        const resp = await fetchWithRetry(url);
        const data = await resp.json();
        const filterId = data?.filter?.id;
        let filterQuery = stripOrderByClause(data?.filter?.query || '');
        let teams = extractTeamsFromJql(filterQuery, responsibleFieldKey);

        if ((!teams || !teams.length) && filterId) {
          try {
            const filterResp = await fetchWithRetry(`https://${domain}/rest/api/3/filter/${filterId}`);
            const filterData = await filterResp.json();
            const filterJql = stripOrderByClause(filterData?.jql || '');
            if (filterJql) {
              if (!filterQuery) filterQuery = filterJql;
              teams = extractTeamsFromJql(filterJql, responsibleFieldKey);
            }
          } catch (err) {
            Logger.warn('Failed to fetch filter details for board', boardId, err);
          }
        }

        return {
          id: Number(boardId),
          name: data?.name,
          filterId: filterId ? Number(filterId) : undefined,
          filterQuery,
          teams,
        };
      })();

      boardConfigCache.set(cacheKey, promise);
      return promise;
    }

    async function fetchReleasesForBoard(domain, boardId) {
      const cacheKey = `${domain}:releases:${boardId}`;
      if (releaseCache.has(cacheKey)) return releaseCache.get(cacheKey);

      const promise = (async () => {
        const results = [];
        let startAt = 0;
        const maxResults = 50;
        for (let loop = 0; loop < 40; loop++) {
          const url = `https://${domain}/rest/agile/1.0/board/${boardId}/version?startAt=${startAt}&maxResults=${maxResults}`;
          const resp = await fetchWithRetry(url);
          const data = await resp.json();
          const values = data.values || [];
          values.forEach(v => {
            const normalized = {
              id: v.id ? String(v.id) : undefined,
              uniqueKey: v.id ? String(v.id) : (v.name ? `name:${v.name}` : `board:${boardId}:${startAt}`),
              name: v.name || 'Unnamed Release',
              released: Boolean(v.released),
              archived: Boolean(v.archived),
              releaseDate: v.releaseDate || v.userReleaseDate || null,
              startDate: v.startDate || v.userStartDate || null,
              projectId: v.projectId !== undefined ? Number(v.projectId) : undefined,
              boardId: Number(boardId),
            };
            results.push(normalized);
          });
          startAt += values.length;
          if (data.isLast || !values.length) break;
        }
        return results;
      })();

      releaseCache.set(cacheKey, promise);
      return promise;
    }

    async function fetchProjectDetails(domain, projectId) {
      if (!projectId) return null;
      const key = `${domain}:project:${projectId}`;
      if (projectCache.has(key)) return projectCache.get(key);

      const promise = (async () => {
        const url = `https://${domain}/rest/api/3/project/${projectId}`;
        try {
          const resp = await fetchWithRetry(url);
          const data = await resp.json();
          return {
            key: data.key || undefined,
            name: data.name || undefined,
          };
        } catch (err) {
          Logger.warn('Failed to fetch project details', projectId, err);
          return null;
        }
      })();

      projectCache.set(key, promise);
      return promise;
    }

    const fieldCache = new Map();
    async function discoverResponsibleField(domain) {
      if (fieldCache.has(domain)) return fieldCache.get(domain);
      const promise = (async () => {
        const url = `https://${domain}/rest/api/3/field`;
        const resp = await fetchWithRetry(url);
        const fields = await resp.json();
        let fieldKey = 'responsible-team';
        if (Array.isArray(fields)) {
          const normalized = fields.map(f => ({
            key: f.key || f.id,
            name: (f.name || '').toLowerCase(),
          }));
          const exact = normalized.find(f => f.key === 'responsible-team');
          if (exact) {
            fieldKey = exact.key;
          } else {
            const candidate = normalized.find(f => /responsible[\s-]?team/.test(f.name));
            if (candidate && candidate.key) {
              fieldKey = candidate.key;
            }
          }
        }
        return fieldKey;
      })();
      fieldCache.set(domain, promise);
      return promise;
    }

    async function jiraSearch(domain, payload) {
      const searchUrl = `https://${domain}/rest/api/3/search/jql`;
      const fieldList = Array.isArray(payload.fields) ? payload.fields.filter(Boolean) : [];
      const expandList = Array.isArray(payload.expand) ? payload.expand.filter(Boolean) : [];
      let useGet = true;

      const buildQuery = () => {
        const params = new URLSearchParams();
        params.set('jql', payload.jql);
        params.set('startAt', String(payload.startAt || 0));
        params.set('maxResults', String(payload.maxResults || 50));
        if (fieldList.length) params.set('fields', fieldList.join(','));
        if (expandList.length) params.set('expand', expandList.join(','));
        return params.toString();
      };

      const buildBody = () => {
        const body = {
          jql: payload.jql,
          startAt: payload.startAt || 0,
          maxResults: payload.maxResults || 50,
        };
        if (fieldList.length) body.fields = fieldList;
        if (expandList.length) body.expand = expandList;
        return JSON.stringify(body);
      };

      while (true) {
        try {
          if (useGet) {
            return await fetchWithRetry(`${searchUrl}?${buildQuery()}`, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
              },
            }).then(r => r.json());
          }
          return await fetchWithRetry(searchUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'X-Atlassian-Token': 'no-check',
            },
            body: buildBody(),
          }).then(r => r.json());
        } catch (err) {
          if (useGet) {
            const status = err?.status;
            if (status && [405, 413, 414].includes(status)) {
              Logger.warn(`Jira search GET returned status ${status}, retrying with POST.`);
              useGet = false;
              continue;
            }
            Logger.warn('Jira search GET failed, retrying with POST', err);
            useGet = false;
            continue;
          }
          throw err;
        }
      }
    }

    async function fetchEpicsForBoard(domain, boardConfig, responsibleField) {
      const fields = [
        'key',
        'summary',
        'issuetype',
        'status',
        'assignee',
        'labels',
        'fixVersions',
        'target-release',
        'project',
        'updated',
      ];
      if (responsibleField && responsibleField !== 'responsible-team') {
        fields.push(responsibleField);
      } else {
        fields.push('responsible-team');
      }

      const filterQuery = stripOrderByClause(boardConfig.filterQuery || '');
      const baseJql = filterQuery ? `(${filterQuery}) AND ` : '';
      const projectClause = '(project in (ANP, NPSCO, BF))';
      const jql = `${baseJql}${projectClause} AND issuetype = Epic AND statusCategory != Done`;

      const results = [];
      let startAt = 0;
      const maxResults = 100;
      for (let page = 0; page < 200; page++) {
        const data = await jiraSearch(domain, {
          jql,
          startAt,
          maxResults,
          fields,
        });
        const issues = data.issues || [];
        issues.forEach(issue => results.push({ issue, boardId: boardConfig.id }));
        startAt += issues.length;
        if (startAt >= (data.total || 0) || !issues.length) break;
      }
      return results;
    }

    async function fetchChildIssuesForBoard(domain, boardConfig, epicKeys, responsibleField) {
      if (!epicKeys.length) return [];
      const fields = [
        'key',
        'summary',
        'issuetype',
        'status',
        'assignee',
        'labels',
        'fixVersions',
        'target-release',
        'project',
        'updated',
        'customfield_10014',
        'parent',
      ];
      if (responsibleField && responsibleField !== 'responsible-team') {
        fields.push(responsibleField);
      } else {
        fields.push('responsible-team');
      }

      const filterQuery = stripOrderByClause(boardConfig.filterQuery || '');
      const baseJql = filterQuery ? `(${filterQuery}) AND ` : '';
      const chunkSize = 40;
      const results = [];
      for (let i = 0; i < epicKeys.length; i += chunkSize) {
        const chunk = epicKeys.slice(i, i + chunkSize);
        const formattedKeys = chunk.map(key => `'${String(key).replace(/'/g, "\\'")}'`).join(',');
        const projectClause = '(project in (ANP, NPSCO, BF))';
        const jql = `${baseJql}${projectClause} AND "Epic Link" in (${formattedKeys})`;
        let startAt = 0;
        const maxResults = 100;
        for (let page = 0; page < 200; page++) {
          const data = await jiraSearch(domain, {
            jql,
            startAt,
            maxResults,
            fields,
          });
          const issues = data.issues || [];
          issues.forEach(issue => results.push({ issue, boardId: boardConfig.id }));
          startAt += issues.length;
          if (startAt >= (data.total || 0) || !issues.length) break;
        }
      }
      return results;
    }

    async function fetchStandaloneIssuesForBoard(domain, boardConfig, responsibleField) {
      const fields = [
        'key',
        'summary',
        'issuetype',
        'status',
        'assignee',
        'labels',
        'fixVersions',
        'target-release',
        'project',
        'updated',
        'customfield_10014',
        'parent',
      ];
      if (responsibleField && responsibleField !== 'responsible-team') {
        fields.push(responsibleField);
      } else {
        fields.push('responsible-team');
      }

      const filterQuery = stripOrderByClause(boardConfig.filterQuery || '');
      const baseJql = filterQuery ? `(${filterQuery}) AND ` : '';
      const projectClause = '(project in (ANP, NPSCO, BF))';
      const typeExclusion = 'issuetype not in (Epic, Sub-task, "Sub-Task")';
      const epicEmptyClause = '"Epic Link" is EMPTY';
      const jql = `${baseJql}${projectClause} AND ${typeExclusion} AND ${epicEmptyClause}`;

      const results = [];
      let startAt = 0;
      const maxResults = 100;
      for (let page = 0; page < 200; page++) {
        const data = await jiraSearch(domain, {
          jql,
          startAt,
          maxResults,
          fields,
        });
        const issues = data.issues || [];
        issues.forEach(issue => results.push({ issue, boardId: boardConfig.id }));
        startAt += issues.length;
        if (startAt >= (data.total || 0) || !issues.length) break;
      }
      return results;
    }

    // Planning helpers will be defined below.

    function parseTargetReleaseValues(raw) {
      if (!raw) return [];
      const values = [];
      const seen = new Set();
      const addValue = (value) => {
        if (!value) return;
        const str = String(value).trim();
        if (!str) return;
        const key = str.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        values.push(str);
      };
      if (typeof raw === 'string') {
        addValue(raw);
      } else if (Array.isArray(raw)) {
        raw.forEach(item => {
          if (!item) return;
          if (typeof item === 'string') {
            addValue(item);
          } else if (typeof item === 'object') {
            addValue(item.name || item.value || item.label);
          }
        });
      } else if (typeof raw === 'object') {
        addValue(raw.name || raw.value || raw.label);
      }
      return values;
    }

    function parseFixVersions(raw) {
      if (!Array.isArray(raw) || !raw.length) return [];
      const seen = new Set();
      const versions = [];
      raw.forEach(version => {
        if (!version) return;
        const id = version.id ? String(version.id) : undefined;
        const name = version.name ? String(version.name) : undefined;
        const key = id || (name ? `name:${name}` : undefined);
        if (!key || seen.has(key)) return;
        seen.add(key);
        versions.push({
          id,
          key,
          name: name || 'Unnamed Release',
          released: Boolean(version.released),
          releaseDate: version.releaseDate || version.userReleaseDate || undefined,
          startDate: version.startDate || version.userStartDate || undefined,
        });
      });
      return versions;
    }

    function extractResponsibleTeam(fields, responsibleFieldKey) {
      const responsibleValue = fields?.[responsibleFieldKey] ?? fields?.['responsible-team'];
      if (!responsibleValue) return undefined;
      if (typeof responsibleValue === 'string') return responsibleValue;
      if (Array.isArray(responsibleValue)) {
        return responsibleValue.find(val => typeof val === 'string');
      }
      if (typeof responsibleValue === 'object') {
        return responsibleValue.value || responsibleValue.name || responsibleValue.title || undefined;
      }
      return undefined;
    }

    function extractPis(labels) {
      if (!Array.isArray(labels) || !labels.length) return [];
      const matches = [];
      const seen = new Set();
      labels.forEach(label => {
        if (typeof label !== 'string') return;
        const trimmed = label.trim();
        const match = trimmed.match(/^(pi\d{2})(?:[_-](committed|planned|spillover))?$/i);
        if (!match) return;
        const base = match[1].toLowerCase();
        const suffix = match[2] ? match[2].toLowerCase() : null;
        const key = suffix ? `${base}_${suffix}` : base;
        if (seen.has(key)) return;
        seen.add(key);
        matches.push({ base, suffix: suffix === 'committed' || suffix === 'planned' || suffix === 'spillover' ? suffix : null, label: suffix ? `${base}_${suffix}` : base });
      });
      return matches;
    }

    function determineTargetVersions(fixVersions, targetReleases) {
      const targets = [];
      const seen = new Set();

      const addTarget = (key, label, source, hasValue = true) => {
        if (!key) return;
        const finalKey = key || '__none__';
        if (seen.has(finalKey)) return;
        seen.add(finalKey);
        targets.push({
          key: finalKey,
          label: label || 'No Target Version',
          hasValue,
          source,
        });
      };

      if (Array.isArray(fixVersions) && fixVersions.length) {
        fixVersions.forEach(version => {
          if (!version) return;
          const key = version.key || (version.name ? `name:${version.name}` : undefined) || '__none__';
          const label = version.name || 'Unnamed Release';
          addTarget(key, label, 'fixVersion', key !== '__none__');
        });
      }

      if (Array.isArray(targetReleases) && targetReleases.length) {
        targetReleases.forEach(value => {
          const label = value || 'No Target Version';
          const key = value ? `target:${value}` : '__none__';
          addTarget(key, label, value ? 'target-release' : 'none', Boolean(value));
        });
      }

      if (!targets.length) {
        addTarget('__none__', 'No Target Version', 'none', false);
      }

      const primary = targets.find(target => target.hasValue) || targets[0];
      return {
        primary,
        targets,
      };
    }

    function normalizeEpic(issue, boardId, responsibleFieldKey) {
      const fields = issue.fields || {};
      const labels = Array.isArray(fields.labels) ? fields.labels.slice() : [];
      const pis = extractPis(labels);
      const fixVersions = parseFixVersions(fields.fixVersions);
      const targetReleases = parseTargetReleaseValues(fields['target-release']);
      const targetInfo = determineTargetVersions(fixVersions, targetReleases);
      const targetPrimary = targetInfo.primary;
      const targetVersions = targetInfo.targets;
      const responsibleTeam = extractResponsibleTeam(fields, responsibleFieldKey);

      return {
        id: String(issue.id || issue.key || ''),
        key: String(issue.key || ''),
        summary: String(fields.summary || ''),
        status: fields.status?.name ? String(fields.status.name) : 'Unknown',
        assignee: fields.assignee?.displayName ? String(fields.assignee.displayName) : undefined,
        responsibleTeam: responsibleTeam || undefined,
        boardIds: new Set([Number(boardId)]),
        fixVersions,
        targetRelease: targetReleases[0] || undefined,
        targetReleases,
        targetVersion: targetPrimary.label,
        targetVersionKey: targetPrimary.key,
        hasTargetVersion: targetPrimary.hasValue,
        targetSource: targetPrimary.source,
        targetVersions,
        pis,
        labels,
        updated: fields.updated ? String(fields.updated) : undefined,
        project: fields.project?.name ? String(fields.project.name) : undefined,
        childTotal: 0,
        childWithTarget: 0,
        childWithoutTarget: 0,
        coveragePct: 0,
      };
    }

    function extractEpicLink(fields) {
      if (!fields) return undefined;
      if (typeof fields.epicLink === 'string') return fields.epicLink;
      if (typeof fields['Epic Link'] === 'string') return fields['Epic Link'];
      if (fields.customfield_10014) {
        if (typeof fields.customfield_10014 === 'string') return fields.customfield_10014;
        if (typeof fields.customfield_10014 === 'object' && fields.customfield_10014.key) {
          return String(fields.customfield_10014.key);
        }
      }
      if (fields.parent?.key && fields.parent?.fields?.issuetype?.name === 'Epic') {
        return String(fields.parent.key);
      }
      return undefined;
    }

    function normalizeChildIssue(issue, boardId, responsibleFieldKey, epicMap) {
      const fields = issue.fields || {};
      const epicKey = extractEpicLink(fields);
      const parent = epicKey ? epicMap.get(epicKey) : undefined;
      const labels = Array.isArray(fields.labels) ? fields.labels.slice() : [];
      if (parent?.labels) {
        parent.labels.forEach(label => {
          if (typeof label === 'string' && !labels.includes(label)) labels.push(label);
        });
      }
      const pis = extractPis(labels);
      const fixVersions = parseFixVersions(fields.fixVersions);
      const targetReleases = parseTargetReleaseValues(fields['target-release']);
      const targetInfo = determineTargetVersions(fixVersions, targetReleases);
      const targetPrimary = targetInfo.primary;
      const targetVersions = targetInfo.targets;
      const responsibleTeam = parent?.responsibleTeam || extractResponsibleTeam(fields, responsibleFieldKey);

      const parentTargetVersion = parent?.targetVersion || targetPrimary.label || 'No Target Version';
      const parentTargetVersionKey = parent?.targetVersionKey || targetPrimary.key || '__none__';
      const parentTargetVersions = parent?.targetVersions?.length
        ? parent.targetVersions.map(target => ({ ...target }))
        : targetVersions.map(target => ({ ...target }));

      return {
        id: String(issue.id || issue.key || ''),
        key: String(issue.key || ''),
        summary: String(fields.summary || ''),
        type: fields.issuetype?.name ? String(fields.issuetype.name) : 'Unknown',
        status: fields.status?.name ? String(fields.status.name) : 'Unknown',
        assignee: fields.assignee?.displayName ? String(fields.assignee.displayName) : undefined,
        responsibleTeam: responsibleTeam || undefined,
        boardIds: new Set([Number(boardId)]),
        fixVersions,
        targetRelease: targetReleases[0] || undefined,
        targetReleases,
        targetVersion: targetPrimary.label,
        targetVersionKey: targetPrimary.key,
        hasTargetVersion: targetPrimary.hasValue,
        targetSource: targetPrimary.source,
        targetVersions,
        parentKey: epicKey || parent?.key,
        parentSummary: parent?.summary,
        parentTargetVersion: parentTargetVersion,
        parentTargetVersionKey: parentTargetVersionKey,
        parentTargetVersions,
        parentPis: parent?.pis?.length ? parent.pis.slice() : (pis.length ? pis : []),
        pis,
        project: fields.project?.name ? String(fields.project.name) : undefined,
        updated: fields.updated ? String(fields.updated) : undefined,
      };
    }

    function computeEpicCoverage(epics, issues) {
      const map = new Map(epics.map(epic => [epic.key, epic]));
      epics.forEach(epic => {
        epic.childTotal = 0;
        epic.childWithTarget = 0;
        epic.childWithoutTarget = 0;
        epic.coveragePct = 0;
      });
      issues.forEach(issue => {
        if (!issue.parentKey) return;
        const epic = map.get(issue.parentKey);
        if (!epic) return;
        epic.childTotal += 1;
        if (issue.hasTargetVersion) epic.childWithTarget += 1; else epic.childWithoutTarget += 1;
      });
      epics.forEach(epic => {
        epic.coveragePct = computePct(epic.childWithTarget, epic.childTotal);
      });
    }

    function computePct(withTarget, total) {
      if (!total) return 0;
      return Number(((withTarget / total) * 100).toFixed(1));
    }

    function collectTargetVersionKeys(entity, includeParent = false) {
      const keys = new Set();

      const addTargets = targets => {
        if (!Array.isArray(targets)) return;
        targets.forEach(target => {
          if (!target) return;
          const key = target.key || '__none__';
          keys.add(key);
        });
      };

      if (entity?.targetVersions?.length) {
        addTargets(entity.targetVersions);
      } else if (entity?.targetVersionKey) {
        keys.add(entity.targetVersionKey);
      }

      if (includeParent) {
        if (entity?.parentTargetVersions?.length) {
          addTargets(entity.parentTargetVersions);
        } else if (entity?.parentTargetVersionKey) {
          keys.add(entity.parentTargetVersionKey);
        }
      }

      if (!keys.size) keys.add('__none__');
      return Array.from(keys);
    }

    function getAllTargetVersionsForEntity(entity, includeParent = false) {
      const map = new Map();
      const addTarget = (target, overrideSource) => {
        if (!target) return;
        const key = target.key || '__none__';
        const label = target.label || 'No Target Version';
        if (map.has(key)) return;
        map.set(key, {
          key,
          label,
          hasValue: target.hasValue !== false && key !== '__none__',
          source: overrideSource || target.source || 'none',
        });
      };

      if (entity?.targetVersions?.length) {
        entity.targetVersions.forEach(target => addTarget(target));
      } else if (entity?.targetVersionKey) {
        addTarget({
          key: entity.targetVersionKey,
          label: entity.targetVersion,
          hasValue: entity.hasTargetVersion,
          source: entity.targetSource,
        });
      }

      if (includeParent) {
        if (entity?.parentTargetVersions?.length) {
          entity.parentTargetVersions.forEach(target => addTarget(target, 'inherited'));
        } else if (entity?.parentTargetVersionKey) {
          addTarget({
            key: entity.parentTargetVersionKey,
            label: entity.parentTargetVersion,
            hasValue: entity.parentTargetVersionKey !== '__none__',
            source: 'inherited',
          });
        }
      }

      if (!map.size) {
        addTarget({ key: '__none__', label: 'No Target Version', hasValue: false, source: 'none' });
      }

      return Array.from(map.values());
    }

    function formatTargetVersionLabels(targets) {
      if (!Array.isArray(targets) || !targets.length) return 'No Target Version';
      const seen = new Set();
      const labels = [];
      targets.forEach(target => {
        if (!target) return;
        if (!target.hasValue || target.key === '__none__') return;
        const label = target.label || 'No Target Version';
        const key = label.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        labels.push(label);
      });
      if (labels.length) return labels.join(', ');
      return targets[0]?.label || 'No Target Version';
    }

    function resolveTimelineTargets(entity, includeParent = false) {
      const directTargets = (entity?.targetVersions?.length
        ? entity.targetVersions
        : [{
            key: entity?.targetVersionKey || '__none__',
            label: entity?.targetVersion || 'No Target Version',
            hasValue: entity?.hasTargetVersion,
            source: entity?.targetSource || 'none',
          }]
      ).map(target => ({ ...target }));

      const hasDirectValue = directTargets.some(target => target && target.hasValue && target.key !== '__none__');

      if (hasDirectValue) {
        return directTargets;
      }

      if (includeParent) {
        const parentTargets = (entity?.parentTargetVersions?.length
          ? entity.parentTargetVersions
          : [{
              key: entity?.parentTargetVersionKey || '__none__',
              label: entity?.parentTargetVersion || 'No Target Version',
              hasValue: entity?.parentTargetVersionKey && entity.parentTargetVersionKey !== '__none__',
              source: 'inherited',
            }]
        ).map(target => ({ ...target, source: 'inherited' }));

        const hasParentValue = parentTargets.some(target => target && target.hasValue && target.key !== '__none__');

        if (hasParentValue) {
          return parentTargets;
        }

        if (parentTargets.length) {
          return parentTargets;
        }
      }

      if (directTargets.length) {
        return directTargets;
      }

      return [{ key: '__none__', label: 'No Target Version', hasValue: false, source: includeParent ? 'inherited' : 'none' }];
    }

    function aggregateIssues(issues) {
      const fallbackVersion = { key: '__none__', label: 'No Target Version' };
      const fallbackPi = { key: 'no-pi', label: 'No Product Increment' };
      const fallbackTeam = 'Unassigned Team';

      function ensureBucket(map, key, label) {
        if (!map.has(key)) {
          map.set(key, {
            key,
            label,
            total: 0,
            withTarget: 0,
            withoutTarget: 0,
            pctWith: 0,
            teams: {},
          });
        }
        return map.get(key);
      }

      function ensureTeam(bucket, team) {
        if (!bucket.teams[team]) {
          bucket.teams[team] = { team, total: 0, withTarget: 0, withoutTarget: 0, pctWith: 0 };
        }
        return bucket.teams[team];
      }

      function addIssue(bucket, issue, teamName) {
        bucket.total += 1;
        if (issue.hasTargetVersion) bucket.withTarget += 1; else bucket.withoutTarget += 1;
        const teamAgg = ensureTeam(bucket, teamName);
        teamAgg.total += 1;
        if (issue.hasTargetVersion) teamAgg.withTarget += 1; else teamAgg.withoutTarget += 1;
      }

      function finalizeBucket(bucket) {
        bucket.pctWith = computePct(bucket.withTarget, bucket.total);
        Object.values(bucket.teams).forEach(team => {
          team.pctWith = computePct(team.withTarget, team.total);
        });
      }

      const versionBuckets = new Map();
      const piBuckets = new Map();
      const teamBuckets = new Map();
      let total = 0;
      let withTarget = 0;

      issues.forEach(issue => {
        const teamName = issue.responsibleTeam || fallbackTeam;
        const versionKey = issue.parentTargetVersionKey || issue.targetVersionKey || fallbackVersion.key;
        const versionLabel = issue.parentTargetVersion || issue.targetVersion || fallbackVersion.label;
        const versionBucket = ensureBucket(versionBuckets, versionKey, versionLabel);
        addIssue(versionBucket, issue, teamName);

        const piValues = issue.parentPis && issue.parentPis.length ? issue.parentPis : (issue.pis && issue.pis.length ? issue.pis : [fallbackPi]);
        const seenPi = new Set();
        piValues.forEach(pi => {
          const value = pi && pi.label ? pi.label : fallbackPi.label;
          if (seenPi.has(value)) return;
          seenPi.add(value);
          const bucket = ensureBucket(piBuckets, value, value);
          addIssue(bucket, issue, teamName);
        });

        if (!teamBuckets.has(teamName)) {
          teamBuckets.set(teamName, { team: teamName, total: 0, withTarget: 0, withoutTarget: 0, pctWith: 0 });
        }
        const teamBucket = teamBuckets.get(teamName);
        teamBucket.total += 1;
        if (issue.hasTargetVersion) teamBucket.withTarget += 1; else teamBucket.withoutTarget += 1;

        total += 1;
        if (issue.hasTargetVersion) withTarget += 1;
      });

      const byTargetVersion = Array.from(versionBuckets.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      byTargetVersion.forEach(finalizeBucket);

      const byPi = Array.from(piBuckets.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      byPi.forEach(finalizeBucket);

      const byTeam = Array.from(teamBuckets.values()).sort((a, b) => a.team.localeCompare(b.team));
      byTeam.forEach(team => { team.pctWith = computePct(team.withTarget, team.total); });

      return {
        total,
        withTarget,
        withoutTarget: total - withTarget,
        pctWith: computePct(withTarget, total),
        byTargetVersion,
        byPi,
        byTeam,
      };
    }

    function teamColor(team) {
      if (!teamColorMap.has(team)) {
        const idx = teamColorMap.size % palette.length;
        teamColorMap.set(team, palette[idx]);
      }
      return teamColorMap.get(team);
    }

    function colorWithAlpha(hex, alpha) {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function formatDate(value) {
      if (!value) return '';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return value;
      return date.toLocaleDateString();
    }

    function getStatusClass(status) {
      if (!status) return 'default';
      const lower = status.toLowerCase();
      if (lower.includes('done') || lower.includes('closed')) return 'done';
      if (lower.includes('progress') || lower.includes('in progress')) return 'progress';
      if (lower.includes('block')) return 'blocked';
      return 'default';
    }

    function applyFilters() {
      const selectedVersions = new Set(targetVersionChoices.getValue(true));
      const selectedPiBases = new Set(piChoices.getValue(true));
      const allowCommitted = document.getElementById('suffixCommitted').checked;
      const allowPlanned = document.getElementById('suffixPlanned').checked;
      const allowSpillover = document.getElementById('suffixSpillover').checked;
      const selectedTeams = new Set(teamChoices.getValue(true));
      const selectedBoardFilters = new Set(boardFilterChoices.getValue(true));

      const filteredEpics = state.epics.filter(epic => {
        if (selectedVersions.size) {
          const keys = collectTargetVersionKeys(epic);
          if (!keys.some(key => selectedVersions.has(key))) return false;
        }

        if (selectedPiBases.size) {
          let piMatch = false;
          if (!epic.pis.length && selectedPiBases.has('__none__')) {
            piMatch = true;
          }
          epic.pis.forEach(pi => {
            if (!pi || !pi.base) return;
            if (!selectedPiBases.has(pi.base)) return;
            if (pi.suffix === 'committed' && !allowCommitted) return;
            if (pi.suffix === 'planned' && !allowPlanned) return;
            if (pi.suffix === 'spillover' && !allowSpillover) return;
            piMatch = true;
          });
          if (!piMatch) return false;
        }

        if (selectedTeams.size) {
          const team = epic.responsibleTeam || 'Unassigned Team';
          if (!selectedTeams.has(team)) return false;
        }

        if (selectedBoardFilters.size) {
          const boards = epic.boardIds && epic.boardIds.size
            ? Array.from(epic.boardIds).map(String)
            : ['__unassigned__'];
          if (!boards.some(id => selectedBoardFilters.has(id))) return false;
        }

        return true;
      });

      const filteredEpicKeys = new Set(filteredEpics.map(epic => epic.key));
      const standaloneIssues = [];
      const filteredIssues = state.normalizedIssues.filter(issue => {
        if (issue.parentKey) {
          return filteredEpicKeys.has(issue.parentKey);
        }

        if (selectedVersions.size) {
          const keys = collectTargetVersionKeys(issue, true);
          if (!keys.some(key => selectedVersions.has(key))) return false;
        }

        if (selectedPiBases.size) {
          let piMatch = false;
          if ((!issue.pis || !issue.pis.length) && selectedPiBases.has('__none__')) {
            piMatch = true;
          }
          (issue.pis || []).forEach(pi => {
            if (!pi || !pi.base) return;
            if (!selectedPiBases.has(pi.base)) return;
            if (pi.suffix === 'committed' && !allowCommitted) return;
            if (pi.suffix === 'planned' && !allowPlanned) return;
            if (pi.suffix === 'spillover' && !allowSpillover) return;
            piMatch = true;
          });
          if (!piMatch) return false;
        }

        if (selectedTeams.size) {
          const team = issue.responsibleTeam || 'Unassigned Team';
          if (!selectedTeams.has(team)) return false;
        }

        if (selectedBoardFilters.size) {
          const boards = issue.boardIds && issue.boardIds.size
            ? Array.from(issue.boardIds).map(String)
            : ['__unassigned__'];
          if (!boards.some(id => selectedBoardFilters.has(id))) return false;
        }

        standaloneIssues.push(issue);
        return true;
      });

      state.filteredEpics = filteredEpics;
      state.filteredIssues = filteredIssues;
      state.aggregated = aggregateIssues(filteredIssues);
      computeEpicCoverage(filteredEpics, filteredIssues);
      renderKpis();
      updateCharts();
      renderEpicTable();
      renderReleasesTimeline();

      const epicIssueCount = filteredIssues.filter(issue => issue.parentKey).length;
      if (!filteredEpics.length && epicIssueCount > 0) {
        setLoading('No epics match the current filter selection.');
      } else if (!filteredIssues.length && state.epics.length && !standaloneIssues.length) {
        setLoading('Filtered epics do not have matching child items.');
      } else if (!filteredEpics.length && !state.epics.length && !filteredIssues.length) {
        setLoading('No epics found for the selected boards.');
      } else {
        setLoading('');
      }
    }

    function getUpcomingReleases() {
      if (!state.releases.length) return [];
      const nowTime = Date.now();
      return state.releases.filter(rel => {
        if (rel.archived) return false;
        if (!rel.releaseDate) return !rel.released;
        const date = new Date(rel.releaseDate);
        if (Number.isNaN(date.getTime())) return !rel.released;
        return !rel.released || date.getTime() >= nowTime;
      }).sort((a, b) => {
        const aTime = a.releaseDate ? new Date(a.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        const bTime = b.releaseDate ? new Date(b.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        if (aTime === bTime) return a.name.localeCompare(b.name, undefined, { numeric: true });
        return aTime - bTime;
      });
    }

    function buildTimelineIssueHtml(issue) {
      const domain = state.domain;
      const team = issue.responsibleTeam || 'Unassigned Team';
      const boards = issue.boardIds && issue.boardIds.size
        ? Array.from(issue.boardIds).map(id => state.boardsMap.get(Number(id))?.name || `Board ${id}`).join(', ')
        : '';
      const updated = formatDate(issue.updated);
      const badgeClass = issue.isEpic ? 'badge epic-badge' : 'badge';
      const timelineTarget = issue.timelineTargetVersion || issue.targetVersion;
      const timelineSource = issue.timelineTargetSource || issue.targetSource;
      const targetSuffix = timelineSource === 'inherited' ? ' (from epic)' : '';
      const issueType = (issue.type || '').toLowerCase();
      const metaParts = [
        `<span class="${badgeClass}">${issue.type}</span>`,
        `<span class="status-pill ${getStatusClass(issue.status)}">${issue.status}</span>`,
        `<span class="issue-team">Team: ${team}</span>`,
      ];
      if (issue.parentKey) {
        const epicSummary = issue.parentSummary ? `  ${issue.parentSummary}` : '';
        metaParts.push(`<span class="issue-epic">Epic <a href="https://${domain}/browse/${issue.parentKey}" target="_blank" rel="noopener">${issue.parentKey}</a>${epicSummary}</span>`);
      }
      const shouldShowTarget = issue.isEpic || issueType !== 'task';
      if (shouldShowTarget) {
        metaParts.push(`<span>Target: ${timelineTarget}${targetSuffix}</span>`);
      }
      if (boards) metaParts.push(`<span>Boards: ${boards}</span>`);
      if (issue.assignee) metaParts.push(`<span>Assignee: ${issue.assignee}</span>`);
      if (updated) metaParts.push(`<span>Updated ${updated}</span>`);

      const classes = ['timeline-issue'];
      if (!issue.hasTargetVersion && timelineSource !== 'inherited') classes.push('no-target');
      if (issue.isEpic) classes.push('epic');
      if (timelineSource === 'inherited') classes.push('inherited-target');

      return `
        <div class="${classes.join(' ')}">
          <div class="timeline-issue-header">
            <a href="https://${domain}/browse/${issue.key}" target="_blank" rel="noopener">${issue.key}</a>
            <span class="timeline-issue-summary">${issue.summary || ''}</span>
          </div>
          <div class="timeline-issue-meta">
            ${metaParts.join('')}
          </div>
        </div>
      `;
    }

    function renderReleasesTimeline() {
      const container = document.getElementById('releasesTimeline');
      if (!container) return;
      const searchInput = document.getElementById('releaseSearch');
      const search = searchInput ? searchInput.value.trim().toLowerCase() : '';

      const releases = getUpcomingReleases();
      const releaseBuckets = new Map();
      releases.forEach(release => {
        releaseBuckets.set(release.uniqueKey, {
          type: 'release',
          key: release.uniqueKey,
          label: release.name,
          release,
          issues: [],
        });
      });

      const orphanBuckets = new Map();
      const ensureOrphanBucket = (key, issue) => {
        if (orphanBuckets.has(key)) return orphanBuckets.get(key);
        const timelineTarget = issue?.timelineTargetVersion || issue?.targetVersion;
        const timelineSource = issue?.timelineTargetSource || issue?.targetSource;
        let label = timelineTarget || 'Unmapped Target Version';
        let type = timelineSource === 'target-release' ? 'manual' : 'unmapped';
        if (timelineSource === 'inherited') type = 'inherited';
        if (key === '__none__' || (!issue?.hasTargetVersion && timelineSource !== 'inherited')) {
          label = 'No Target Version';
          type = 'none';
        } else if (timelineSource === 'target-release' && key.startsWith('target:')) {
          label = timelineTarget || key.slice('target:'.length);
          type = 'manual';
        }
        const bucket = { type, key, label, release: null, issues: [] };
        orphanBuckets.set(key, bucket);
        return bucket;
      };

      const timelineItems = [];

      state.filteredIssues.forEach(issue => {
        const baseItem = {
          ...issue,
          boardIds: issue.boardIds && issue.boardIds.size ? new Set(issue.boardIds) : new Set(),
          isEpic: false,
        };
        const targets = resolveTimelineTargets(issue, true);
        targets.forEach(target => {
          const item = {
            ...baseItem,
            timelineTargetVersion: target.label,
            timelineTargetVersionKey: target.key,
            timelineTargetSource: target.source,
            hasTargetVersion: target.hasValue,
          };
          timelineItems.push(item);
        });
      });

      state.filteredEpics.forEach(epic => {
        const baseItem = {
          ...epic,
          type: 'Epic',
          isEpic: true,
          boardIds: epic.boardIds && epic.boardIds.size ? new Set(epic.boardIds) : new Set(),
          parentKey: undefined,
          parentSummary: undefined,
          parentTargetVersion: epic.targetVersion,
          parentTargetVersionKey: epic.targetVersionKey,
          parentPis: epic.pis,
        };
        const targets = resolveTimelineTargets(epic, false);
        targets.forEach(target => {
          const item = {
            ...baseItem,
            timelineTargetVersion: target.label,
            timelineTargetVersionKey: target.key,
            timelineTargetSource: target.source,
            hasTargetVersion: target.hasValue,
          };
          timelineItems.push(item);
        });
      });

      timelineItems.forEach(issue => {
        const key = issue.timelineTargetVersionKey || issue.targetVersionKey || '__none__';
        const bucket = releaseBuckets.get(key) || ensureOrphanBucket(key, issue);
        bucket.issues.push(issue);
      });

      const releaseList = Array.from(releaseBuckets.values()).sort((a, b) => {
        const aDate = a.release?.releaseDate ? new Date(a.release.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        const bDate = b.release?.releaseDate ? new Date(b.release.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        if (aDate === bDate) return a.label.localeCompare(b.label, undefined, { numeric: true });
        return aDate - bDate;
      });
      const orphanList = Array.from(orphanBuckets.values()).sort((a, b) => {
        if (a.type === 'none' && b.type !== 'none') return 1;
        if (b.type === 'none' && a.type !== 'none') return -1;
        return a.label.localeCompare(b.label, undefined, { numeric: true });
      });
      const buckets = [...releaseList, ...orphanList];

      const matchesSearch = (bucket) => {
        if (!search) return true;
        const values = [bucket.label || ''];
        if (bucket.release) {
          values.push(bucket.release.name || '');
          if (bucket.release.projectName) values.push(bucket.release.projectName);
          if (bucket.release.projectKey) values.push(bucket.release.projectKey);
          if (bucket.release.boardId !== undefined) {
            const boardName = state.boardsMap.get(Number(bucket.release.boardId))?.name || `Board ${bucket.release.boardId}`;
            values.push(boardName);
          }
        } else if (bucket.type === 'none') {
          values.push('no target version');
        } else if (bucket.type === 'manual') {
          values.push('target release');
        } else if (bucket.type === 'inherited') {
          values.push('inherited target');
        } else {
          values.push('fix version');
        }
        bucket.issues.forEach(issue => {
          values.push(
            issue.key,
            issue.summary,
            issue.responsibleTeam,
            issue.status,
            issue.type,
            issue.targetVersion,
            issue.timelineTargetVersion,
            issue.assignee,
            issue.parentKey,
            issue.parentSummary,
          );
          if (issue.boardIds && issue.boardIds.size) {
            issue.boardIds.forEach(id => {
              values.push(state.boardsMap.get(Number(id))?.name || `Board ${id}`);
            });
          }
        });
        return values.some(value => value && String(value).toLowerCase().includes(search));
      };

      container.innerHTML = '';
      document.getElementById('releasesSection').style.display = '';

      const filteredBuckets = buckets.filter(matchesSearch);
      if (!filteredBuckets.length) {
        document.getElementById('releasesEmpty').style.display = '';
        return;
      }
      document.getElementById('releasesEmpty').style.display = 'none';

      const collectBoardNames = (issues) => {
        const names = new Set();
        issues.forEach(issue => {
          if (!issue.boardIds || !issue.boardIds.size) return;
          issue.boardIds.forEach(id => {
            names.add(state.boardsMap.get(Number(id))?.name || `Board ${id}`);
          });
        });
        return Array.from(names.values());
      };

      filteredBuckets.forEach(bucket => {
        bucket.issues.sort((a, b) => {
          if (Boolean(a.isEpic) === Boolean(b.isEpic)) {
            return String(a.key || '').localeCompare(String(b.key || ''), undefined, { numeric: true });
          }
          return a.isEpic ? -1 : 1;
        });
        const item = document.createElement('div');
        item.className = 'timeline-item';
        const issueCount = bucket.issues.length;
        let metaSpans = [];
        if (bucket.release) {
          const startDate = bucket.release.startDate ? formatDate(bucket.release.startDate) : 'Not set';
          const releaseDate = bucket.release.releaseDate ? formatDate(bucket.release.releaseDate) : 'Not set';
          const boardName = bucket.release.boardId !== undefined
            ? state.boardsMap.get(Number(bucket.release.boardId))?.name || `Board ${bucket.release.boardId}`
            : '';
          const projectDisplay = bucket.release.projectName
            ? bucket.release.projectKey
              ? `${bucket.release.projectName} (${bucket.release.projectKey})`
              : bucket.release.projectName
            : (bucket.release.projectKey || '');
          metaSpans = [
            `<span><span class="timeline-date-label">Start</span> ${startDate}</span>`,
            `<span><span class="timeline-date-label">Release</span> ${releaseDate}</span>`,
            `<span><span class="timeline-date-label">Issues</span> ${issueCount}</span>`,
          ];
          if (boardName) metaSpans.push(`<span><span class="timeline-date-label">Board</span> ${boardName}</span>`);
          if (projectDisplay) metaSpans.push(`<span><span class="timeline-date-label">Project</span> ${projectDisplay}</span>`);
          } else {
            const boardNames = collectBoardNames(bucket.issues);
            metaSpans = [
              `<span><span class="timeline-date-label">Issues</span> ${issueCount}</span>`,
            ];
            if (bucket.type === 'none') {
              metaSpans.push(`<span><span class="timeline-date-label">Status</span> No Target Version</span>`);
            } else if (bucket.type === 'manual') {
              metaSpans.push(`<span><span class="timeline-date-label">Source</span> Target Release Field</span>`);
            } else if (bucket.type === 'inherited') {
              metaSpans.push(`<span><span class="timeline-date-label">Source</span> Inherited from Epic</span>`);
            } else {
              metaSpans.push(`<span><span class="timeline-date-label">Source</span> Fix Version</span>`);
            }
            if (boardNames.length) {
              metaSpans.push(`<span><span class="timeline-date-label">Boards</span> ${boardNames.join(', ')}</span>`);
          }
        }

        const issuesHtml = issueCount
          ? `<div class="timeline-issues">${bucket.issues.map(buildTimelineIssueHtml).join('')}</div>`
          : '<div class="timeline-no-issues">No child items match the current filters.</div>';

        item.innerHTML = `
          <div class="timeline-marker"></div>
          <div class="timeline-content">
            <div class="timeline-title">${bucket.label}</div>
            <div class="timeline-dates">${metaSpans.join('')}</div>
            ${issuesHtml}
          </div>
        `;
        container.appendChild(item);
      });

    }

    function renderKpis() {
      const total = state.filteredIssues.length;
      const withTarget = state.filteredIssues.filter(i => i.hasTargetVersion).length;
      const withoutTarget = total - withTarget;
      const pct = total ? ((withTarget / total) * 100).toFixed(1) : '0.0';
      document.getElementById('kpiTotal').textContent = total;
      document.getElementById('kpiWith').textContent = withTarget;
      document.getElementById('kpiWithout').textContent = withoutTarget;
      document.getElementById('kpiPct').textContent = `${pct}%`;
      document.getElementById('kpiSection').style.display = '';
      document.getElementById('chartsSection').style.display = state.filteredIssues.length ? '' : 'none';
      document.getElementById('epicSection').style.display = '';
    }

    function buildStackedData(dimension) {
      const buckets = dimension === 'pi' ? state.aggregated.byPi : state.aggregated.byTargetVersion;
      const labels = buckets.map(b => b.label);
      const teamNames = new Set();
      buckets.forEach(bucket => {
        Object.keys(bucket.teams).forEach(team => teamNames.add(team));
      });
      const datasets = [];
      Array.from(teamNames.values()).sort().forEach(team => {
        const color = teamColor(team);
        datasets.push({
          label: `${team}  With Target`,
          data: buckets.map(bucket => (bucket.teams[team]?.withTarget || 0)),
          backgroundColor: colorWithAlpha(color, 0.85),
          stack: team,
          borderRadius: 4,
        });
        datasets.push({
          label: `${team}  Without Target`,
          data: buckets.map(bucket => (bucket.teams[team]?.withoutTarget || 0)),
          backgroundColor: colorWithAlpha(color, 0.45),
          stack: team,
          borderRadius: 4,
        });
      });
      return { labels, datasets };
    }

    function buildDistributionData(mode) {
      if (mode === 'team') {
        const labels = state.aggregated.byTeam.map(t => t.team);
        return {
          labels,
          datasets: [
            {
              label: 'With Target',
              data: state.aggregated.byTeam.map(t => t.withTarget),
              backgroundColor: '#10b981',
              stack: 'total',
              borderRadius: 4,
            },
            {
              label: 'Without Target',
              data: state.aggregated.byTeam.map(t => t.withoutTarget),
              backgroundColor: '#f97316',
              stack: 'total',
              borderRadius: 4,
            }
          ]
        };
      }
      const source = mode === 'targetVersion' ? state.aggregated.byTargetVersion : state.aggregated.byPi;
      const labels = source.map(b => b.label);
      return {
        labels,
        datasets: [
          {
            label: 'With Target',
            data: source.map(b => b.withTarget),
            backgroundColor: '#3b82f6',
            stack: 'total',
            borderRadius: 4,
          },
          {
            label: 'Without Target',
            data: source.map(b => b.withoutTarget),
            backgroundColor: '#ef4444',
            stack: 'total',
            borderRadius: 4,
          }
        ]
      };
    }

    function updateCharts() {
      if (!state.aggregated) return;
      const stackedDimension = document.querySelector('input[name="stackedDimension"]:checked').value;
      const stackedData = buildStackedData(stackedDimension);
      const distributionMode = document.getElementById('distributionMode').value;
      const distributionData = buildDistributionData(distributionMode);

      const stackedCtx = document.getElementById('stackedChart').getContext('2d');
      if (!stackedChart) {
        stackedChart = new Chart(stackedCtx, {
          type: 'bar',
          data: stackedData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { stacked: true, ticks: { autoSkip: false, maxRotation: 45, minRotation: 0 } },
              y: { stacked: true, beginAtZero: true }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: { mode: 'index', intersect: false }
            }
          }
        });
      } else {
        stackedChart.data = stackedData;
        stackedChart.update();
      }

      const distributionCtx = document.getElementById('distributionChart').getContext('2d');
      if (!distributionChart) {
        distributionChart = new Chart(distributionCtx, {
          type: 'bar',
          data: distributionData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
              x: { stacked: true, beginAtZero: true },
              y: { stacked: true }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: { mode: 'index', intersect: false }
            }
          }
        });
      } else {
        distributionChart.data = distributionData;
        distributionChart.update();
      }
    }

    function renderEpicTable() {
      const tbody = document.getElementById('epicTableBody');
      const searchInput = document.getElementById('epicSearch');
      const search = searchInput ? searchInput.value.trim().toLowerCase() : '';
      const rows = state.filteredEpics.filter(epic => {
        if (!search) return true;
        const targetLabel = formatTargetVersionLabels(epic.targetVersions);
        const values = [
          epic.key,
          epic.summary,
          epic.responsibleTeam,
          targetLabel,
          epic.pis.map(pi => pi.label).join(' '),
        ].join(' ').toLowerCase();
        return values.includes(search);
      });
      tbody.innerHTML = '';
      if (!rows.length) {
        document.getElementById('epicEmpty').style.display = '';
        return;
      }
      document.getElementById('epicEmpty').style.display = 'none';
      const domain = state.domain;
      rows.slice(0, 500).forEach(epic => {
        const boards = epic.boardIds && epic.boardIds.size
          ? Array.from(epic.boardIds).map(id => state.boardsMap.get(Number(id))?.name || `Board ${id}`).join(', ')
          : '';
        const team = epic.responsibleTeam || 'Unassigned Team';
        const piLabels = epic.pis.length ? epic.pis.map(pi => pi.label).join(', ') : '';
        const targetLabel = formatTargetVersionLabels(epic.targetVersions);
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><a href="https://${domain}/browse/${epic.key}" target="_blank" rel="noopener">${epic.key}</a></td>
          <td>${epic.summary || ''}</td>
          <td>${targetLabel}</td>
          <td>${team}</td>
          <td>${piLabels}</td>
          <td>${epic.childTotal || 0}</td>
          <td>${epic.childWithTarget || 0}</td>
          <td>${epic.childTotal ? `${epic.coveragePct}%` : ''}</td>
          <td>${boards}</td>
        `;
        tbody.appendChild(row);
      });
    }

    function updateFilterOptions() {
      const allPis = new Map();
      const teams = new Set();
      const boardOptions = new Map();
      const versions = new Map();

      state.epics.forEach(epic => {
        const targets = getAllTargetVersionsForEntity(epic);
        targets.forEach(target => {
          const key = target.key || '__none__';
          const label = target.label || 'No Target Version';
          if (!versions.has(key)) {
            versions.set(key, { value: key, label });
          }
        });

        if (!epic.pis.length) {
          if (!allPis.has('__none__')) allPis.set('__none__', { value: '__none__', label: 'No Product Increment' });
        }
        epic.pis.forEach(pi => {
          if (!allPis.has(pi.base)) {
            allPis.set(pi.base, { value: pi.base, label: pi.base });
          }
        });

        const team = epic.responsibleTeam || 'Unassigned Team';
        teams.add(team);

        if (epic.boardIds && epic.boardIds.size) {
          epic.boardIds.forEach(id => {
            const key = String(id);
            if (!boardOptions.has(key)) {
              boardOptions.set(key, { value: key, label: state.boardsMap.get(Number(id))?.name || `Board ${id}` });
            }
          });
        }
      });

      state.normalizedIssues.forEach(issue => {
        if (issue.parentKey) return;

        const targets = getAllTargetVersionsForEntity(issue, true);
        targets.forEach(target => {
          const key = target.key || '__none__';
          const label = target.label || 'No Target Version';
          if (!versions.has(key)) {
            versions.set(key, { value: key, label });
          }
        });

        if (!issue.pis || !issue.pis.length) {
          if (!allPis.has('__none__')) {
            allPis.set('__none__', { value: '__none__', label: 'No Product Increment' });
          }
        }
        (issue.pis || []).forEach(pi => {
          if (!pi || !pi.base) return;
          if (!allPis.has(pi.base)) {
            allPis.set(pi.base, { value: pi.base, label: pi.base });
          }
        });

        const team = issue.responsibleTeam || 'Unassigned Team';
        teams.add(team);

        if (issue.boardIds && issue.boardIds.size) {
          issue.boardIds.forEach(id => {
            const key = String(id);
            if (!boardOptions.has(key)) {
              boardOptions.set(key, { value: key, label: state.boardsMap.get(Number(id))?.name || `Board ${id}` });
            }
          });
        }
      });

      const versionChoices = Array.from(versions.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      if (!versionChoices.length) versionChoices.push({ value: '__none__', label: 'No Target Version' });
      targetVersionChoices.clearChoices();
      targetVersionChoices.setChoices(versionChoices, 'value', 'label', true);

      const piChoicesData = Array.from(allPis.values()).sort((a, b) => a.label.localeCompare(b.label));
      piChoices.clearChoices();
      piChoices.setChoices(piChoicesData.length ? piChoicesData : [{ value: '__none__', label: 'No Product Increment' }], 'value', 'label', true);

      const teamChoicesData = Array.from(teams.values()).sort().map(team => ({ value: team, label: team }));
      teamChoices.clearChoices();
      teamChoices.setChoices(teamChoicesData, 'value', 'label', true);

      boardFilterChoices.clearChoices();
      const boardValues = Array.from(boardOptions.values());
      boardValues.push({ value: '__unassigned__', label: 'No Board' });
      boardFilterChoices.setChoices(boardValues, 'value', 'label', true);
    }



    async function loadBoards() {
      const domain = document.getElementById('jiraDomain').value.trim();
      if (!domain) return;
      state.domain = domain;
      try {
        setLoading('Loading boards...');
        const boards = await Jira.fetchBoardsByJql(domain);
        state.boards = boards;
        state.boardsMap = new Map(boards.map(b => [Number(b.id), b]));
        boardChoices.clearChoices();
        boardChoices.setChoices(boards.map(b => ({ value: String(b.id), label: `${b.name} (${b.id})` })), 'value', 'label', true);
        boardFilterChoices.clearChoices();
        boardFilterChoices.setChoices(boards.map(b => ({ value: String(b.id), label: `${b.name} (${b.id})` })), 'value', 'label', true);
        setLoading('');
      } catch (err) {
        Logger.error('Failed to load boards', err);
        setError('Could not load boards. Check your Jira session.');
        setLoading('');
      }
    }



    async function loadData() {
      const domain = document.getElementById('jiraDomain').value.trim();
      const boardIds = boardChoices.getValue(true);
      if (!domain) {
        setError('Jira domain is required.');
        return;
      }
      if (!boardIds.length) {
        setError('Select at least one board to query.');
        return;
      }
      setError('');
      state.domain = domain;
      try {
        setLoading('Discovering fields...');
        const responsibleField = await discoverResponsibleField(domain);
        state.responsibleFieldKey = responsibleField;
        teamColorMap.clear();

        setLoading('Loading board configurations...');
        const boardConfigs = await Promise.all(boardIds.map(async id => {
          const config = await fetchBoardConfiguration(domain, id, responsibleField);
          return { ...config, name: state.boardsMap.get(Number(id))?.name || config.name || `Board ${id}` };
        }));

        setLoading('Fetching releases...');
        const releaseList = [];
        await Promise.all(boardConfigs.map(async config => {
          try {
            const values = await fetchReleasesForBoard(domain, config.id);
            values.forEach(rel => releaseList.push(rel));
          } catch (err) {
            Logger.error('Failed to load releases for board', config.id, err);
          }
        }));
        const releaseUnique = new Map();
        releaseList.forEach(rel => {
          if (!releaseUnique.has(rel.uniqueKey)) releaseUnique.set(rel.uniqueKey, rel);
        });
        state.releases = Array.from(releaseUnique.values());
        state.releaseIndex = new Map(state.releases.map(rel => [rel.uniqueKey, rel]));
        if (state.releases.length) {
          const projectIds = Array.from(new Set(state.releases.map(rel => rel.projectId).filter(Boolean)));
          await Promise.all(projectIds.map(async projectId => {
            const info = await fetchProjectDetails(domain, projectId);
            if (info) {
              state.releases.forEach(rel => {
                if (rel.projectId === projectId) {
                  rel.projectKey = info.key;
                  rel.projectName = info.name;
                }
              });
            }
          }));
        }
        document.getElementById('releasesSection').style.display = '';
        document.getElementById('releasesEmpty').style.display = 'none';

        setLoading('Fetching epics...');
        const epicMap = new Map();
        const epicsByBoard = new Map();
        await Promise.all(boardConfigs.map(async config => {
          try {
            const items = await fetchEpicsForBoard(domain, config, responsibleField);
            const teamSet = new Set((config.teams || []).map(team => String(team).trim().toLowerCase()).filter(Boolean));
            items.forEach(({ issue, boardId }) => {
              if (teamSet.size) {
                const epicTeamRaw = extractResponsibleTeam(issue.fields || {}, responsibleField);
                const epicTeam = epicTeamRaw ? epicTeamRaw.trim().toLowerCase() : '';
                if (!epicTeam || !teamSet.has(epicTeam)) {
                  return;
                }
              }
              const normalized = normalizeEpic(issue, boardId, responsibleField);
              if (epicMap.has(normalized.key)) {
                const existing = epicMap.get(normalized.key);
                normalized.boardIds.forEach(id => existing.boardIds.add(id));
              } else {
                epicMap.set(normalized.key, normalized);
              }
              if (!epicsByBoard.has(boardId)) epicsByBoard.set(boardId, new Set());
              epicsByBoard.get(boardId).add(normalized.key);
            });
          } catch (err) {
            Logger.error('Failed to load epics for board', config.id, err);
          }
        }));

        state.epics = Array.from(epicMap.values()).sort((a, b) => a.targetVersion.localeCompare(b.targetVersion, undefined, { numeric: true }));
        state.epicMap = epicMap;

        setLoading('Fetching child items...');
        const childMap = new Map();
        await Promise.all(boardConfigs.map(async config => {
          const keys = epicsByBoard.get(config.id);
          if (!keys || !keys.size) return;
          try {
            const children = await fetchChildIssuesForBoard(domain, config, Array.from(keys), responsibleField);
            children.forEach(({ issue, boardId }) => {
              const normalized = normalizeChildIssue(issue, boardId, responsibleField, epicMap);
              if (childMap.has(normalized.key)) {
                const existing = childMap.get(normalized.key);
                normalized.boardIds.forEach(id => existing.boardIds.add(id));
                if (!existing.hasTargetVersion && normalized.hasTargetVersion) {
                  existing.hasTargetVersion = true;
                  existing.targetVersion = normalized.targetVersion;
                  existing.targetVersionKey = normalized.targetVersionKey;
                  existing.targetSource = normalized.targetSource;
                }
                if (normalized.targetVersions && normalized.targetVersions.length) {
                  existing.targetVersions = normalized.targetVersions.map(target => ({ ...target }));
                }
                if (normalized.targetReleases && normalized.targetReleases.length) {
                  existing.targetReleases = normalized.targetReleases.slice();
                }
              } else {
                childMap.set(normalized.key, normalized);
              }
            });
          } catch (err) {
            Logger.error('Failed to load child issues for board', config.id, err);
          }
        }));

        setLoading('Fetching stand-alone items...');
        await Promise.all(boardConfigs.map(async config => {
          try {
            const standalone = await fetchStandaloneIssuesForBoard(domain, config, responsibleField);
            standalone.forEach(({ issue, boardId }) => {
              const normalized = normalizeChildIssue(issue, boardId, responsibleField, epicMap);
              if (childMap.has(normalized.key)) {
                const existing = childMap.get(normalized.key);
                normalized.boardIds.forEach(id => existing.boardIds.add(id));
                if (!existing.hasTargetVersion && normalized.hasTargetVersion) {
                  existing.hasTargetVersion = true;
                  existing.targetVersion = normalized.targetVersion;
                  existing.targetVersionKey = normalized.targetVersionKey;
                  existing.targetSource = normalized.targetSource;
                }
                if (normalized.targetVersions && normalized.targetVersions.length) {
                  existing.targetVersions = normalized.targetVersions.map(target => ({ ...target }));
                }
                if (normalized.targetReleases && normalized.targetReleases.length) {
                  existing.targetReleases = normalized.targetReleases.slice();
                }
                if (!existing.parentKey && normalized.parentKey) {
                  existing.parentKey = normalized.parentKey;
                  existing.parentSummary = normalized.parentSummary;
                  existing.parentTargetVersion = normalized.parentTargetVersion;
                  existing.parentTargetVersionKey = normalized.parentTargetVersionKey;
                  existing.parentTargetVersions = normalized.parentTargetVersions?.map(target => ({ ...target })) || existing.parentTargetVersions;
                  existing.parentPis = normalized.parentPis;
                }
              } else {
                childMap.set(normalized.key, normalized);
              }
            });
          } catch (err) {
            Logger.error('Failed to load stand-alone issues for board', config.id, err);
          }
        }));

        state.normalizedIssues = Array.from(childMap.values());
        computeEpicCoverage(state.epics, state.normalizedIssues);
        updateFilterOptions();
        document.getElementById('filtersSection').style.display = '';
        document.getElementById('kpiSection').style.display = '';
        document.getElementById('chartsSection').style.display = state.normalizedIssues.length ? '' : 'none';
        document.getElementById('epicSection').style.display = '';

        setLoading('Applying filters...');
        state.filteredEpics = state.epics.slice();
        state.filteredIssues = state.normalizedIssues.slice();
        state.aggregated = aggregateIssues(state.normalizedIssues);
        applyFilters();
        setLoading('');
      } catch (err) {
        Logger.error('Failed to load planning data', err);
        setError('Could not fetch planning data. Verify your Jira permissions and filters.');
        setLoading('');
      }
    }

    async function exportPDF() {
      const content = document.getElementById('pdfContent');
      const canvas = await html2canvas(content, { scale: 2, useCORS: true });
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
      const imgWidth = canvas.width * ratio;
      const imgHeight = canvas.height * ratio;
      pdf.addImage(imgData, 'PNG', (pageWidth - imgWidth) / 2, 20, imgWidth, imgHeight);
      pdf.save('pi-target-version-dashboard.pdf');
    }

    function switchVersion(page) {
      if (!page) return;
      window.location.href = page;
    }

    function initVersionSelect() {
      const select = document.getElementById('versionSelect');
      if (!select) return;
      select.value = 'target_release_dashboard.html';
      select.addEventListener('change', (event) => switchVersion(event.target.value));
    }

    document.getElementById('loadDataBtn').addEventListener('click', loadData);
    document.getElementById('exportBtn').addEventListener('click', exportPDF);
    document.getElementById('jiraDomain').addEventListener('change', loadBoards);
    document.getElementById('epicSearch').addEventListener('input', () => renderEpicTable());
    document.getElementById('releaseSearch').addEventListener('input', () => renderReleasesTimeline());
    document.querySelectorAll('input[name="stackedDimension"]').forEach(input => input.addEventListener('change', updateCharts));
    document.getElementById('distributionMode').addEventListener('change', updateCharts);
    ['suffixCommitted', 'suffixPlanned', 'suffixSpillover'].forEach(id => {
      document.getElementById(id).addEventListener('change', applyFilters);
    });

    function setupFilterReactivity() {
      ['teamSelect', 'boardFilterSelect', 'piSelect', 'targetVersionSelect'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('change', () => {
          applyFilters();
        });
      });
    }

    initVersionSelect();
    initChoices();
    setupFilterReactivity();
    loadBoards();
  </script>
</body>
</html>
