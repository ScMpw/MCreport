<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PI & Target Version Planning Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <link rel="stylesheet" href="public/tailwind.css">
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    html { background: #f7f8fa; }
    body { background: #f7f8fa; font-family: 'Inter', Arial, sans-serif; margin:0; padding:0; }
    .main { max-width: 1200px; margin: 30px auto 40px auto; background: #fff; border-radius: 18px; box-shadow: 0 2px 12px #d1d5db70; padding: 36px 32px 48px 32px; }
    h1 { font-size: 2.2em; margin:0 0 0.7em 0; font-weight: 600; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: flex-end; margin-bottom: 20px; }
    .controls label { display:flex; flex-direction:column; font-size:0.95em; color:#374151; }
    .controls input, .controls select { padding:7px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:0.95em; }
    .btn { background:#6366f1; color:#fff; border:none; border-radius:8px; padding:9px 18px; cursor:pointer; font-size:0.95em; font-weight:600; transition: background 0.15s ease; }
    .btn.secondary { background:#f3f4f6; color:#374151; }
    .btn:disabled { background:#c4c6f5; cursor: default; }
    .section-title { font-size: 1.2em; font-weight:600; margin: 30px 0 14px; color:#111827; }
    .filters { background:#f9fafb; border:1px solid #e5e7eb; border-radius:16px; padding:20px 24px; display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:18px; }
    .filter-block label { font-size:0.85em; color:#6b7280; margin-bottom:6px; display:block; font-weight:600; text-transform:uppercase; letter-spacing:0.02em; }
    .filter-block select { width:100%; }
    .suffix-toggles { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }
    .suffix-toggles label { background:#e0e7ff; color:#4338ca; padding:4px 10px; border-radius:999px; font-size:0.82em; display:flex; align-items:center; gap:6px; font-weight:600; }
    .suffix-toggles input { margin:0; }
    .kpi-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:16px; margin-top:20px; }
    .kpi-card { background:#f9fafb; border:1px solid #e5e7eb; border-radius:16px; padding:18px 20px; box-shadow: inset 0 1px 0 #fff; }
    .kpi-label { font-size:0.9em; color:#6b7280; text-transform:uppercase; letter-spacing:0.04em; margin-bottom:6px; font-weight:600; }
    .kpi-value { font-size:2em; font-weight:600; color:#111827; }
    .chart-section { margin-top:32px; }
    .chart-wrapper { background:#fff; border-radius:16px; border:1px solid #e5e7eb; padding:20px; box-shadow: 0 2px 6px #e5e7f070; }
    .chart-toolbar { display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px; margin-bottom:10px; }
    .chart-toolbar .toggle-group label { margin-right:12px; font-size:0.92em; color:#374151; font-weight:600; }
    .chart-toolbar .toggle-group input { margin-right:4px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #e5e7eb; padding:8px 10px; font-size:0.9em; text-align:left; }
    th { background:#f3f4f6; text-transform:uppercase; font-size:0.76em; letter-spacing:0.06em; color:#4b5563; }
    .table-controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; flex-wrap:wrap; gap:10px; }
    .table-controls input { padding:7px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:0.9em; }
    .badge { background:#e5e7eb; border-radius:999px; padding:2px 10px; font-size:0.78em; font-weight:600; color:#374151; }
    .status-pill { border-radius:999px; padding:2px 10px; font-size:0.78em; font-weight:600; color:#fff; display:inline-block; }
    .status-pill.default { background:#6b7280; }
    .status-pill.done { background:#10b981; }
    .status-pill.progress { background:#6366f1; }
    .status-pill.blocked { background:#ef4444; }
    .empty-state { background:#f9fafb; border:1px dashed #cbd5f5; border-radius:12px; padding:30px; text-align:center; color:#6b7280; font-size:0.95em; margin-top:20px; }
    .loading { margin:14px 0; font-weight:600; color:#4338ca; }
    .error { margin:14px 0; font-weight:600; color:#dc2626; }
    @media (max-width: 840px) {
      .controls { flex-direction:column; align-items:flex-start; }
      .chart-toolbar { flex-direction:column; align-items:flex-start; }
    }
  </style>
</head>
<body>
  <div class="main" id="pdfContent">
    <h1>PI & Target Version Planning Dashboard</h1>
    <div style="margin-bottom:14px;">
      <label>Version:
        <select id="versionSelect">
          <option value="index.html">Velocity</option>
          <option value="index_throughput.html">Throughput</option>
          <option value="index_throughput_week.html">Weekly Throughput</option>
          <option value="index_disruption.html">Disruption</option>
          <option value="KPI_Report.html">KPI Report</option>
          <option value="target_release_dashboard.html">PI &amp; Target Version Planning Dashboard</option>
        </select>
      </label>
    </div>
    <div class="controls">
      <label>Jira Domain
        <input id="jiraDomain" value="aldi-sued.atlassian.net" placeholder="your-domain.atlassian.net">
      </label>
      <label style="flex:1; min-width:220px;">Boards
        <select id="boardSelect" multiple></select>
      </label>
      <button class="btn" id="loadDataBtn">Load Planning Data</button>
      <button class="btn secondary" id="exportBtn">Export as PDF</button>
    </div>
    <div id="loadingMessage" class="loading" style="display:none;"></div>
    <div id="errorMessage" class="error" style="display:none;"></div>

    <div id="filtersSection" style="display:none;">
      <div class="section-title">Filters</div>
      <div class="filters">
        <div class="filter-block">
          <label for="targetVersionSelect">Target Versions</label>
          <select id="targetVersionSelect" multiple></select>
          <div style="font-size:0.78em; color:#6b7280; margin-top:6px;">Defaults to all target versions from open epics.</div>
        </div>
        <div class="filter-block">
          <label for="piSelect">Product Increments</label>
          <select id="piSelect" multiple></select>
          <div class="suffix-toggles">
            <label><input type="checkbox" id="suffixCommitted" checked> Committed</label>
            <label><input type="checkbox" id="suffixPlanned" checked> Planned</label>
            <label><input type="checkbox" id="suffixSpillover" checked> Spillover</label>
          </div>
        </div>
        <div class="filter-block">
          <label for="teamSelect">Responsible Teams</label>
          <select id="teamSelect" multiple></select>
        </div>
        <div class="filter-block">
          <label for="boardFilterSelect">Boards (Filter)</label>
          <select id="boardFilterSelect" multiple></select>
        </div>
      </div>
    </div>

    <div id="kpiSection" style="display:none;">
      <div class="section-title">Key Metrics</div>
      <div class="kpi-grid">
        <div class="kpi-card">
          <div class="kpi-label">Total Items</div>
          <div class="kpi-value" id="kpiTotal">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">With Target Version</div>
          <div class="kpi-value" id="kpiWith">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">Without Target Version</div>
          <div class="kpi-value" id="kpiWithout">0</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">% With Target Version</div>
          <div class="kpi-value" id="kpiPct">0%</div>
        </div>
      </div>
    </div>

    <div id="releasesSection" style="display:none;">
      <div class="section-title">Upcoming Releases</div>
      <div class="table-controls">
        <div style="font-size:0.85em; color:#6b7280;">Unreleased or future-dated versions from the selected boards.</div>
        <input id="releaseSearch" placeholder="Search by release, board or project...">
      </div>
      <div class="table-wrap" style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Release</th>
              <th>Board</th>
              <th>Project</th>
              <th>Status</th>
              <th>Start</th>
              <th>Release Date</th>
              <th>Issues Planned</th>
              <th>With Target</th>
              <th>Coverage</th>
            </tr>
          </thead>
          <tbody id="releasesTableBody"></tbody>
        </table>
      </div>
      <div id="releasesEmpty" class="empty-state" style="display:none;">No upcoming releases were found for the selected boards.</div>
    </div>

    <div id="epicSection" style="display:none;">
      <div class="section-title">Open Epics</div>
      <div class="table-controls">
        <div style="font-size:0.85em; color:#6b7280;">Epics grouped by target version for the selected boards.</div>
        <input id="epicSearch" placeholder="Search by epic, summary, target version...">
      </div>
      <div class="table-wrap" style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Epic</th>
              <th>Summary</th>
              <th>Target Version</th>
              <th>Responsible Team</th>
              <th>Product Increments</th>
              <th>Child Items</th>
              <th>With Target</th>
              <th>Coverage</th>
              <th>Boards</th>
            </tr>
          </thead>
          <tbody id="epicTableBody"></tbody>
        </table>
      </div>
      <div id="epicEmpty" class="empty-state" style="display:none;">No epics match the current filters.</div>
    </div>

    <div id="chartsSection" style="display:none;">
      <div class="section-title">Target Version Coverage</div>
      <div class="chart-section">
        <div class="chart-toolbar">
          <div class="toggle-group">
            <label><input type="radio" name="stackedDimension" value="targetVersion" checked> By Target Version</label>
            <label><input type="radio" name="stackedDimension" value="pi"> By Product Increment</label>
          </div>
          <div style="font-size:0.85em; color:#6b7280;">Stacks display with/without target version per responsible team.</div>
        </div>
        <div class="chart-wrapper">
          <canvas id="stackedChart" height="360"></canvas>
        </div>
      </div>

      <div class="chart-section" style="margin-top:36px;">
        <div class="chart-toolbar">
          <div class="toggle-group">
            <label for="distributionMode">Distribution View:</label>
            <select id="distributionMode">
              <option value="team">By Team</option>
              <option value="targetVersion">By Target Version</option>
              <option value="pi">By Product Increment</option>
            </select>
          </div>
          <div style="font-size:0.85em; color:#6b7280;">Shows ratio of issues with/without target versions.</div>
        </div>
        <div class="chart-wrapper">
          <canvas id="distributionChart" height="360"></canvas>
        </div>
      </div>
    </div>

    <div id="childSection" style="display:none; margin-top:40px;">
      <div class="section-title">Child Items</div>
      <div class="table-controls">
        <div style="font-size:0.85em; color:#6b7280;">Displaying child issues for the filtered epics. Use search to refine.</div>
        <input id="childSearch" placeholder="Search by key, summary, epic, team...">
      </div>
      <div class="table-wrap" style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Key</th>
              <th>Summary</th>
              <th>Epic</th>
              <th>Type</th>
              <th>Status</th>
              <th>Responsible Team</th>
              <th>Epic Target Version</th>
              <th>Issue Target Version</th>
              <th>Boards</th>
              <th>Assignee</th>
              <th>Updated</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="childTableBody"></tbody>
        </table>
      </div>
      <div id="childEmpty" class="empty-state" style="display:none;">No child items match the current filters.</div>
    </div>
  </div>

  <script src="src/logger.js"></script>
  <script src="src/jira.js"></script>
  <script>
    Logger.setLevel('info');

    const state = {
      domain: '',
      boards: [],
      boardsMap: new Map(),
      normalizedIssues: [],
      responsibleFieldKey: 'responsible-team',
      filteredIssues: [],
      aggregated: null,
      releases: [],
      releaseIndex: new Map(),
      epics: [],
      epicMap: new Map(),
      filteredEpics: [],
    };

    let boardChoices, targetVersionChoices, piChoices, teamChoices, boardFilterChoices;
    let stackedChart, distributionChart;
    const teamColorMap = new Map();
    const palette = ['#6366f1', '#ec4899', '#10b981', '#f97316', '#14b8a6', '#8b5cf6', '#f59e0b', '#ef4444', '#3b82f6', '#22c55e'];

    function initChoices() {
      boardChoices = new Choices('#boardSelect', { removeItemButton: true, shouldSort: false });
      targetVersionChoices = new Choices('#targetVersionSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'All target versions' });
      piChoices = new Choices('#piSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'Select Product Increments' });
      teamChoices = new Choices('#teamSelect', { removeItemButton: true, shouldSort: true, placeholder: true, placeholderValue: 'All teams' });
      boardFilterChoices = new Choices('#boardFilterSelect', { removeItemButton: true, shouldSort: false });
    }

    function setLoading(message) {
      const el = document.getElementById('loadingMessage');
      if (message) {
        el.textContent = message;
        el.style.display = '';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function setError(message) {
      const el = document.getElementById('errorMessage');
      if (message) {
        el.textContent = message;
        el.style.display = '';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    async function fetchWithRetry(url, options = {}, retries = 3, baseDelay = 800) {
      let attempt = 0;
      while (true) {
        try {
          const resp = await fetch(url, { credentials: 'include', ...options });
          if (resp.status === 429 && attempt < retries) {
            const retryAfter = Number(resp.headers.get('Retry-After'));
            const delay = Number.isFinite(retryAfter) ? retryAfter * 1000 : baseDelay * Math.pow(2, attempt);
            Logger.warn('Rate limited, retrying', url, 'delay', delay);
            await sleep(delay);
            attempt++;
            continue;
          }
          if (!resp.ok) {
            const error = new Error(`Request failed ${resp.status}`);
            error.status = resp.status;
            throw error;
          }
          return resp;
        } catch (err) {
          Logger.error('Request error', url, err);
          if (attempt >= retries) throw err;
          await sleep(baseDelay * Math.pow(2, attempt));
          attempt++;
        }
      }
    }

    const releaseCache = new Map();
    const projectCache = new Map();
    const boardConfigCache = new Map();

    async function fetchBoardConfiguration(domain, boardId) {
      const cacheKey = `${domain}:board-config:${boardId}`;
      if (boardConfigCache.has(cacheKey)) return boardConfigCache.get(cacheKey);

      const promise = (async () => {
        const url = `https://${domain}/rest/agile/1.0/board/${boardId}/configuration`;
        const resp = await fetchWithRetry(url);
        const data = await resp.json();
        return {
          id: Number(boardId),
          name: data?.name,
          filterQuery: data?.filter?.query || '',
        };
      })();

      boardConfigCache.set(cacheKey, promise);
      return promise;
    }

    async function fetchReleasesForBoard(domain, boardId) {
      const cacheKey = `${domain}:releases:${boardId}`;
      if (releaseCache.has(cacheKey)) return releaseCache.get(cacheKey);

      const promise = (async () => {
        const results = [];
        let startAt = 0;
        const maxResults = 50;
        for (let loop = 0; loop < 40; loop++) {
          const url = `https://${domain}/rest/agile/1.0/board/${boardId}/version?startAt=${startAt}&maxResults=${maxResults}`;
          const resp = await fetchWithRetry(url);
          const data = await resp.json();
          const values = data.values || [];
          values.forEach(v => {
            const normalized = {
              id: v.id ? String(v.id) : undefined,
              uniqueKey: v.id ? String(v.id) : (v.name ? `name:${v.name}` : `board:${boardId}:${startAt}`),
              name: v.name || 'Unnamed Release',
              released: Boolean(v.released),
              archived: Boolean(v.archived),
              releaseDate: v.releaseDate || v.userReleaseDate || null,
              startDate: v.startDate || v.userStartDate || null,
              projectId: v.projectId !== undefined ? Number(v.projectId) : undefined,
              boardId: Number(boardId),
            };
            results.push(normalized);
          });
          startAt += values.length;
          if (data.isLast || !values.length) break;
        }
        return results;
      })();

      releaseCache.set(cacheKey, promise);
      return promise;
    }

    async function fetchProjectDetails(domain, projectId) {
      if (!projectId) return null;
      const key = `${domain}:project:${projectId}`;
      if (projectCache.has(key)) return projectCache.get(key);

      const promise = (async () => {
        const url = `https://${domain}/rest/api/3/project/${projectId}`;
        try {
          const resp = await fetchWithRetry(url);
          const data = await resp.json();
          return {
            key: data.key || undefined,
            name: data.name || undefined,
          };
        } catch (err) {
          Logger.warn('Failed to fetch project details', projectId, err);
          return null;
        }
      })();

      projectCache.set(key, promise);
      return promise;
    }

    const fieldCache = new Map();
    async function discoverResponsibleField(domain) {
      if (fieldCache.has(domain)) return fieldCache.get(domain);
      const promise = (async () => {
        const url = `https://${domain}/rest/api/3/field`;
        const resp = await fetchWithRetry(url);
        const fields = await resp.json();
        let fieldKey = 'responsible-team';
        if (Array.isArray(fields)) {
          const normalized = fields.map(f => ({
            key: f.key || f.id,
            name: (f.name || '').toLowerCase(),
          }));
          const exact = normalized.find(f => f.key === 'responsible-team');
          if (exact) {
            fieldKey = exact.key;
          } else {
            const candidate = normalized.find(f => /responsible[\s-]?team/.test(f.name));
            if (candidate && candidate.key) {
              fieldKey = candidate.key;
            }
          }
        }
        return fieldKey;
      })();
      fieldCache.set(domain, promise);
      return promise;
    }

    async function jiraSearch(domain, payload) {
      const searchUrl = `https://${domain}/rest/api/3/search/jql`;
      const fieldList = Array.isArray(payload.fields) ? payload.fields.filter(Boolean) : [];
      const expandList = Array.isArray(payload.expand) ? payload.expand.filter(Boolean) : [];
      let useGet = true;

      const buildQuery = () => {
        const params = new URLSearchParams();
        params.set('jql', payload.jql);
        params.set('startAt', String(payload.startAt || 0));
        params.set('maxResults', String(payload.maxResults || 50));
        if (fieldList.length) params.set('fields', fieldList.join(','));
        if (expandList.length) params.set('expand', expandList.join(','));
        return params.toString();
      };

      const buildBody = () => {
        const body = {
          jql: payload.jql,
          startAt: payload.startAt || 0,
          maxResults: payload.maxResults || 50,
        };
        if (fieldList.length) body.fields = fieldList;
        if (expandList.length) body.expand = expandList;
        return JSON.stringify(body);
      };

      while (true) {
        try {
          if (useGet) {
            return await fetchWithRetry(`${searchUrl}?${buildQuery()}`, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
              },
            }).then(r => r.json());
          }
          return await fetchWithRetry(searchUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              'X-Atlassian-Token': 'no-check',
            },
            body: buildBody(),
          }).then(r => r.json());
        } catch (err) {
          if (useGet) {
            const status = err?.status;
            if (status && [405, 413, 414].includes(status)) {
              Logger.warn(`Jira search GET returned status ${status}, retrying with POST.`);
              useGet = false;
              continue;
            }
            Logger.warn('Jira search GET failed, retrying with POST', err);
            useGet = false;
            continue;
          }
          throw err;
        }
      }
    }

    async function fetchEpicsForBoard(domain, boardConfig, responsibleField) {
      const fields = [
        'key',
        'summary',
        'issuetype',
        'status',
        'assignee',
        'labels',
        'fixVersions',
        'target-release',
        'project',
        'updated',
      ];
      if (responsibleField && responsibleField !== 'responsible-team') {
        fields.push(responsibleField);
      } else {
        fields.push('responsible-team');
      }

      const baseJql = boardConfig.filterQuery ? `(${boardConfig.filterQuery}) AND ` : '';
      const projectClause = '(project in (ANP, NPSCO, BF))';
      const jql = `${baseJql}${projectClause} AND issuetype = Epic AND statusCategory != Done`;

      const results = [];
      let startAt = 0;
      const maxResults = 100;
      for (let page = 0; page < 200; page++) {
        const data = await jiraSearch(domain, {
          jql,
          startAt,
          maxResults,
          fields,
        });
        const issues = data.issues || [];
        issues.forEach(issue => results.push({ issue, boardId: boardConfig.id }));
        startAt += issues.length;
        if (startAt >= (data.total || 0) || !issues.length) break;
      }
      return results;
    }

    async function fetchChildIssuesForBoard(domain, boardConfig, epicKeys, responsibleField) {
      if (!epicKeys.length) return [];
      const fields = [
        'key',
        'summary',
        'issuetype',
        'status',
        'assignee',
        'labels',
        'fixVersions',
        'target-release',
        'project',
        'updated',
        'customfield_10014',
        'parent',
      ];
      if (responsibleField && responsibleField !== 'responsible-team') {
        fields.push(responsibleField);
      } else {
        fields.push('responsible-team');
      }

      const baseJql = boardConfig.filterQuery ? `(${boardConfig.filterQuery}) AND ` : '';
      const chunkSize = 40;
      const results = [];
      for (let i = 0; i < epicKeys.length; i += chunkSize) {
        const chunk = epicKeys.slice(i, i + chunkSize);
        const formattedKeys = chunk.map(key => `'${String(key).replace(/'/g, "\\'")}'`).join(',');
        const projectClause = '(project in (ANP, NPSCO, BF))';
        const jql = `${baseJql}${projectClause} AND "Epic Link" in (${formattedKeys})`;
        let startAt = 0;
        const maxResults = 100;
        for (let page = 0; page < 200; page++) {
          const data = await jiraSearch(domain, {
            jql,
            startAt,
            maxResults,
            fields,
          });
          const issues = data.issues || [];
          issues.forEach(issue => results.push({ issue, boardId: boardConfig.id }));
          startAt += issues.length;
          if (startAt >= (data.total || 0) || !issues.length) break;
        }
      }
      return results;
    }

    // Planning helpers will be defined below.

    function parseTargetReleaseValue(raw) {
      if (!raw) return undefined;
      if (typeof raw === 'string') return raw;
      if (Array.isArray(raw)) {
        const first = raw[0];
        if (!first) return undefined;
        if (typeof first === 'string') return first;
        if (typeof first === 'object') return first.name || first.value || undefined;
      }
      if (typeof raw === 'object') return raw.name || raw.value || undefined;
      return undefined;
    }

    function parseFixVersions(raw) {
      if (!Array.isArray(raw) || !raw.length) return [];
      const seen = new Set();
      const versions = [];
      raw.forEach(version => {
        if (!version) return;
        const id = version.id ? String(version.id) : undefined;
        const name = version.name ? String(version.name) : undefined;
        const key = id || (name ? `name:${name}` : undefined);
        if (!key || seen.has(key)) return;
        seen.add(key);
        versions.push({
          id,
          key,
          name: name || 'Unnamed Release',
          released: Boolean(version.released),
          releaseDate: version.releaseDate || version.userReleaseDate || undefined,
          startDate: version.startDate || version.userStartDate || undefined,
        });
      });
      return versions;
    }

    function extractResponsibleTeam(fields, responsibleFieldKey) {
      const responsibleValue = fields?.[responsibleFieldKey] ?? fields?.['responsible-team'];
      if (!responsibleValue) return undefined;
      if (typeof responsibleValue === 'string') return responsibleValue;
      if (Array.isArray(responsibleValue)) {
        return responsibleValue.find(val => typeof val === 'string');
      }
      if (typeof responsibleValue === 'object') {
        return responsibleValue.value || responsibleValue.name || responsibleValue.title || undefined;
      }
      return undefined;
    }

    function extractPis(labels) {
      if (!Array.isArray(labels) || !labels.length) return [];
      const matches = [];
      const seen = new Set();
      labels.forEach(label => {
        if (typeof label !== 'string') return;
        const trimmed = label.trim();
        const match = trimmed.match(/^(pi\d{2})(?:[_-](committed|planned|spillover))?$/i);
        if (!match) return;
        const base = match[1].toLowerCase();
        const suffix = match[2] ? match[2].toLowerCase() : null;
        const key = suffix ? `${base}_${suffix}` : base;
        if (seen.has(key)) return;
        seen.add(key);
        matches.push({ base, suffix: suffix === 'committed' || suffix === 'planned' || suffix === 'spillover' ? suffix : null, label: suffix ? `${base}_${suffix}` : base });
      });
      return matches;
    }

    function determineTargetVersion(fixVersions, targetRelease) {
      if (Array.isArray(fixVersions) && fixVersions.length) {
        const version = fixVersions[0];
        const key = version.key || (version.name ? `name:${version.name}` : undefined) || '__none__';
        const label = version.name || 'Unnamed Release';
        return { key, label, hasValue: true, source: 'fixVersion' };
      }
      if (targetRelease) {
        return { key: `target:${targetRelease}`, label: targetRelease, hasValue: true, source: 'target-release' };
      }
      return { key: '__none__', label: 'No Target Version', hasValue: false, source: 'none' };
    }

    function normalizeEpic(issue, boardId, responsibleFieldKey) {
      const fields = issue.fields || {};
      const labels = Array.isArray(fields.labels) ? fields.labels.slice() : [];
      const pis = extractPis(labels);
      const fixVersions = parseFixVersions(fields.fixVersions);
      const targetRelease = parseTargetReleaseValue(fields['target-release']);
      const targetInfo = determineTargetVersion(fixVersions, targetRelease);
      const responsibleTeam = extractResponsibleTeam(fields, responsibleFieldKey);

      return {
        id: String(issue.id || issue.key || ''),
        key: String(issue.key || ''),
        summary: String(fields.summary || ''),
        status: fields.status?.name ? String(fields.status.name) : 'Unknown',
        assignee: fields.assignee?.displayName ? String(fields.assignee.displayName) : undefined,
        responsibleTeam: responsibleTeam || undefined,
        boardIds: new Set([Number(boardId)]),
        fixVersions,
        targetRelease: targetRelease || undefined,
        targetVersion: targetInfo.label,
        targetVersionKey: targetInfo.key,
        hasTargetVersion: targetInfo.hasValue,
        targetSource: targetInfo.source,
        pis,
        labels,
        updated: fields.updated ? String(fields.updated) : undefined,
        project: fields.project?.name ? String(fields.project.name) : undefined,
        childTotal: 0,
        childWithTarget: 0,
        childWithoutTarget: 0,
        coveragePct: 0,
      };
    }

    function extractEpicLink(fields) {
      if (!fields) return undefined;
      if (typeof fields.epicLink === 'string') return fields.epicLink;
      if (typeof fields['Epic Link'] === 'string') return fields['Epic Link'];
      if (fields.customfield_10014) {
        if (typeof fields.customfield_10014 === 'string') return fields.customfield_10014;
        if (typeof fields.customfield_10014 === 'object' && fields.customfield_10014.key) {
          return String(fields.customfield_10014.key);
        }
      }
      if (fields.parent?.key && fields.parent?.fields?.issuetype?.name === 'Epic') {
        return String(fields.parent.key);
      }
      return undefined;
    }

    function normalizeChildIssue(issue, boardId, responsibleFieldKey, epicMap) {
      const fields = issue.fields || {};
      const epicKey = extractEpicLink(fields);
      const parent = epicKey ? epicMap.get(epicKey) : undefined;
      if (!epicKey) {
        Logger.warn('Skipping issue without epic link', issue.key);
      }
      const labels = Array.isArray(fields.labels) ? fields.labels.slice() : [];
      if (parent?.labels) {
        parent.labels.forEach(label => {
          if (typeof label === 'string' && !labels.includes(label)) labels.push(label);
        });
      }
      const pis = extractPis(labels);
      const fixVersions = parseFixVersions(fields.fixVersions);
      const targetRelease = parseTargetReleaseValue(fields['target-release']);
      const targetInfo = determineTargetVersion(fixVersions, targetRelease);
      const responsibleTeam = parent?.responsibleTeam || extractResponsibleTeam(fields, responsibleFieldKey);

      return {
        id: String(issue.id || issue.key || ''),
        key: String(issue.key || ''),
        summary: String(fields.summary || ''),
        type: fields.issuetype?.name ? String(fields.issuetype.name) : 'Unknown',
        status: fields.status?.name ? String(fields.status.name) : 'Unknown',
        assignee: fields.assignee?.displayName ? String(fields.assignee.displayName) : undefined,
        responsibleTeam: responsibleTeam || undefined,
        boardIds: new Set([Number(boardId)]),
        fixVersions,
        targetRelease: targetRelease || undefined,
        targetVersion: targetInfo.label,
        targetVersionKey: targetInfo.key,
        hasTargetVersion: targetInfo.hasValue,
        targetSource: targetInfo.source,
        parentKey: epicKey || parent?.key,
        parentSummary: parent?.summary,
        parentTargetVersion: parent?.targetVersion || 'No Target Version',
        parentTargetVersionKey: parent?.targetVersionKey || '__none__',
        parentPis: parent?.pis?.length ? parent.pis.slice() : (pis.length ? pis : []),
        pis,
        project: fields.project?.name ? String(fields.project.name) : undefined,
        updated: fields.updated ? String(fields.updated) : undefined,
      };
    }

    function computeEpicCoverage(epics, issues) {
      const map = new Map(epics.map(epic => [epic.key, epic]));
      epics.forEach(epic => {
        epic.childTotal = 0;
        epic.childWithTarget = 0;
        epic.childWithoutTarget = 0;
        epic.coveragePct = 0;
      });
      issues.forEach(issue => {
        if (!issue.parentKey) return;
        const epic = map.get(issue.parentKey);
        if (!epic) return;
        epic.childTotal += 1;
        if (issue.hasTargetVersion) epic.childWithTarget += 1; else epic.childWithoutTarget += 1;
      });
      epics.forEach(epic => {
        epic.coveragePct = computePct(epic.childWithTarget, epic.childTotal);
      });
    }

    function computePct(withTarget, total) {
      if (!total) return 0;
      return Number(((withTarget / total) * 100).toFixed(1));
    }

    function aggregateIssues(issues) {
      const fallbackVersion = { key: '__none__', label: 'No Target Version' };
      const fallbackPi = { key: 'no-pi', label: 'No Product Increment' };
      const fallbackTeam = 'Unassigned Team';

      function ensureBucket(map, key, label) {
        if (!map.has(key)) {
          map.set(key, {
            key,
            label,
            total: 0,
            withTarget: 0,
            withoutTarget: 0,
            pctWith: 0,
            teams: {},
          });
        }
        return map.get(key);
      }

      function ensureTeam(bucket, team) {
        if (!bucket.teams[team]) {
          bucket.teams[team] = { team, total: 0, withTarget: 0, withoutTarget: 0, pctWith: 0 };
        }
        return bucket.teams[team];
      }

      function addIssue(bucket, issue, teamName) {
        bucket.total += 1;
        if (issue.hasTargetVersion) bucket.withTarget += 1; else bucket.withoutTarget += 1;
        const teamAgg = ensureTeam(bucket, teamName);
        teamAgg.total += 1;
        if (issue.hasTargetVersion) teamAgg.withTarget += 1; else teamAgg.withoutTarget += 1;
      }

      function finalizeBucket(bucket) {
        bucket.pctWith = computePct(bucket.withTarget, bucket.total);
        Object.values(bucket.teams).forEach(team => {
          team.pctWith = computePct(team.withTarget, team.total);
        });
      }

      const versionBuckets = new Map();
      const piBuckets = new Map();
      const teamBuckets = new Map();
      let total = 0;
      let withTarget = 0;

      issues.forEach(issue => {
        const teamName = issue.responsibleTeam || fallbackTeam;
        const versionKey = issue.parentTargetVersionKey || fallbackVersion.key;
        const versionLabel = issue.parentTargetVersion || fallbackVersion.label;
        const versionBucket = ensureBucket(versionBuckets, versionKey, versionLabel);
        addIssue(versionBucket, issue, teamName);

        const piValues = issue.parentPis && issue.parentPis.length ? issue.parentPis : [fallbackPi];
        const seenPi = new Set();
        piValues.forEach(pi => {
          const value = pi && pi.label ? pi.label : fallbackPi.label;
          if (seenPi.has(value)) return;
          seenPi.add(value);
          const bucket = ensureBucket(piBuckets, value, value);
          addIssue(bucket, issue, teamName);
        });

        if (!teamBuckets.has(teamName)) {
          teamBuckets.set(teamName, { team: teamName, total: 0, withTarget: 0, withoutTarget: 0, pctWith: 0 });
        }
        const teamBucket = teamBuckets.get(teamName);
        teamBucket.total += 1;
        if (issue.hasTargetVersion) teamBucket.withTarget += 1; else teamBucket.withoutTarget += 1;

        total += 1;
        if (issue.hasTargetVersion) withTarget += 1;
      });

      const byTargetVersion = Array.from(versionBuckets.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      byTargetVersion.forEach(finalizeBucket);

      const byPi = Array.from(piBuckets.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      byPi.forEach(finalizeBucket);

      const byTeam = Array.from(teamBuckets.values()).sort((a, b) => a.team.localeCompare(b.team));
      byTeam.forEach(team => { team.pctWith = computePct(team.withTarget, team.total); });

      return {
        total,
        withTarget,
        withoutTarget: total - withTarget,
        pctWith: computePct(withTarget, total),
        byTargetVersion,
        byPi,
        byTeam,
      };
    }

    function teamColor(team) {
      if (!teamColorMap.has(team)) {
        const idx = teamColorMap.size % palette.length;
        teamColorMap.set(team, palette[idx]);
      }
      return teamColorMap.get(team);
    }

    function colorWithAlpha(hex, alpha) {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function formatDate(value) {
      if (!value) return '';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return value;
      return date.toLocaleDateString();
    }

    function getStatusClass(status) {
      if (!status) return 'default';
      const lower = status.toLowerCase();
      if (lower.includes('done') || lower.includes('closed')) return 'done';
      if (lower.includes('progress') || lower.includes('in progress')) return 'progress';
      if (lower.includes('block')) return 'blocked';
      return 'default';
    }

    function applyFilters() {
      if (!state.epics.length) {
        state.filteredEpics = [];
        state.filteredIssues = [];
        state.aggregated = aggregateIssues([]);
        renderKpis();
        renderEpicTable();
        renderChildTable();
        renderReleasesTable();
        setLoading('No epics found for the selected boards.');
        return;
      }
      const selectedVersions = new Set(targetVersionChoices.getValue(true));
      const selectedPiBases = new Set(piChoices.getValue(true));
      const allowCommitted = document.getElementById('suffixCommitted').checked;
      const allowPlanned = document.getElementById('suffixPlanned').checked;
      const allowSpillover = document.getElementById('suffixSpillover').checked;
      const selectedTeams = new Set(teamChoices.getValue(true));
      const selectedBoardFilters = new Set(boardFilterChoices.getValue(true));

      const filteredEpics = state.epics.filter(epic => {
        if (selectedVersions.size) {
          const versionKey = epic.targetVersionKey || '__none__';
          if (!selectedVersions.has(versionKey)) return false;
        }

        if (selectedPiBases.size) {
          let piMatch = false;
          if (!epic.pis.length && selectedPiBases.has('__none__')) {
            piMatch = true;
          }
          epic.pis.forEach(pi => {
            if (!pi || !pi.base) return;
            if (!selectedPiBases.has(pi.base)) return;
            if (pi.suffix === 'committed' && !allowCommitted) return;
            if (pi.suffix === 'planned' && !allowPlanned) return;
            if (pi.suffix === 'spillover' && !allowSpillover) return;
            piMatch = true;
          });
          if (!piMatch) return false;
        }

        if (selectedTeams.size) {
          const team = epic.responsibleTeam || 'Unassigned Team';
          if (!selectedTeams.has(team)) return false;
        }

        if (selectedBoardFilters.size) {
          const boards = epic.boardIds && epic.boardIds.size
            ? Array.from(epic.boardIds).map(String)
            : ['__unassigned__'];
          if (!boards.some(id => selectedBoardFilters.has(id))) return false;
        }

        return true;
      });

      const filteredEpicKeys = new Set(filteredEpics.map(epic => epic.key));
      const filteredIssues = state.normalizedIssues.filter(issue => filteredEpicKeys.has(issue.parentKey));

      state.filteredEpics = filteredEpics;
      state.filteredIssues = filteredIssues;
      state.aggregated = aggregateIssues(filteredIssues);
      computeEpicCoverage(filteredEpics, filteredIssues);
      renderKpis();
      updateCharts();
      renderEpicTable();
      renderChildTable();
      renderReleasesTable();

      if (!filteredEpics.length) {
        setLoading('No epics match the current filter selection.');
      } else if (!filteredIssues.length) {
        setLoading('Filtered epics do not have matching child items.');
      } else {
        setLoading('');
      }
    }

    function getUpcomingReleases() {
      if (!state.releases.length) return [];
      const nowTime = Date.now();
      return state.releases.filter(rel => {
        if (rel.archived) return false;
        if (!rel.releaseDate) return !rel.released;
        const date = new Date(rel.releaseDate);
        if (Number.isNaN(date.getTime())) return !rel.released;
        return !rel.released || date.getTime() >= nowTime;
      }).sort((a, b) => {
        const aTime = a.releaseDate ? new Date(a.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        const bTime = b.releaseDate ? new Date(b.releaseDate).getTime() : Number.MAX_SAFE_INTEGER;
        if (aTime === bTime) return a.name.localeCompare(b.name, undefined, { numeric: true });
        return aTime - bTime;
      });
    }

    function renderReleasesTable() {
      const tbody = document.getElementById('releasesTableBody');
      if (!tbody) return;
      const releases = getUpcomingReleases();
      const search = document.getElementById('releaseSearch').value.trim().toLowerCase();

      if (!releases.length) {
        tbody.innerHTML = '';
        document.getElementById('releasesSection').style.display = 'none';
        document.getElementById('releasesEmpty').style.display = '';
        return;
      }

      document.getElementById('releasesSection').style.display = '';
      document.getElementById('releasesEmpty').style.display = 'none';

      const statsMap = new Map();
      releases.forEach(rel => {
        statsMap.set(rel.uniqueKey, {
          release: rel,
          total: 0,
          withTarget: 0,
        });
      });

      state.filteredIssues.forEach(issue => {
        if (!issue.fixVersions || !issue.fixVersions.length) return;
        issue.fixVersions.forEach(version => {
          if (!version.key) return;
          const stats = statsMap.get(version.key);
          if (!stats) return;
          stats.total += 1;
          if (issue.hasTargetVersion) stats.withTarget += 1;
        });
      });

      const rows = Array.from(statsMap.values()).map(stats => {
        const release = stats.release;
        const boardName = state.boardsMap.get(Number(release.boardId))?.name || `Board ${release.boardId}`;
        const projectName = release.projectName || '';
        const projectKey = release.projectKey || '';
        const displayProject = projectName || projectKey || '—';
        const matchHaystack = [
          release.name,
          boardName,
          projectName,
          projectKey,
        ].join(' ').toLowerCase();
        if (search && !matchHaystack.includes(search)) return null;
        const pct = stats.total ? Math.round((stats.withTarget / stats.total) * 100) : 0;
        return {
          release,
          boardName,
          displayProject,
          status: release.released ? 'Released' : 'Unreleased',
          total: stats.total,
          withTarget: stats.withTarget,
          pct,
        };
      }).filter(Boolean);

      tbody.innerHTML = '';
      if (!rows.length) {
        document.getElementById('releasesEmpty').style.display = '';
        return;
      }
      document.getElementById('releasesEmpty').style.display = 'none';

      rows.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${row.release.name}</td>
          <td>${row.boardName}</td>
          <td>${row.displayProject}</td>
          <td>${row.status}</td>
          <td>${row.release.startDate ? formatDate(row.release.startDate) : '—'}</td>
          <td>${row.release.releaseDate ? formatDate(row.release.releaseDate) : '—'}</td>
          <td>${row.total}</td>
          <td>${row.withTarget}</td>
          <td>${row.pct}%</td>
        `;
        tbody.appendChild(tr);
      });

    }

    function renderKpis() {
      const total = state.filteredIssues.length;
      const withTarget = state.filteredIssues.filter(i => i.hasTargetVersion).length;
      const withoutTarget = total - withTarget;
      const pct = total ? ((withTarget / total) * 100).toFixed(1) : '0.0';
      document.getElementById('kpiTotal').textContent = total;
      document.getElementById('kpiWith').textContent = withTarget;
      document.getElementById('kpiWithout').textContent = withoutTarget;
      document.getElementById('kpiPct').textContent = `${pct}%`;
      document.getElementById('kpiSection').style.display = '';
      document.getElementById('chartsSection').style.display = state.filteredIssues.length ? '' : 'none';
      document.getElementById('epicSection').style.display = '';
      document.getElementById('childSection').style.display = '';
    }

    function buildStackedData(dimension) {
      const buckets = dimension === 'pi' ? state.aggregated.byPi : state.aggregated.byTargetVersion;
      const labels = buckets.map(b => b.label);
      const teamNames = new Set();
      buckets.forEach(bucket => {
        Object.keys(bucket.teams).forEach(team => teamNames.add(team));
      });
      const datasets = [];
      Array.from(teamNames.values()).sort().forEach(team => {
        const color = teamColor(team);
        datasets.push({
          label: `${team} – With Target`,
          data: buckets.map(bucket => (bucket.teams[team]?.withTarget || 0)),
          backgroundColor: colorWithAlpha(color, 0.85),
          stack: team,
          borderRadius: 4,
        });
        datasets.push({
          label: `${team} – Without Target`,
          data: buckets.map(bucket => (bucket.teams[team]?.withoutTarget || 0)),
          backgroundColor: colorWithAlpha(color, 0.45),
          stack: team,
          borderRadius: 4,
        });
      });
      return { labels, datasets };
    }

    function buildDistributionData(mode) {
      if (mode === 'team') {
        const labels = state.aggregated.byTeam.map(t => t.team);
        return {
          labels,
          datasets: [
            {
              label: 'With Target',
              data: state.aggregated.byTeam.map(t => t.withTarget),
              backgroundColor: '#10b981',
              stack: 'total',
              borderRadius: 4,
            },
            {
              label: 'Without Target',
              data: state.aggregated.byTeam.map(t => t.withoutTarget),
              backgroundColor: '#f97316',
              stack: 'total',
              borderRadius: 4,
            }
          ]
        };
      }
      const source = mode === 'targetVersion' ? state.aggregated.byTargetVersion : state.aggregated.byPi;
      const labels = source.map(b => b.label);
      return {
        labels,
        datasets: [
          {
            label: 'With Target',
            data: source.map(b => b.withTarget),
            backgroundColor: '#3b82f6',
            stack: 'total',
            borderRadius: 4,
          },
          {
            label: 'Without Target',
            data: source.map(b => b.withoutTarget),
            backgroundColor: '#ef4444',
            stack: 'total',
            borderRadius: 4,
          }
        ]
      };
    }

    function updateCharts() {
      if (!state.aggregated) return;
      const stackedDimension = document.querySelector('input[name="stackedDimension"]:checked').value;
      const stackedData = buildStackedData(stackedDimension);
      const distributionMode = document.getElementById('distributionMode').value;
      const distributionData = buildDistributionData(distributionMode);

      const stackedCtx = document.getElementById('stackedChart').getContext('2d');
      if (!stackedChart) {
        stackedChart = new Chart(stackedCtx, {
          type: 'bar',
          data: stackedData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { stacked: true, ticks: { autoSkip: false, maxRotation: 45, minRotation: 0 } },
              y: { stacked: true, beginAtZero: true }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: { mode: 'index', intersect: false }
            }
          }
        });
      } else {
        stackedChart.data = stackedData;
        stackedChart.update();
      }

      const distributionCtx = document.getElementById('distributionChart').getContext('2d');
      if (!distributionChart) {
        distributionChart = new Chart(distributionCtx, {
          type: 'bar',
          data: distributionData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
              x: { stacked: true, beginAtZero: true },
              y: { stacked: true }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: { mode: 'index', intersect: false }
            }
          }
        });
      } else {
        distributionChart.data = distributionData;
        distributionChart.update();
      }
    }

    function renderChildTable() {
      const tbody = document.getElementById('childTableBody');
      const searchInput = document.getElementById('childSearch');
      const search = searchInput ? searchInput.value.trim().toLowerCase() : '';
      const rows = state.filteredIssues.filter(issue => {
        if (!search) return true;
        const values = [
          issue.key,
          issue.summary,
          issue.responsibleTeam,
          issue.type,
          issue.status,
          issue.parentKey || '',
          issue.parentSummary || '',
          issue.targetVersion || '',
          issue.parentTargetVersion || ''
        ].join(' ').toLowerCase();
        return values.includes(search);
      });
      tbody.innerHTML = '';
      if (!rows.length) {
        document.getElementById('childEmpty').style.display = '';
        return;
      }
      document.getElementById('childEmpty').style.display = 'none';
      const domain = state.domain;
      rows.slice(0, 1500).forEach(issue => {
        const boards = issue.boardIds && issue.boardIds.size
          ? Array.from(issue.boardIds).map(id => state.boardsMap.get(Number(id))?.name || `Board ${id}`).join(', ')
          : '—';
        const team = issue.responsibleTeam || 'Unassigned Team';
        const parentDisplay = issue.parentKey
          ? `<a href="https://${domain}/browse/${issue.parentKey}" target="_blank" rel="noopener">${issue.parentKey}</a>${issue.parentSummary ? ` – ${issue.parentSummary}` : ''}`
          : '—';
        const targetDisplay = issue.hasTargetVersion ? issue.targetVersion : '—';
        const parentTarget = issue.parentTargetVersion || 'No Target Version';
        const row = document.createElement('tr');
        if (!issue.hasTargetVersion) {
          row.style.background = '#fff7ed';
        }
        row.innerHTML = `
          <td><a href="https://${domain}/browse/${issue.key}" target="_blank" rel="noopener">${issue.key}</a></td>
          <td>${issue.summary || '—'}</td>
          <td>${parentDisplay}</td>
          <td><span class="badge">${issue.type}</span></td>
          <td><span class="status-pill ${getStatusClass(issue.status)}">${issue.status}</span></td>
          <td>${team}</td>
          <td>${parentTarget}</td>
          <td>${targetDisplay}</td>
          <td>${boards}</td>
          <td>${issue.assignee || '—'}</td>
          <td>${formatDate(issue.updated)}</td>
          <td><a href="https://${domain}/browse/${issue.key}" target="_blank" rel="noopener">Open</a></td>
        `;
        tbody.appendChild(row);
      });
    }

    function renderEpicTable() {
      const tbody = document.getElementById('epicTableBody');
      const searchInput = document.getElementById('epicSearch');
      const search = searchInput ? searchInput.value.trim().toLowerCase() : '';
      const rows = state.filteredEpics.filter(epic => {
        if (!search) return true;
        const values = [
          epic.key,
          epic.summary,
          epic.responsibleTeam,
          epic.targetVersion,
          epic.pis.map(pi => pi.label).join(' '),
        ].join(' ').toLowerCase();
        return values.includes(search);
      });
      tbody.innerHTML = '';
      if (!rows.length) {
        document.getElementById('epicEmpty').style.display = '';
        return;
      }
      document.getElementById('epicEmpty').style.display = 'none';
      const domain = state.domain;
      rows.slice(0, 500).forEach(epic => {
        const boards = epic.boardIds && epic.boardIds.size
          ? Array.from(epic.boardIds).map(id => state.boardsMap.get(Number(id))?.name || `Board ${id}`).join(', ')
          : '—';
        const team = epic.responsibleTeam || 'Unassigned Team';
        const piLabels = epic.pis.length ? epic.pis.map(pi => pi.label).join(', ') : '—';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><a href="https://${domain}/browse/${epic.key}" target="_blank" rel="noopener">${epic.key}</a></td>
          <td>${epic.summary || '—'}</td>
          <td>${epic.targetVersion || 'No Target Version'}</td>
          <td>${team}</td>
          <td>${piLabels}</td>
          <td>${epic.childTotal || 0}</td>
          <td>${epic.childWithTarget || 0}</td>
          <td>${epic.childTotal ? `${epic.coveragePct}%` : '—'}</td>
          <td>${boards}</td>
        `;
        tbody.appendChild(row);
      });
    }

    function updateFilterOptions() {
      const allPis = new Map();
      const teams = new Set();
      const boardOptions = new Map();
      const versions = new Map();

      state.epics.forEach(epic => {
        const versionKey = epic.targetVersionKey || '__none__';
        const versionLabel = epic.targetVersion || 'No Target Version';
        if (!versions.has(versionKey)) {
          versions.set(versionKey, { value: versionKey, label: versionLabel });
        }

        if (!epic.pis.length) {
          if (!allPis.has('__none__')) allPis.set('__none__', { value: '__none__', label: 'No Product Increment' });
        }
        epic.pis.forEach(pi => {
          if (!allPis.has(pi.base)) {
            allPis.set(pi.base, { value: pi.base, label: pi.base });
          }
        });

        const team = epic.responsibleTeam || 'Unassigned Team';
        teams.add(team);

        if (epic.boardIds && epic.boardIds.size) {
          epic.boardIds.forEach(id => {
            const key = String(id);
            if (!boardOptions.has(key)) {
              boardOptions.set(key, { value: key, label: state.boardsMap.get(Number(id))?.name || `Board ${id}` });
            }
          });
        }
      });

      const versionChoices = Array.from(versions.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }));
      if (!versionChoices.length) versionChoices.push({ value: '__none__', label: 'No Target Version' });
      targetVersionChoices.clearChoices();
      targetVersionChoices.setChoices(versionChoices, 'value', 'label', true);

      const piChoicesData = Array.from(allPis.values()).sort((a, b) => a.label.localeCompare(b.label));
      piChoices.clearChoices();
      piChoices.setChoices(piChoicesData.length ? piChoicesData : [{ value: '__none__', label: 'No Product Increment' }], 'value', 'label', true);

      const teamChoicesData = Array.from(teams.values()).sort().map(team => ({ value: team, label: team }));
      teamChoices.clearChoices();
      teamChoices.setChoices(teamChoicesData, 'value', 'label', true);

      boardFilterChoices.clearChoices();
      const boardValues = Array.from(boardOptions.values());
      boardValues.push({ value: '__unassigned__', label: 'No Board' });
      boardFilterChoices.setChoices(boardValues, 'value', 'label', true);
    }



    async function loadBoards() {
      const domain = document.getElementById('jiraDomain').value.trim();
      if (!domain) return;
      state.domain = domain;
      try {
        setLoading('Loading boards...');
        const boards = await Jira.fetchBoardsByJql(domain);
        state.boards = boards;
        state.boardsMap = new Map(boards.map(b => [Number(b.id), b]));
        boardChoices.clearChoices();
        boardChoices.setChoices(boards.map(b => ({ value: String(b.id), label: `${b.name} (${b.id})` })), 'value', 'label', true);
        boardFilterChoices.clearChoices();
        boardFilterChoices.setChoices(boards.map(b => ({ value: String(b.id), label: `${b.name} (${b.id})` })), 'value', 'label', true);
        setLoading('');
      } catch (err) {
        Logger.error('Failed to load boards', err);
        setError('Could not load boards. Check your Jira session.');
        setLoading('');
      }
    }



    async function loadData() {
      const domain = document.getElementById('jiraDomain').value.trim();
      const boardIds = boardChoices.getValue(true);
      if (!domain) {
        setError('Jira domain is required.');
        return;
      }
      if (!boardIds.length) {
        setError('Select at least one board to query.');
        return;
      }
      setError('');
      state.domain = domain;
      try {
        setLoading('Discovering fields...');
        const responsibleField = await discoverResponsibleField(domain);
        state.responsibleFieldKey = responsibleField;
        teamColorMap.clear();

        setLoading('Loading board configurations...');
        const boardConfigs = await Promise.all(boardIds.map(async id => {
          const config = await fetchBoardConfiguration(domain, id);
          return { ...config, name: state.boardsMap.get(Number(id))?.name || config.name || `Board ${id}` };
        }));

        setLoading('Fetching releases...');
        const releaseList = [];
        await Promise.all(boardConfigs.map(async config => {
          try {
            const values = await fetchReleasesForBoard(domain, config.id);
            values.forEach(rel => releaseList.push(rel));
          } catch (err) {
            Logger.error('Failed to load releases for board', config.id, err);
          }
        }));
        const releaseUnique = new Map();
        releaseList.forEach(rel => {
          if (!releaseUnique.has(rel.uniqueKey)) releaseUnique.set(rel.uniqueKey, rel);
        });
        state.releases = Array.from(releaseUnique.values());
        state.releaseIndex = new Map(state.releases.map(rel => [rel.uniqueKey, rel]));
        if (state.releases.length) {
          const projectIds = Array.from(new Set(state.releases.map(rel => rel.projectId).filter(Boolean)));
          await Promise.all(projectIds.map(async projectId => {
            const info = await fetchProjectDetails(domain, projectId);
            if (info) {
              state.releases.forEach(rel => {
                if (rel.projectId === projectId) {
                  rel.projectKey = info.key;
                  rel.projectName = info.name;
                }
              });
            }
          }));
          document.getElementById('releasesSection').style.display = '';
        } else {
          document.getElementById('releasesSection').style.display = 'none';
          document.getElementById('releasesEmpty').style.display = '';
        }

        setLoading('Fetching epics...');
        const epicMap = new Map();
        const epicsByBoard = new Map();
        await Promise.all(boardConfigs.map(async config => {
          try {
            const items = await fetchEpicsForBoard(domain, config, responsibleField);
            items.forEach(({ issue, boardId }) => {
              const normalized = normalizeEpic(issue, boardId, responsibleField);
              if (epicMap.has(normalized.key)) {
                const existing = epicMap.get(normalized.key);
                normalized.boardIds.forEach(id => existing.boardIds.add(id));
              } else {
                epicMap.set(normalized.key, normalized);
              }
              if (!epicsByBoard.has(boardId)) epicsByBoard.set(boardId, new Set());
              epicsByBoard.get(boardId).add(normalized.key);
            });
          } catch (err) {
            Logger.error('Failed to load epics for board', config.id, err);
          }
        }));

        state.epics = Array.from(epicMap.values()).sort((a, b) => a.targetVersion.localeCompare(b.targetVersion, undefined, { numeric: true }));
        state.epicMap = epicMap;

        setLoading('Fetching child items...');
        const childMap = new Map();
        await Promise.all(boardConfigs.map(async config => {
          const keys = epicsByBoard.get(config.id);
          if (!keys || !keys.size) return;
          try {
            const children = await fetchChildIssuesForBoard(domain, config, Array.from(keys), responsibleField);
            children.forEach(({ issue, boardId }) => {
              const normalized = normalizeChildIssue(issue, boardId, responsibleField, epicMap);
              if (!normalized.parentKey) return;
              if (childMap.has(normalized.key)) {
                const existing = childMap.get(normalized.key);
                normalized.boardIds.forEach(id => existing.boardIds.add(id));
                if (!existing.hasTargetVersion && normalized.hasTargetVersion) {
                  existing.hasTargetVersion = true;
                  existing.targetVersion = normalized.targetVersion;
                  existing.targetVersionKey = normalized.targetVersionKey;
                  existing.targetSource = normalized.targetSource;
                }
              } else {
                childMap.set(normalized.key, normalized);
              }
            });
          } catch (err) {
            Logger.error('Failed to load child issues for board', config.id, err);
          }
        }));

        state.normalizedIssues = Array.from(childMap.values());
        computeEpicCoverage(state.epics, state.normalizedIssues);
        updateFilterOptions();
        document.getElementById('filtersSection').style.display = '';
        document.getElementById('kpiSection').style.display = '';
        document.getElementById('chartsSection').style.display = state.normalizedIssues.length ? '' : 'none';
        document.getElementById('epicSection').style.display = '';
        document.getElementById('childSection').style.display = '';

        setLoading('Applying filters...');
        state.filteredEpics = state.epics.slice();
        state.filteredIssues = state.normalizedIssues.slice();
        state.aggregated = aggregateIssues(state.normalizedIssues);
        applyFilters();
        setLoading('');
      } catch (err) {
        Logger.error('Failed to load planning data', err);
        setError('Could not fetch planning data. Verify your Jira permissions and filters.');
        setLoading('');
      }
    }

    async function exportPDF() {
      const content = document.getElementById('pdfContent');
      const canvas = await html2canvas(content, { scale: 2, useCORS: true });
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
      const imgWidth = canvas.width * ratio;
      const imgHeight = canvas.height * ratio;
      pdf.addImage(imgData, 'PNG', (pageWidth - imgWidth) / 2, 20, imgWidth, imgHeight);
      pdf.save('pi-target-version-dashboard.pdf');
    }

    function switchVersion(page) {
      if (!page) return;
      window.location.href = page;
    }

    function initVersionSelect() {
      const select = document.getElementById('versionSelect');
      if (!select) return;
      select.value = 'target_release_dashboard.html';
      select.addEventListener('change', (event) => switchVersion(event.target.value));
    }

    document.getElementById('loadDataBtn').addEventListener('click', loadData);
    document.getElementById('exportBtn').addEventListener('click', exportPDF);
    document.getElementById('jiraDomain').addEventListener('change', loadBoards);
    document.getElementById('epicSearch').addEventListener('input', () => renderEpicTable());
    document.getElementById('childSearch').addEventListener('input', () => renderChildTable());
    document.getElementById('releaseSearch').addEventListener('input', () => renderReleasesTable());
    document.querySelectorAll('input[name="stackedDimension"]').forEach(input => input.addEventListener('change', updateCharts));
    document.getElementById('distributionMode').addEventListener('change', updateCharts);
    ['suffixCommitted', 'suffixPlanned', 'suffixSpillover'].forEach(id => {
      document.getElementById(id).addEventListener('change', applyFilters);
    });

    function setupFilterReactivity() {
      ['teamSelect', 'boardFilterSelect', 'piSelect', 'targetVersionSelect'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('change', () => {
          applyFilters();
        });
      });
    }

    initVersionSelect();
    initChoices();
    setupFilterReactivity();
    loadBoards();
  </script>
</body>
</html>
